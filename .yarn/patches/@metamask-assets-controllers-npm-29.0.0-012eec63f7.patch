diff --git a/dist/NftController.js b/dist/NftController.js
index a8deb0837d7035a8368d79d32f32211c84316052..2dc829968015b4011200800b56e4551ed635599e 100644
--- a/dist/NftController.js
+++ b/dist/NftController.js
@@ -2,7 +2,7 @@
 
 
 
-var _chunkKM3J4DO6js = require('./chunk-KM3J4DO6.js');
+var _chunkF2F3NGG3js = require('./chunk-F2F3NGG3.js');
 require('./chunk-RGHTNZQ6.js');
 require('./chunk-LS6R3HQL.js');
 require('./chunk-Z4BLTVTB.js');
@@ -10,5 +10,5 @@ require('./chunk-Z4BLTVTB.js');
 
 
 
-exports.NftController = _chunkKM3J4DO6js.NftController; exports.default = _chunkKM3J4DO6js.NftController_default; exports.getDefaultNftState = _chunkKM3J4DO6js.getDefaultNftState;
+exports.NftController = _chunkF2F3NGG3js.NftController; exports.default = _chunkF2F3NGG3js.NftController_default; exports.getDefaultNftState = _chunkF2F3NGG3js.getDefaultNftState;
 //# sourceMappingURL=NftController.js.map
\ No newline at end of file
diff --git a/dist/NftController.mjs b/dist/NftController.mjs
index 60fbaaed1c38650eac48c8a59f38ae076a6cc2de..9e02524cea9277129a2aa7725e6fb753d7dd01e7 100644
--- a/dist/NftController.mjs
+++ b/dist/NftController.mjs
@@ -2,7 +2,7 @@ import {
   NftController,
   NftController_default,
   getDefaultNftState
-} from "./chunk-S6CZP74C.mjs";
+} from "./chunk-ONJIVH6M.mjs";
 import "./chunk-CP3HC7AQ.mjs";
 import "./chunk-X5PLVMOQ.mjs";
 import "./chunk-XUI43LEZ.mjs";
diff --git a/dist/TokenListController.js b/dist/TokenListController.js
index e2f1c220b4bfc0f13296cdecb638c7926380da34..dcbd7ebf2ba6ae3473b3771d40c068dc90951359 100644
--- a/dist/TokenListController.js
+++ b/dist/TokenListController.js
@@ -2,13 +2,13 @@
 
 
 
-var _chunkDEQZ35QEjs = require('./chunk-DEQZ35QE.js');
-require('./chunk-OHSQRYVL.js');
+var _chunkU36OEBF2js = require('./chunk-U36OEBF2.js');
+require('./chunk-OKEA7NPV.js');
 require('./chunk-LS6R3HQL.js');
 require('./chunk-Z4BLTVTB.js');
 
 
 
 
-exports.TokenListController = _chunkDEQZ35QEjs.TokenListController; exports.default = _chunkDEQZ35QEjs.TokenListController_default; exports.getDefaultTokenListState = _chunkDEQZ35QEjs.getDefaultTokenListState;
+exports.TokenListController = _chunkU36OEBF2js.TokenListController; exports.default = _chunkU36OEBF2js.TokenListController_default; exports.getDefaultTokenListState = _chunkU36OEBF2js.getDefaultTokenListState;
 //# sourceMappingURL=TokenListController.js.map
\ No newline at end of file
diff --git a/dist/TokenListController.mjs b/dist/TokenListController.mjs
index 4361aaf9d40cafc5b3da5416afe522807f5d8310..1787b125a59965ea0853c4f3a8eef49a09638eac 100644
--- a/dist/TokenListController.mjs
+++ b/dist/TokenListController.mjs
@@ -2,8 +2,8 @@ import {
   TokenListController,
   TokenListController_default,
   getDefaultTokenListState
-} from "./chunk-RUE635TV.mjs";
-import "./chunk-NXGX7LZJ.mjs";
+} from "./chunk-C64L6MMU.mjs";
+import "./chunk-S6KASB6I.mjs";
 import "./chunk-X5PLVMOQ.mjs";
 import "./chunk-XUI43LEZ.mjs";
 export {
diff --git a/dist/TokenRatesController.js b/dist/TokenRatesController.js
index 4aee145d134df0336bbbe61e2172b783986e2759..e0b585c7d8301bb3ddd52536e89c5c086dab444b 100644
--- a/dist/TokenRatesController.js
+++ b/dist/TokenRatesController.js
@@ -1,12 +1,12 @@
 "use strict";Object.defineProperty(exports, "__esModule", {value: true});
 
 
-var _chunkIOQX3VTDjs = require('./chunk-IOQX3VTD.js');
+var _chunk6MY5FIJBjs = require('./chunk-6MY5FIJB.js');
 require('./chunk-DYH5P3VY.js');
 require('./chunk-LS6R3HQL.js');
 require('./chunk-Z4BLTVTB.js');
 
 
 
-exports.TokenRatesController = _chunkIOQX3VTDjs.TokenRatesController; exports.default = _chunkIOQX3VTDjs.TokenRatesController_default;
+exports.TokenRatesController = _chunk6MY5FIJBjs.TokenRatesController; exports.default = _chunk6MY5FIJBjs.TokenRatesController_default;
 //# sourceMappingURL=TokenRatesController.js.map
\ No newline at end of file
diff --git a/dist/TokenRatesController.mjs b/dist/TokenRatesController.mjs
index a9799c1bd9bda6768fc449e77b3f528f4fc4e03c..c58d2667f4c4c57eb9a52b002b7a8d522487bd06 100644
--- a/dist/TokenRatesController.mjs
+++ b/dist/TokenRatesController.mjs
@@ -1,7 +1,7 @@
 import {
   TokenRatesController,
   TokenRatesController_default
-} from "./chunk-OWTCG2N3.mjs";
+} from "./chunk-4L54AXTJ.mjs";
 import "./chunk-PWZE6KJV.mjs";
 import "./chunk-X5PLVMOQ.mjs";
 import "./chunk-XUI43LEZ.mjs";
diff --git a/dist/TokensController.js b/dist/TokensController.js
index aa40003710def85737e76b1fed5bd034b3ac7b7d..ddc9a28adf5651aeabe78d07064226e2da868c9b 100644
--- a/dist/TokensController.js
+++ b/dist/TokensController.js
@@ -2,15 +2,15 @@
 
 
 
-var _chunkSOK5YX7Ijs = require('./chunk-SOK5YX7I.js');
+var _chunkAVPUXAZYjs = require('./chunk-AVPUXAZY.js');
 require('./chunk-3ZHN4GFT.js');
 require('./chunk-BO2WZDUM.js');
-require('./chunk-OHSQRYVL.js');
+require('./chunk-OKEA7NPV.js');
 require('./chunk-LS6R3HQL.js');
 require('./chunk-Z4BLTVTB.js');
 
 
 
 
-exports.TokensController = _chunkSOK5YX7Ijs.TokensController; exports.default = _chunkSOK5YX7Ijs.TokensController_default; exports.getDefaultTokensState = _chunkSOK5YX7Ijs.getDefaultTokensState;
+exports.TokensController = _chunkAVPUXAZYjs.TokensController; exports.default = _chunkAVPUXAZYjs.TokensController_default; exports.getDefaultTokensState = _chunkAVPUXAZYjs.getDefaultTokensState;
 //# sourceMappingURL=TokensController.js.map
\ No newline at end of file
diff --git a/dist/TokensController.mjs b/dist/TokensController.mjs
index ea42abe63ec496f6e039d449907938d7e99bc53f..e9458ddb10b6e75f58c525731ab62c7a926ce3d8 100644
--- a/dist/TokensController.mjs
+++ b/dist/TokensController.mjs
@@ -2,10 +2,10 @@ import {
   TokensController,
   TokensController_default,
   getDefaultTokensState
-} from "./chunk-6XOM7KOQ.mjs";
+} from "./chunk-MDHJNCTR.mjs";
 import "./chunk-S7UA2DU7.mjs";
 import "./chunk-LLYYJY7H.mjs";
-import "./chunk-NXGX7LZJ.mjs";
+import "./chunk-S6KASB6I.mjs";
 import "./chunk-X5PLVMOQ.mjs";
 import "./chunk-XUI43LEZ.mjs";
 export {
diff --git a/dist/chunk-4FMVFW2T.js b/dist/chunk-4FMVFW2T.js
deleted file mode 100644
index 1a99f58eac10b2b966e452cf7fb16cf67288b79d..0000000000000000000000000000000000000000
--- a/dist/chunk-4FMVFW2T.js
+++ /dev/null
@@ -1,343 +0,0 @@
-"use strict";Object.defineProperty(exports, "__esModule", {value: true});
-
-
-
-var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
-
-// src/token-prices-service/codefi-v2.ts
-var _controllerutils = require('@metamask/controller-utils');
-var _utils = require('@metamask/utils');
-
-
-
-
-
-
-
-
-var _cockatiel = require('cockatiel');
-var SUPPORTED_CURRENCIES = [
-  // Bitcoin
-  "btc",
-  // Ether
-  "eth",
-  // Litecoin
-  "ltc",
-  // Bitcoin Cash
-  "bch",
-  // Binance Coin
-  "bnb",
-  // EOS
-  "eos",
-  // XRP
-  "xrp",
-  // Lumens
-  "xlm",
-  // Chainlink
-  "link",
-  // Polkadot
-  "dot",
-  // Yearn.finance
-  "yfi",
-  // US Dollar
-  "usd",
-  // United Arab Emirates Dirham
-  "aed",
-  // Argentine Peso
-  "ars",
-  // Australian Dollar
-  "aud",
-  // Bangladeshi Taka
-  "bdt",
-  // Bahraini Dinar
-  "bhd",
-  // Bermudian Dollar
-  "bmd",
-  // Brazil Real
-  "brl",
-  // Canadian Dollar
-  "cad",
-  // Swiss Franc
-  "chf",
-  // Chilean Peso
-  "clp",
-  // Chinese Yuan
-  "cny",
-  // Czech Koruna
-  "czk",
-  // Danish Krone
-  "dkk",
-  // Euro
-  "eur",
-  // British Pound Sterling
-  "gbp",
-  // Hong Kong Dollar
-  "hkd",
-  // Hungarian Forint
-  "huf",
-  // Indonesian Rupiah
-  "idr",
-  // Israeli New Shekel
-  "ils",
-  // Indian Rupee
-  "inr",
-  // Japanese Yen
-  "jpy",
-  // South Korean Won
-  "krw",
-  // Kuwaiti Dinar
-  "kwd",
-  // Sri Lankan Rupee
-  "lkr",
-  // Burmese Kyat
-  "mmk",
-  // Mexican Peso
-  "mxn",
-  // Malaysian Ringgit
-  "myr",
-  // Nigerian Naira
-  "ngn",
-  // Norwegian Krone
-  "nok",
-  // New Zealand Dollar
-  "nzd",
-  // Philippine Peso
-  "php",
-  // Pakistani Rupee
-  "pkr",
-  // Polish Zloty
-  "pln",
-  // Russian Ruble
-  "rub",
-  // Saudi Riyal
-  "sar",
-  // Swedish Krona
-  "sek",
-  // Singapore Dollar
-  "sgd",
-  // Thai Baht
-  "thb",
-  // Turkish Lira
-  "try",
-  // New Taiwan Dollar
-  "twd",
-  // Ukrainian hryvnia
-  "uah",
-  // Venezuelan bolívar fuerte
-  "vef",
-  // Vietnamese đồng
-  "vnd",
-  // South African Rand
-  "zar",
-  // IMF Special Drawing Rights
-  "xdr",
-  // Silver - Troy Ounce
-  "xag",
-  // Gold - Troy Ounce
-  "xau",
-  // Bits
-  "bits",
-  // Satoshi
-  "sats"
-];
-var SUPPORTED_CHAIN_IDS = [
-  // Ethereum Mainnet
-  "0x1",
-  // OP Mainnet
-  "0xa",
-  // Cronos Mainnet
-  "0x19",
-  // BNB Smart Chain Mainnet
-  "0x38",
-  // Syscoin Mainnet
-  "0x39",
-  // OKXChain Mainnet
-  "0x42",
-  // Hoo Smart Chain
-  "0x46",
-  // Meter Mainnet
-  "0x52",
-  // TomoChain
-  "0x58",
-  // Gnosis
-  "0x64",
-  // Velas EVM Mainnet
-  "0x6a",
-  // Fuse Mainnet
-  "0x7a",
-  // Huobi ECO Chain Mainnet
-  "0x80",
-  // Polygon Mainnet
-  "0x89",
-  // Fantom Opera
-  "0xfa",
-  // Boba Network
-  "0x120",
-  // KCC Mainnet
-  "0x141",
-  // zkSync Era Mainnet
-  "0x144",
-  // Theta Mainnet
-  "0x169",
-  // Metis Andromeda Mainnet
-  "0x440",
-  // Moonbeam
-  "0x504",
-  // Moonriver
-  "0x505",
-  // Base
-  "0x2105",
-  // Shiden
-  "0x150",
-  // Smart Bitcoin Cash
-  "0x2710",
-  // Arbitrum One
-  "0xa4b1",
-  // Celo Mainnet
-  "0xa4ec",
-  // Oasis Emerald
-  "0xa516",
-  // Avalanche C-Chain
-  "0xa86a",
-  // Polis Mainnet
-  "0x518af",
-  // Aurora Mainnet
-  "0x4e454152",
-  // Harmony Mainnet Shard 0
-  "0x63564c40",
-  // Linea Mainnet
-  "0xe708"
-];
-var BASE_URL = "https://price-api.metafi.codefi.network/v2";
-var DEFAULT_TOKEN_PRICE_RETRIES = 3;
-var DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES = (1 + DEFAULT_TOKEN_PRICE_RETRIES) * 3;
-var DEFAULT_DEGRADED_THRESHOLD = 5e3;
-var _tokenPricePolicy;
-var CodefiTokenPricesServiceV2 = class {
-  /**
-   * Construct a Codefi Token Price Service.
-   *
-   * @param options - Constructor options
-   * @param options.degradedThreshold - The threshold between "normal" and "degrated" service,
-   * in milliseconds.
-   * @param options.retries - Number of retry attempts for each token price update.
-   * @param options.maximumConsecutiveFailures - The maximum number of consecutive failures
-   * allowed before breaking the circuit and pausing further updates.
-   * @param options.onBreak - An event handler for when the circuit breaks, useful for capturing
-   * metrics about network failures.
-   * @param options.onDegraded - An event handler for when the circuit remains closed, but requests
-   * are failing or resolving too slowly (i.e. resolving more slowly than the `degradedThreshold).
-   * @param options.circuitBreakDuration - The amount of time to wait when the circuit breaks
-   * from too many consecutive failures.
-   */
-  constructor({
-    degradedThreshold = DEFAULT_DEGRADED_THRESHOLD,
-    retries = DEFAULT_TOKEN_PRICE_RETRIES,
-    maximumConsecutiveFailures = DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES,
-    onBreak,
-    onDegraded,
-    circuitBreakDuration = 30 * 60 * 1e3
-  } = {}) {
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _tokenPricePolicy, void 0);
-    const retryPolicy = _cockatiel.retry.call(void 0, _cockatiel.handleAll, {
-      maxAttempts: retries,
-      backoff: new (0, _cockatiel.ExponentialBackoff)()
-    });
-    const circuitBreakerPolicy = _cockatiel.circuitBreaker.call(void 0, _cockatiel.handleAll, {
-      halfOpenAfter: circuitBreakDuration,
-      breaker: new (0, _cockatiel.ConsecutiveBreaker)(maximumConsecutiveFailures)
-    });
-    if (onBreak) {
-      circuitBreakerPolicy.onBreak(onBreak);
-    }
-    if (onDegraded) {
-      retryPolicy.onGiveUp(() => {
-        if (circuitBreakerPolicy.state === _cockatiel.CircuitState.Closed) {
-          onDegraded();
-        }
-      });
-      retryPolicy.onSuccess(({ duration }) => {
-        if (circuitBreakerPolicy.state === _cockatiel.CircuitState.Closed && duration > degradedThreshold) {
-          onDegraded();
-        }
-      });
-    }
-    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _tokenPricePolicy, _cockatiel.wrap.call(void 0, retryPolicy, circuitBreakerPolicy));
-  }
-  /**
-   * Retrieves prices in the given currency for the tokens identified by the
-   * given addresses which are expected to live on the given chain.
-   *
-   * @param args - The arguments to function.
-   * @param args.chainId - An EIP-155 chain ID.
-   * @param args.tokenAddresses - Addresses for tokens that live on the chain.
-   * @param args.currency - The desired currency of the token prices.
-   * @returns The prices for the requested tokens.
-   */
-  async fetchTokenPrices({
-    chainId,
-    tokenAddresses,
-    currency
-  }) {
-    const chainIdAsNumber = _utils.hexToNumber.call(void 0, chainId);
-    const url = new URL(`${BASE_URL}/chains/${chainIdAsNumber}/spot-prices`);
-    url.searchParams.append("tokenAddresses", tokenAddresses.join(","));
-    url.searchParams.append("vsCurrency", currency);
-    const pricesByCurrencyByTokenAddress = await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _tokenPricePolicy).execute(
-      () => _controllerutils.handleFetch.call(void 0, url, { headers: { "Cache-Control": "no-cache" } })
-    );
-    return tokenAddresses.reduce(
-      (obj, tokenAddress) => {
-        const lowercasedTokenAddress = tokenAddress.toLowerCase();
-        const lowercasedCurrency = currency.toLowerCase();
-        const price = pricesByCurrencyByTokenAddress[lowercasedTokenAddress]?.[lowercasedCurrency];
-        if (!price) {
-          console.error(
-            `Could not find price for "${tokenAddress}" in "${currency}"`
-          );
-        }
-        const tokenPrice = {
-          tokenAddress,
-          value: price,
-          currency
-        };
-        return {
-          ...obj,
-          ...tokenPrice.value !== void 0 ? { [tokenAddress]: tokenPrice } : {}
-        };
-      },
-      {}
-    );
-  }
-  /**
-   * Type guard for whether the API can return token prices for the given chain
-   * ID.
-   *
-   * @param chainId - The chain ID to check.
-   * @returns True if the API supports the chain ID, false otherwise.
-   */
-  validateChainIdSupported(chainId) {
-    const supportedChainIds = SUPPORTED_CHAIN_IDS;
-    return typeof chainId === "string" && supportedChainIds.includes(chainId);
-  }
-  /**
-   * Type guard for whether the API can return token prices in the given
-   * currency.
-   *
-   * @param currency - The currency to check. If a string, can be either
-   * lowercase or uppercase.
-   * @returns True if the API supports the currency, false otherwise.
-   */
-  validateCurrencySupported(currency) {
-    const supportedCurrencies = SUPPORTED_CURRENCIES;
-    return typeof currency === "string" && supportedCurrencies.includes(currency.toLowerCase());
-  }
-};
-_tokenPricePolicy = new WeakMap();
-
-
-
-
-
-exports.SUPPORTED_CURRENCIES = SUPPORTED_CURRENCIES; exports.SUPPORTED_CHAIN_IDS = SUPPORTED_CHAIN_IDS; exports.CodefiTokenPricesServiceV2 = CodefiTokenPricesServiceV2;
-//# sourceMappingURL=chunk-4FMVFW2T.js.map
\ No newline at end of file
diff --git a/dist/chunk-4FMVFW2T.js.map b/dist/chunk-4FMVFW2T.js.map
deleted file mode 100644
index 494bb0d12a4e47121a5adee89e71e10a35e136ca..0000000000000000000000000000000000000000
--- a/dist/chunk-4FMVFW2T.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["../src/token-prices-service/codefi-v2.ts"],"names":[],"mappings":"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","sourcesContent":["import { handleFetch } from '@metamask/controller-utils';\nimport type { Hex } from '@metamask/utils';\nimport { hexToNumber } from '@metamask/utils';\nimport {\n  circuitBreaker,\n  ConsecutiveBreaker,\n  ExponentialBackoff,\n  handleAll,\n  type IPolicy,\n  retry,\n  wrap,\n  CircuitState,\n} from 'cockatiel';\n\nimport type {\n  AbstractTokenPricesService,\n  TokenPrice,\n  TokenPricesByTokenAddress,\n} from './abstract-token-prices-service';\n\n/**\n * The shape of the data that the /spot-prices endpoint returns.\n */\ntype SpotPricesEndpointData<\n  TokenAddress extends Hex,\n  Currency extends string,\n> = Record<TokenAddress, Record<Currency, number>>;\n\n/**\n * The list of currencies that can be supplied as the `vsCurrency` parameter to\n * the `/spot-prices` endpoint, in lowercase form.\n */\nexport const SUPPORTED_CURRENCIES = [\n  // Bitcoin\n  'btc',\n  // Ether\n  'eth',\n  // Litecoin\n  'ltc',\n  // Bitcoin Cash\n  'bch',\n  // Binance Coin\n  'bnb',\n  // EOS\n  'eos',\n  // XRP\n  'xrp',\n  // Lumens\n  'xlm',\n  // Chainlink\n  'link',\n  // Polkadot\n  'dot',\n  // Yearn.finance\n  'yfi',\n  // US Dollar\n  'usd',\n  // United Arab Emirates Dirham\n  'aed',\n  // Argentine Peso\n  'ars',\n  // Australian Dollar\n  'aud',\n  // Bangladeshi Taka\n  'bdt',\n  // Bahraini Dinar\n  'bhd',\n  // Bermudian Dollar\n  'bmd',\n  // Brazil Real\n  'brl',\n  // Canadian Dollar\n  'cad',\n  // Swiss Franc\n  'chf',\n  // Chilean Peso\n  'clp',\n  // Chinese Yuan\n  'cny',\n  // Czech Koruna\n  'czk',\n  // Danish Krone\n  'dkk',\n  // Euro\n  'eur',\n  // British Pound Sterling\n  'gbp',\n  // Hong Kong Dollar\n  'hkd',\n  // Hungarian Forint\n  'huf',\n  // Indonesian Rupiah\n  'idr',\n  // Israeli New Shekel\n  'ils',\n  // Indian Rupee\n  'inr',\n  // Japanese Yen\n  'jpy',\n  // South Korean Won\n  'krw',\n  // Kuwaiti Dinar\n  'kwd',\n  // Sri Lankan Rupee\n  'lkr',\n  // Burmese Kyat\n  'mmk',\n  // Mexican Peso\n  'mxn',\n  // Malaysian Ringgit\n  'myr',\n  // Nigerian Naira\n  'ngn',\n  // Norwegian Krone\n  'nok',\n  // New Zealand Dollar\n  'nzd',\n  // Philippine Peso\n  'php',\n  // Pakistani Rupee\n  'pkr',\n  // Polish Zloty\n  'pln',\n  // Russian Ruble\n  'rub',\n  // Saudi Riyal\n  'sar',\n  // Swedish Krona\n  'sek',\n  // Singapore Dollar\n  'sgd',\n  // Thai Baht\n  'thb',\n  // Turkish Lira\n  'try',\n  // New Taiwan Dollar\n  'twd',\n  // Ukrainian hryvnia\n  'uah',\n  // Venezuelan bolívar fuerte\n  'vef',\n  // Vietnamese đồng\n  'vnd',\n  // South African Rand\n  'zar',\n  // IMF Special Drawing Rights\n  'xdr',\n  // Silver - Troy Ounce\n  'xag',\n  // Gold - Troy Ounce\n  'xau',\n  // Bits\n  'bits',\n  // Satoshi\n  'sats',\n] as const;\n\n/**\n * A currency that can be supplied as the `vsCurrency` parameter to\n * the `/spot-prices` endpoint. Covers both uppercase and lowercase versions.\n */\ntype SupportedCurrency =\n  | (typeof SUPPORTED_CURRENCIES)[number]\n  | Uppercase<(typeof SUPPORTED_CURRENCIES)[number]>;\n\n/**\n * The list of chain IDs that can be supplied in the URL for the `/spot-prices`\n * endpoint, but in hexadecimal form (for consistency with how we represent\n * chain IDs in other places).\n * @see Used by {@link CodefiTokenPricesServiceV2} to validate that a given chain ID is supported by V2 of the Codefi Price API.\n */\nexport const SUPPORTED_CHAIN_IDS = [\n  // Ethereum Mainnet\n  '0x1',\n  // OP Mainnet\n  '0xa',\n  // Cronos Mainnet\n  '0x19',\n  // BNB Smart Chain Mainnet\n  '0x38',\n  // Syscoin Mainnet\n  '0x39',\n  // OKXChain Mainnet\n  '0x42',\n  // Hoo Smart Chain\n  '0x46',\n  // Meter Mainnet\n  '0x52',\n  // TomoChain\n  '0x58',\n  // Gnosis\n  '0x64',\n  // Velas EVM Mainnet\n  '0x6a',\n  // Fuse Mainnet\n  '0x7a',\n  // Huobi ECO Chain Mainnet\n  '0x80',\n  // Polygon Mainnet\n  '0x89',\n  // Fantom Opera\n  '0xfa',\n  // Boba Network\n  '0x120',\n  // KCC Mainnet\n  '0x141',\n  // zkSync Era Mainnet\n  '0x144',\n  // Theta Mainnet\n  '0x169',\n  // Metis Andromeda Mainnet\n  '0x440',\n  // Moonbeam\n  '0x504',\n  // Moonriver\n  '0x505',\n  // Base\n  '0x2105',\n  // Shiden\n  '0x150',\n  // Smart Bitcoin Cash\n  '0x2710',\n  // Arbitrum One\n  '0xa4b1',\n  // Celo Mainnet\n  '0xa4ec',\n  // Oasis Emerald\n  '0xa516',\n  // Avalanche C-Chain\n  '0xa86a',\n  // Polis Mainnet\n  '0x518af',\n  // Aurora Mainnet\n  '0x4e454152',\n  // Harmony Mainnet Shard 0\n  '0x63564c40',\n  // Linea Mainnet\n  '0xe708',\n] as const;\n\n/**\n * A chain ID that can be supplied in the URL for the `/spot-prices` endpoint,\n * but in hexadecimal form (for consistency with how we represent chain IDs in\n * other places).\n */\ntype SupportedChainId = (typeof SUPPORTED_CHAIN_IDS)[number];\n\n/**\n * All requests to V2 of the Price API start with this.\n */\nconst BASE_URL = 'https://price-api.metafi.codefi.network/v2';\n\nconst DEFAULT_TOKEN_PRICE_RETRIES = 3;\n// Each update attempt will result (1 + retries) calls if the server is down\nconst DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES =\n  (1 + DEFAULT_TOKEN_PRICE_RETRIES) * 3;\n\nconst DEFAULT_DEGRADED_THRESHOLD = 5_000;\n\n/**\n * This version of the token prices service uses V2 of the Codefi Price API to\n * fetch token prices.\n */\nexport class CodefiTokenPricesServiceV2\n  implements\n    AbstractTokenPricesService<SupportedChainId, Hex, SupportedCurrency>\n{\n  #tokenPricePolicy: IPolicy;\n\n  /**\n   * Construct a Codefi Token Price Service.\n   *\n   * @param options - Constructor options\n   * @param options.degradedThreshold - The threshold between \"normal\" and \"degrated\" service,\n   * in milliseconds.\n   * @param options.retries - Number of retry attempts for each token price update.\n   * @param options.maximumConsecutiveFailures - The maximum number of consecutive failures\n   * allowed before breaking the circuit and pausing further updates.\n   * @param options.onBreak - An event handler for when the circuit breaks, useful for capturing\n   * metrics about network failures.\n   * @param options.onDegraded - An event handler for when the circuit remains closed, but requests\n   * are failing or resolving too slowly (i.e. resolving more slowly than the `degradedThreshold).\n   * @param options.circuitBreakDuration - The amount of time to wait when the circuit breaks\n   * from too many consecutive failures.\n   */\n  constructor({\n    degradedThreshold = DEFAULT_DEGRADED_THRESHOLD,\n    retries = DEFAULT_TOKEN_PRICE_RETRIES,\n    maximumConsecutiveFailures = DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES,\n    onBreak,\n    onDegraded,\n    circuitBreakDuration = 30 * 60 * 1000,\n  }: {\n    degradedThreshold?: number;\n    retries?: number;\n    maximumConsecutiveFailures?: number;\n    onBreak?: () => void;\n    onDegraded?: () => void;\n    circuitBreakDuration?: number;\n  } = {}) {\n    // Construct a policy that will retry each update, and halt further updates\n    // for a certain period after too many consecutive failures.\n    const retryPolicy = retry(handleAll, {\n      maxAttempts: retries,\n      backoff: new ExponentialBackoff(),\n    });\n    const circuitBreakerPolicy = circuitBreaker(handleAll, {\n      halfOpenAfter: circuitBreakDuration,\n      breaker: new ConsecutiveBreaker(maximumConsecutiveFailures),\n    });\n    if (onBreak) {\n      circuitBreakerPolicy.onBreak(onBreak);\n    }\n    if (onDegraded) {\n      retryPolicy.onGiveUp(() => {\n        if (circuitBreakerPolicy.state === CircuitState.Closed) {\n          onDegraded();\n        }\n      });\n      retryPolicy.onSuccess(({ duration }) => {\n        if (\n          circuitBreakerPolicy.state === CircuitState.Closed &&\n          duration > degradedThreshold\n        ) {\n          onDegraded();\n        }\n      });\n    }\n    this.#tokenPricePolicy = wrap(retryPolicy, circuitBreakerPolicy);\n  }\n\n  /**\n   * Retrieves prices in the given currency for the tokens identified by the\n   * given addresses which are expected to live on the given chain.\n   *\n   * @param args - The arguments to function.\n   * @param args.chainId - An EIP-155 chain ID.\n   * @param args.tokenAddresses - Addresses for tokens that live on the chain.\n   * @param args.currency - The desired currency of the token prices.\n   * @returns The prices for the requested tokens.\n   */\n  async fetchTokenPrices({\n    chainId,\n    tokenAddresses,\n    currency,\n  }: {\n    chainId: SupportedChainId;\n    tokenAddresses: Hex[];\n    currency: SupportedCurrency;\n  }): Promise<Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>> {\n    const chainIdAsNumber = hexToNumber(chainId);\n\n    const url = new URL(`${BASE_URL}/chains/${chainIdAsNumber}/spot-prices`);\n    url.searchParams.append('tokenAddresses', tokenAddresses.join(','));\n    url.searchParams.append('vsCurrency', currency);\n\n    const pricesByCurrencyByTokenAddress: SpotPricesEndpointData<\n      Lowercase<Hex>,\n      Lowercase<SupportedCurrency>\n    > = await this.#tokenPricePolicy.execute(() =>\n      handleFetch(url, { headers: { 'Cache-Control': 'no-cache' } }),\n    );\n\n    return tokenAddresses.reduce(\n      (\n        obj: Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>,\n        tokenAddress,\n      ) => {\n        // The Price API lowercases both currency and token addresses, so we have\n        // to keep track of them and make sure we return the original versions.\n        const lowercasedTokenAddress =\n          tokenAddress.toLowerCase() as Lowercase<Hex>;\n        const lowercasedCurrency =\n          currency.toLowerCase() as Lowercase<SupportedCurrency>;\n\n        const price =\n          pricesByCurrencyByTokenAddress[lowercasedTokenAddress]?.[\n            lowercasedCurrency\n          ];\n\n        if (!price) {\n          // console error instead of throwing to not interrupt the fetching of other tokens in case just one fails\n          console.error(\n            `Could not find price for \"${tokenAddress}\" in \"${currency}\"`,\n          );\n        }\n\n        const tokenPrice: TokenPrice<Hex, SupportedCurrency> = {\n          tokenAddress,\n          value: price,\n          currency,\n        };\n\n        return {\n          ...obj,\n          ...(tokenPrice.value !== undefined\n            ? { [tokenAddress]: tokenPrice }\n            : {}),\n        };\n      },\n      {},\n    ) as Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>;\n  }\n\n  /**\n   * Type guard for whether the API can return token prices for the given chain\n   * ID.\n   *\n   * @param chainId - The chain ID to check.\n   * @returns True if the API supports the chain ID, false otherwise.\n   */\n  validateChainIdSupported(chainId: unknown): chainId is SupportedChainId {\n    const supportedChainIds: readonly string[] = SUPPORTED_CHAIN_IDS;\n    return typeof chainId === 'string' && supportedChainIds.includes(chainId);\n  }\n\n  /**\n   * Type guard for whether the API can return token prices in the given\n   * currency.\n   *\n   * @param currency - The currency to check. If a string, can be either\n   * lowercase or uppercase.\n   * @returns True if the API supports the currency, false otherwise.\n   */\n  validateCurrencySupported(currency: unknown): currency is SupportedCurrency {\n    const supportedCurrencies: readonly string[] = SUPPORTED_CURRENCIES;\n    return (\n      typeof currency === 'string' &&\n      supportedCurrencies.includes(currency.toLowerCase())\n    );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/chunk-4L54AXTJ.mjs b/dist/chunk-4L54AXTJ.mjs
new file mode 100644
index 0000000000000000000000000000000000000000..e1a1b96b84be63c34234b8df4e7ffd5251d116f1
--- /dev/null
+++ b/dist/chunk-4L54AXTJ.mjs
@@ -0,0 +1,441 @@
+import {
+  fetchExchangeRate
+} from "./chunk-PWZE6KJV.mjs";
+import {
+  TOKEN_PRICES_BATCH_SIZE,
+  reduceInBatchesSerially
+} from "./chunk-X5PLVMOQ.mjs";
+import {
+  __privateAdd,
+  __privateGet,
+  __privateMethod,
+  __privateSet
+} from "./chunk-XUI43LEZ.mjs";
+
+// src/TokenRatesController.ts
+import {
+  safelyExecute,
+  toChecksumHexAddress,
+  FALL_BACK_VS_CURRENCY,
+  toHex
+} from "@metamask/controller-utils";
+import { StaticIntervalPollingControllerV1 } from "@metamask/polling-controller";
+import { createDeferredPromise } from "@metamask/utils";
+import { isEqual } from "lodash";
+async function getCurrencyConversionRate({
+  from,
+  to
+}) {
+  const includeUSDRate = false;
+  try {
+    const result = await fetchExchangeRate(
+      to,
+      from,
+      includeUSDRate
+    );
+    return result.conversionRate;
+  } catch (error) {
+    if (error instanceof Error && error.message.includes("market does not exist for this coin pair")) {
+      return null;
+    }
+    throw error;
+  }
+}
+var _pollState, _tokenPricesService, _inProcessExchangeRateUpdates, _getTokenAddresses, getTokenAddresses_fn, _stopPoll, stopPoll_fn, _poll, poll_fn, _fetchAndMapExchangeRates, fetchAndMapExchangeRates_fn, _fetchAndMapExchangeRatesForSupportedNativeCurrency, fetchAndMapExchangeRatesForSupportedNativeCurrency_fn, _fetchAndMapExchangeRatesForUnsupportedNativeCurrency, fetchAndMapExchangeRatesForUnsupportedNativeCurrency_fn;
+var TokenRatesController = class extends StaticIntervalPollingControllerV1 {
+  /**
+   * Creates a TokenRatesController instance.
+   *
+   * @param options - The controller options.
+   * @param options.interval - The polling interval in ms
+   * @param options.threshold - The duration in ms before metadata fetched from CoinGecko is considered stale
+   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.
+   * @param options.chainId - The chain ID of the current network.
+   * @param options.ticker - The ticker for the current network.
+   * @param options.selectedAddress - The current selected address.
+   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
+   * @param options.onTokensStateChange - Allows subscribing to token controller state changes.
+   * @param options.onNetworkStateChange - Allows subscribing to network state changes.
+   * @param options.tokenPricesService - An object in charge of retrieving token prices.
+   * @param config - Initial options used to configure this controller.
+   * @param state - Initial state to set on this controller.
+   */
+  constructor({
+    interval = 3 * 60 * 1e3,
+    threshold = 6 * 60 * 60 * 1e3,
+    getNetworkClientById,
+    chainId: initialChainId,
+    ticker: initialTicker,
+    selectedAddress: initialSelectedAddress,
+    onPreferencesStateChange,
+    onTokensStateChange,
+    onNetworkStateChange,
+    tokenPricesService
+  }, config, state) {
+    super(config, state);
+    /**
+     * Get the user's tokens for the given chain.
+     *
+     * @param chainId - The chain ID.
+     * @returns The list of tokens addresses for the current chain
+     */
+    __privateAdd(this, _getTokenAddresses);
+    /**
+     * Clear the active polling timer, if present.
+     */
+    __privateAdd(this, _stopPoll);
+    /**
+     * Poll for exchange rate updates.
+     */
+    __privateAdd(this, _poll);
+    /**
+     * Uses the token prices service to retrieve exchange rates for tokens in a
+     * particular currency.
+     *
+     * If the price API does not support the given chain ID, returns an empty
+     * object.
+     *
+     * If the price API does not support the given currency, retrieves exchange
+     * rates in a known currency instead, then converts those rates using the
+     * exchange rate between the known currency and desired currency.
+     *
+     * @param args - The arguments to this function.
+     * @param args.tokenAddresses - Addresses for tokens.
+     * @param args.chainId - The EIP-155 ID of the chain where the tokens live.
+     * @param args.nativeCurrency - The native currency in which to request
+     * exchange rates.
+     * @returns A map from token address to its exchange rate in the native
+     * currency, or an empty map if no exchange rates can be obtained for the
+     * chain ID.
+     */
+    __privateAdd(this, _fetchAndMapExchangeRates);
+    /**
+     * Retrieves prices in the given currency for the given tokens on the given
+     * chain. Ensures that token addresses are checksum addresses.
+     *
+     * @param args - The arguments to this function.
+     * @param args.tokenAddresses - Addresses for tokens.
+     * @param args.chainId - The EIP-155 ID of the chain where the tokens live.
+     * @param args.nativeCurrency - The native currency in which to request
+     * prices.
+     * @returns A map of the token addresses (as checksums) to their prices in the
+     * native currency.
+     */
+    __privateAdd(this, _fetchAndMapExchangeRatesForSupportedNativeCurrency);
+    /**
+     * If the price API does not support a given native currency, then we need to
+     * convert it to a fallback currency and feed that currency into the price
+     * API, then convert the prices to our desired native currency.
+     *
+     * @param args - The arguments to this function.
+     * @param args.tokenAddresses - Addresses for tokens.
+     * @param args.nativeCurrency - The native currency in which to request
+     * prices.
+     * @returns A map of the token addresses (as checksums) to their prices in the
+     * native currency.
+     */
+    __privateAdd(this, _fetchAndMapExchangeRatesForUnsupportedNativeCurrency);
+    __privateAdd(this, _pollState, "Inactive" /* Inactive */);
+    __privateAdd(this, _tokenPricesService, void 0);
+    __privateAdd(this, _inProcessExchangeRateUpdates, {});
+    /**
+     * Name of this controller used during composition
+     */
+    this.name = "TokenRatesController";
+    this.defaultConfig = {
+      interval,
+      threshold,
+      disabled: false,
+      nativeCurrency: initialTicker,
+      chainId: initialChainId,
+      selectedAddress: initialSelectedAddress,
+      allTokens: {},
+      // TODO: initialize these correctly, maybe as part of BaseControllerV2 migration
+      allDetectedTokens: {}
+    };
+    this.defaultState = {
+      marketData: {}
+    };
+    this.initialize();
+    this.setIntervalLength(interval);
+    this.getNetworkClientById = getNetworkClientById;
+    __privateSet(this, _tokenPricesService, tokenPricesService);
+    if (config?.disabled) {
+      this.configure({ disabled: true }, false, false);
+    }
+    onPreferencesStateChange(async ({ selectedAddress }) => {
+      if (this.config.selectedAddress !== selectedAddress) {
+        this.configure({ selectedAddress });
+        if (__privateGet(this, _pollState) === "Active" /* Active */) {
+          await this.updateExchangeRates();
+        }
+      }
+    });
+    onTokensStateChange(async ({ allTokens, allDetectedTokens }) => {
+      const previousTokenAddresses = __privateMethod(this, _getTokenAddresses, getTokenAddresses_fn).call(this, this.config.chainId);
+      this.configure({ allTokens, allDetectedTokens });
+      const newTokenAddresses = __privateMethod(this, _getTokenAddresses, getTokenAddresses_fn).call(this, this.config.chainId);
+      if (!isEqual(previousTokenAddresses, newTokenAddresses) && __privateGet(this, _pollState) === "Active" /* Active */) {
+        await this.updateExchangeRates();
+      }
+    });
+    onNetworkStateChange(async ({ providerConfig }) => {
+      const { chainId, ticker } = providerConfig;
+      if (this.config.chainId !== chainId || this.config.nativeCurrency !== ticker) {
+        this.update({ marketData: {} });
+        this.configure({ chainId, nativeCurrency: ticker });
+        if (__privateGet(this, _pollState) === "Active" /* Active */) {
+          await this.updateExchangeRates();
+        }
+      }
+    });
+  }
+  /**
+   * Start (or restart) polling.
+   */
+  async start() {
+    __privateMethod(this, _stopPoll, stopPoll_fn).call(this);
+    __privateSet(this, _pollState, "Active" /* Active */);
+    await __privateMethod(this, _poll, poll_fn).call(this);
+  }
+  /**
+   * Stop polling.
+   */
+  stop() {
+    __privateMethod(this, _stopPoll, stopPoll_fn).call(this);
+    __privateSet(this, _pollState, "Inactive" /* Inactive */);
+  }
+  /**
+   * Updates exchange rates for all tokens.
+   */
+  async updateExchangeRates() {
+    const { chainId, nativeCurrency } = this.config;
+    await this.updateExchangeRatesByChainId({
+      chainId,
+      nativeCurrency
+    });
+  }
+  /**
+   * Updates exchange rates for all tokens.
+   *
+   * @param options - The options to fetch exchange rates.
+   * @param options.chainId - The chain ID.
+   * @param options.nativeCurrency - The ticker for the chain.
+   */
+  async updateExchangeRatesByChainId({
+    chainId,
+    nativeCurrency
+  }) {
+    if (this.disabled) {
+      return;
+    }
+    const tokenAddresses = __privateMethod(this, _getTokenAddresses, getTokenAddresses_fn).call(this, chainId);
+    const updateKey = `${chainId}:${nativeCurrency}`;
+    if (updateKey in __privateGet(this, _inProcessExchangeRateUpdates)) {
+      await __privateGet(this, _inProcessExchangeRateUpdates)[updateKey];
+      return;
+    }
+    const {
+      promise: inProgressUpdate,
+      resolve: updateSucceeded,
+      reject: updateFailed
+    } = createDeferredPromise({ suppressUnhandledRejection: true });
+    __privateGet(this, _inProcessExchangeRateUpdates)[updateKey] = inProgressUpdate;
+    try {
+      const contractInformations = await __privateMethod(this, _fetchAndMapExchangeRates, fetchAndMapExchangeRates_fn).call(this, {
+        tokenAddresses,
+        chainId,
+        nativeCurrency
+      });
+      const marketData = {
+        [chainId]: {
+          ...contractInformations.marketData ?? {}
+        }
+      };
+      this.update({
+        marketData
+      });
+      updateSucceeded();
+    } catch (error) {
+      updateFailed(error);
+      throw error;
+    } finally {
+      delete __privateGet(this, _inProcessExchangeRateUpdates)[updateKey];
+    }
+  }
+  /**
+   * Updates token rates for the given networkClientId
+   *
+   * @param networkClientId - The network client ID used to get a ticker value.
+   * @returns The controller state.
+   */
+  async _executePoll(networkClientId) {
+    const networkClient = this.getNetworkClientById(networkClientId);
+    await this.updateExchangeRatesByChainId({
+      chainId: networkClient.configuration.chainId,
+      nativeCurrency: networkClient.configuration.ticker
+    });
+  }
+};
+_pollState = new WeakMap();
+_tokenPricesService = new WeakMap();
+_inProcessExchangeRateUpdates = new WeakMap();
+_getTokenAddresses = new WeakSet();
+getTokenAddresses_fn = function(chainId) {
+  const { allTokens, allDetectedTokens } = this.config;
+  const tokens = allTokens[chainId]?.[this.config.selectedAddress] || [];
+  const detectedTokens = allDetectedTokens[chainId]?.[this.config.selectedAddress] || [];
+  return [
+    ...new Set(
+      [...tokens, ...detectedTokens].map(
+        (token) => toHex(toChecksumHexAddress(token.address))
+      )
+    )
+  ].sort();
+};
+_stopPoll = new WeakSet();
+stopPoll_fn = function() {
+  if (this.handle) {
+    clearTimeout(this.handle);
+  }
+};
+_poll = new WeakSet();
+poll_fn = async function() {
+  await safelyExecute(() => this.updateExchangeRates());
+  this.handle = setTimeout(() => {
+    __privateMethod(this, _poll, poll_fn).call(this);
+  }, this.config.interval);
+};
+_fetchAndMapExchangeRates = new WeakSet();
+fetchAndMapExchangeRates_fn = async function({
+  tokenAddresses,
+  chainId,
+  nativeCurrency
+}) {
+  if (!__privateGet(this, _tokenPricesService).validateChainIdSupported(chainId)) {
+    return tokenAddresses.reduce(
+      (obj, tokenAddress) => {
+        obj.marketData = {
+          ...obj.marketData,
+          [tokenAddress]: void 0
+        };
+        return obj;
+      },
+      {
+        marketData: {}
+      }
+    );
+  }
+  if (__privateGet(this, _tokenPricesService).validateCurrencySupported(nativeCurrency)) {
+    return await __privateMethod(this, _fetchAndMapExchangeRatesForSupportedNativeCurrency, fetchAndMapExchangeRatesForSupportedNativeCurrency_fn).call(this, {
+      tokenAddresses,
+      chainId,
+      nativeCurrency
+    });
+  }
+  return await __privateMethod(this, _fetchAndMapExchangeRatesForUnsupportedNativeCurrency, fetchAndMapExchangeRatesForUnsupportedNativeCurrency_fn).call(this, {
+    tokenAddresses,
+    nativeCurrency
+  });
+};
+_fetchAndMapExchangeRatesForSupportedNativeCurrency = new WeakSet();
+fetchAndMapExchangeRatesForSupportedNativeCurrency_fn = async function({
+  tokenAddresses,
+  chainId,
+  nativeCurrency
+}) {
+  let contractNativeInformations;
+  const tokenPricesByTokenAddress = await reduceInBatchesSerially({
+    values: [...tokenAddresses].sort(),
+    batchSize: TOKEN_PRICES_BATCH_SIZE,
+    eachBatch: async (allTokenPricesByTokenAddress, batch) => {
+      const tokenPricesByTokenAddressForBatch = await __privateGet(this, _tokenPricesService).fetchTokenPrices({
+        tokenAddresses: batch,
+        chainId,
+        currency: nativeCurrency
+      });
+      return {
+        ...allTokenPricesByTokenAddress,
+        ...tokenPricesByTokenAddressForBatch
+      };
+    },
+    initialResult: {}
+  });
+  contractNativeInformations = tokenPricesByTokenAddress;
+  if (tokenAddresses.length === 0) {
+    const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
+    const contractNativeInformationsNative = await __privateGet(this, _tokenPricesService).fetchTokenPrices({
+      tokenAddresses: [ZERO_ADDRESS],
+      chainId: this.config.chainId,
+      currency: nativeCurrency
+    });
+    contractNativeInformations = {
+      [ZERO_ADDRESS]: {
+        currency: nativeCurrency,
+        ...contractNativeInformationsNative[ZERO_ADDRESS]
+      }
+    };
+  }
+  return Object.entries(contractNativeInformations).reduce(
+    (obj, [tokenAddress, tokenPrice]) => {
+      obj.marketData = {
+        ...obj.marketData,
+        [tokenAddress.toLowerCase()]: { ...tokenPrice }
+      };
+      return obj;
+    },
+    {
+      marketData: {}
+    }
+  );
+};
+_fetchAndMapExchangeRatesForUnsupportedNativeCurrency = new WeakSet();
+fetchAndMapExchangeRatesForUnsupportedNativeCurrency_fn = async function({
+  tokenAddresses,
+  nativeCurrency
+}) {
+  const [
+    contractExchangeInformations,
+    fallbackCurrencyToNativeCurrencyConversionRate
+  ] = await Promise.all([
+    __privateMethod(this, _fetchAndMapExchangeRatesForSupportedNativeCurrency, fetchAndMapExchangeRatesForSupportedNativeCurrency_fn).call(this, {
+      tokenAddresses,
+      chainId: this.config.chainId,
+      nativeCurrency: FALL_BACK_VS_CURRENCY
+    }),
+    getCurrencyConversionRate({
+      from: FALL_BACK_VS_CURRENCY,
+      to: nativeCurrency
+    })
+  ]);
+  if (fallbackCurrencyToNativeCurrencyConversionRate === null) {
+    return {
+      marketData: {}
+    };
+  }
+  const updatedContractExchangeRates = Object.entries(
+    contractExchangeInformations.marketData
+  ).reduce(
+    (obj, [tokenAddress, tokenValue]) => {
+      obj.marketData = {
+        ...obj.marketData,
+        [tokenAddress]: {
+          ...tokenValue,
+          value: tokenValue.value ? tokenValue.value * fallbackCurrencyToNativeCurrencyConversionRate : void 0
+        }
+      };
+      return obj;
+    },
+    {
+      marketData: {}
+    }
+  );
+  return updatedContractExchangeRates;
+};
+var TokenRatesController_default = TokenRatesController;
+
+export {
+  TokenRatesController,
+  TokenRatesController_default
+};
+//# sourceMappingURL=chunk-4L54AXTJ.mjs.map
\ No newline at end of file
diff --git a/dist/chunk-4L54AXTJ.mjs.map b/dist/chunk-4L54AXTJ.mjs.map
new file mode 100644
index 0000000000000000000000000000000000000000..2a0c48c1cc7c3c56ee62b91602f50a19d35f1645
--- /dev/null
+++ b/dist/chunk-4L54AXTJ.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/TokenRatesController.ts"],"sourcesContent":["import type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport {\n  safelyExecute,\n  toChecksumHexAddress,\n  FALL_BACK_VS_CURRENCY,\n  toHex,\n} from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkState,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingControllerV1 } from '@metamask/polling-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { createDeferredPromise, type Hex } from '@metamask/utils';\nimport { isEqual } from 'lodash';\n\nimport { reduceInBatchesSerially, TOKEN_PRICES_BATCH_SIZE } from './assetsUtil';\nimport { fetchExchangeRate as fetchNativeCurrencyExchangeRate } from './crypto-compare';\nimport type { AbstractTokenPricesService } from './token-prices-service/abstract-token-prices-service';\nimport type { TokensState } from './TokensController';\n\n/**\n * @type Token\n *\n * Token representation\n * @property address - Hex address of the token contract\n * @property decimals - Number of decimals the token uses\n * @property symbol - Symbol of the token\n * @property image - Image of the token, url or bit32 image\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface Token {\n  address: string;\n  decimals: number;\n  symbol: string;\n  aggregators?: string[];\n  image?: string;\n  balanceError?: unknown;\n  isERC721?: boolean;\n  name?: string;\n}\n\n/**\n * @type TokenRatesConfig\n *\n * Token rates controller configuration\n * @property interval - Polling interval used to fetch new token rates\n * @property nativeCurrency - Current native currency selected to use base of rates\n * @property chainId - Current network chainId\n * @property tokens - List of tokens to track exchange rates for\n * @property threshold - Threshold to invalidate the supportedChains\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface TokenRatesConfig extends BaseConfig {\n  interval: number;\n  nativeCurrency: string;\n  chainId: Hex;\n  selectedAddress: string;\n  allTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  allDetectedTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  threshold: number;\n}\n\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface ContractExchangeRates {\n  [address: string]: number | undefined;\n}\n\nexport type ContractInformations = {\n  marketData: Record<\n    Hex,\n    {\n      tokenAddress: `0x${string}`;\n      value: number;\n      currency: string;\n      allTimeHigh: number;\n      allTimeLow: number;\n      circulatingSupply: number;\n      dilutedMarketCap: number;\n      high1d: number;\n      low1d: number;\n      marketCap: number;\n      marketCapPercentChange1d: number;\n      price: number;\n      priceChange1d: number;\n      pricePercentChange1d: number;\n      pricePercentChange1h: number;\n      pricePercentChange1y: number;\n      pricePercentChange7d: number;\n      pricePercentChange14d: number;\n      pricePercentChange30d: number;\n      pricePercentChange200d: number;\n      totalVolume: number;\n    }\n  >;\n};\n\nenum PollState {\n  Active = 'Active',\n  Inactive = 'Inactive',\n}\n\n/**\n * @type TokenRatesState\n *\n * Token rates controller state\n * @property marketData - Hash of token contract addresses to market data\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface TokenRatesState extends BaseState {\n  marketData: Record<\n    Hex,\n    Record<\n      Hex,\n      {\n        tokenAddress: `0x${string}`;\n        value: number;\n        currency: string;\n        allTimeHigh: number;\n        allTimeLow: number;\n        circulatingSupply: number;\n        dilutedMarketCap: number;\n        high1d: number;\n        low1d: number;\n        marketCap: number;\n        marketCapPercentChange1d: number;\n        price: number;\n        priceChange1d: number;\n        pricePercentChange1d: number;\n        pricePercentChange1h: number;\n        pricePercentChange1y: number;\n        pricePercentChange7d: number;\n        pricePercentChange14d: number;\n        pricePercentChange30d: number;\n        pricePercentChange200d: number;\n        totalVolume: number;\n      }\n    >\n  >;\n}\n\n/**\n * Uses the CryptoCompare API to fetch the exchange rate between one currency\n * and another, i.e., the multiplier to apply the amount of one currency in\n * order to convert it to another.\n *\n * @param args - The arguments to this function.\n * @param args.from - The currency to convert from.\n * @param args.to - The currency to convert to.\n * @returns The exchange rate between `fromCurrency` to `toCurrency` if one\n * exists, or null if one does not.\n */\nasync function getCurrencyConversionRate({\n  from,\n  to,\n}: {\n  from: string;\n  to: string;\n}) {\n  const includeUSDRate = false;\n  try {\n    const result = await fetchNativeCurrencyExchangeRate(\n      to,\n      from,\n      includeUSDRate,\n    );\n    return result.conversionRate;\n  } catch (error) {\n    if (\n      error instanceof Error &&\n      error.message.includes('market does not exist for this coin pair')\n    ) {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n * Controller that passively polls on a set interval for token-to-fiat exchange rates\n * for tokens stored in the TokensController\n */\nexport class TokenRatesController extends StaticIntervalPollingControllerV1<\n  TokenRatesConfig,\n  TokenRatesState\n> {\n  private handle?: ReturnType<typeof setTimeout>;\n\n  #pollState = PollState.Inactive;\n\n  #tokenPricesService: AbstractTokenPricesService;\n\n  #inProcessExchangeRateUpdates: Record<`${Hex}:${string}`, Promise<void>> = {};\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokenRatesController';\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  /**\n   * Creates a TokenRatesController instance.\n   *\n   * @param options - The controller options.\n   * @param options.interval - The polling interval in ms\n   * @param options.threshold - The duration in ms before metadata fetched from CoinGecko is considered stale\n   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.ticker - The ticker for the current network.\n   * @param options.selectedAddress - The current selected address.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onTokensStateChange - Allows subscribing to token controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network state changes.\n   * @param options.tokenPricesService - An object in charge of retrieving token prices.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      interval = 3 * 60 * 1000,\n      threshold = 6 * 60 * 60 * 1000,\n      getNetworkClientById,\n      chainId: initialChainId,\n      ticker: initialTicker,\n      selectedAddress: initialSelectedAddress,\n      onPreferencesStateChange,\n      onTokensStateChange,\n      onNetworkStateChange,\n      tokenPricesService,\n    }: {\n      interval?: number;\n      threshold?: number;\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n      chainId: Hex;\n      ticker: string;\n      selectedAddress: string;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onTokensStateChange: (\n        listener: (tokensState: TokensState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      tokenPricesService: AbstractTokenPricesService;\n    },\n    config?: Partial<TokenRatesConfig>,\n    state?: Partial<TokenRatesState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval,\n      threshold,\n      disabled: false,\n      nativeCurrency: initialTicker,\n      chainId: initialChainId,\n      selectedAddress: initialSelectedAddress,\n      allTokens: {}, // TODO: initialize these correctly, maybe as part of BaseControllerV2 migration\n      allDetectedTokens: {},\n    };\n\n    this.defaultState = {\n      marketData: {},\n    };\n    this.initialize();\n    this.setIntervalLength(interval);\n    this.getNetworkClientById = getNetworkClientById;\n    this.#tokenPricesService = tokenPricesService;\n\n    if (config?.disabled) {\n      this.configure({ disabled: true }, false, false);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    onPreferencesStateChange(async ({ selectedAddress }) => {\n      if (this.config.selectedAddress !== selectedAddress) {\n        this.configure({ selectedAddress });\n        if (this.#pollState === PollState.Active) {\n          await this.updateExchangeRates();\n        }\n      }\n    });\n\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    onTokensStateChange(async ({ allTokens, allDetectedTokens }) => {\n      const previousTokenAddresses = this.#getTokenAddresses(\n        this.config.chainId,\n      );\n      this.configure({ allTokens, allDetectedTokens });\n      const newTokenAddresses = this.#getTokenAddresses(this.config.chainId);\n      if (\n        !isEqual(previousTokenAddresses, newTokenAddresses) &&\n        this.#pollState === PollState.Active\n      ) {\n        await this.updateExchangeRates();\n      }\n    });\n\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    onNetworkStateChange(async ({ providerConfig }) => {\n      const { chainId, ticker } = providerConfig;\n      if (\n        this.config.chainId !== chainId ||\n        this.config.nativeCurrency !== ticker\n      ) {\n        this.update({ marketData: {} });\n        this.configure({ chainId, nativeCurrency: ticker });\n        if (this.#pollState === PollState.Active) {\n          await this.updateExchangeRates();\n        }\n      }\n    });\n  }\n\n  /**\n   * Get the user's tokens for the given chain.\n   *\n   * @param chainId - The chain ID.\n   * @returns The list of tokens addresses for the current chain\n   */\n  #getTokenAddresses(chainId: Hex): Hex[] {\n    const { allTokens, allDetectedTokens } = this.config;\n    const tokens = allTokens[chainId]?.[this.config.selectedAddress] || [];\n    const detectedTokens =\n      allDetectedTokens[chainId]?.[this.config.selectedAddress] || [];\n\n    return [\n      ...new Set(\n        [...tokens, ...detectedTokens].map((token) =>\n          toHex(toChecksumHexAddress(token.address)),\n        ),\n      ),\n    ].sort();\n  }\n\n  /**\n   * Start (or restart) polling.\n   */\n  async start() {\n    this.#stopPoll();\n    this.#pollState = PollState.Active;\n    await this.#poll();\n  }\n\n  /**\n   * Stop polling.\n   */\n  stop() {\n    this.#stopPoll();\n    this.#pollState = PollState.Inactive;\n  }\n\n  /**\n   * Clear the active polling timer, if present.\n   */\n  #stopPoll() {\n    if (this.handle) {\n      clearTimeout(this.handle);\n    }\n  }\n\n  /**\n   * Poll for exchange rate updates.\n   */\n  async #poll() {\n    await safelyExecute(() => this.updateExchangeRates());\n\n    // Poll using recursive `setTimeout` instead of `setInterval` so that\n    // requests don't stack if they take longer than the polling interval\n    this.handle = setTimeout(() => {\n      this.#poll();\n    }, this.config.interval);\n  }\n\n  /**\n   * Updates exchange rates for all tokens.\n   */\n  async updateExchangeRates() {\n    const { chainId, nativeCurrency } = this.config;\n    await this.updateExchangeRatesByChainId({\n      chainId,\n      nativeCurrency,\n    });\n  }\n\n  /**\n   * Updates exchange rates for all tokens.\n   *\n   * @param options - The options to fetch exchange rates.\n   * @param options.chainId - The chain ID.\n   * @param options.nativeCurrency - The ticker for the chain.\n   */\n  async updateExchangeRatesByChainId({\n    chainId,\n    nativeCurrency,\n  }: {\n    chainId: Hex;\n    nativeCurrency: string;\n  }) {\n    if (this.disabled) {\n      return;\n    }\n\n    const tokenAddresses = this.#getTokenAddresses(chainId);\n\n    const updateKey: `${Hex}:${string}` = `${chainId}:${nativeCurrency}`;\n    if (updateKey in this.#inProcessExchangeRateUpdates) {\n      // This prevents redundant updates\n      // This promise is resolved after the in-progress update has finished,\n      // and state has been updated.\n      await this.#inProcessExchangeRateUpdates[updateKey];\n      return;\n    }\n\n    const {\n      promise: inProgressUpdate,\n      resolve: updateSucceeded,\n      reject: updateFailed,\n    } = createDeferredPromise({ suppressUnhandledRejection: true });\n    this.#inProcessExchangeRateUpdates[updateKey] = inProgressUpdate;\n\n    try {\n      const contractInformations = await this.#fetchAndMapExchangeRates({\n        tokenAddresses,\n        chainId,\n        nativeCurrency,\n      });\n\n      const marketData = {\n        [chainId]: {\n          ...(contractInformations.marketData ?? {}),\n        },\n      };\n\n      this.update({\n        marketData,\n      });\n      updateSucceeded();\n    } catch (error: unknown) {\n      updateFailed(error);\n      throw error;\n    } finally {\n      delete this.#inProcessExchangeRateUpdates[updateKey];\n    }\n  }\n\n  /**\n   * Uses the token prices service to retrieve exchange rates for tokens in a\n   * particular currency.\n   *\n   * If the price API does not support the given chain ID, returns an empty\n   * object.\n   *\n   * If the price API does not support the given currency, retrieves exchange\n   * rates in a known currency instead, then converts those rates using the\n   * exchange rate between the known currency and desired currency.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.chainId - The EIP-155 ID of the chain where the tokens live.\n   * @param args.nativeCurrency - The native currency in which to request\n   * exchange rates.\n   * @returns A map from token address to its exchange rate in the native\n   * currency, or an empty map if no exchange rates can be obtained for the\n   * chain ID.\n   */\n  async #fetchAndMapExchangeRates({\n    tokenAddresses,\n    chainId,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    chainId: Hex;\n    nativeCurrency: string;\n  }): Promise<ContractInformations> {\n    if (!this.#tokenPricesService.validateChainIdSupported(chainId)) {\n      return tokenAddresses.reduce(\n        (obj, tokenAddress) => {\n          obj.marketData = {\n            ...obj.marketData,\n            [tokenAddress]: undefined,\n          };\n\n          return obj;\n        },\n        {\n          marketData: {},\n        },\n      );\n    }\n\n    if (this.#tokenPricesService.validateCurrencySupported(nativeCurrency)) {\n      return await this.#fetchAndMapExchangeRatesForSupportedNativeCurrency({\n        tokenAddresses,\n        chainId,\n        nativeCurrency,\n      });\n    }\n    return await this.#fetchAndMapExchangeRatesForUnsupportedNativeCurrency({\n      tokenAddresses,\n      nativeCurrency,\n    });\n  }\n\n  /**\n   * Updates token rates for the given networkClientId\n   *\n   * @param networkClientId - The network client ID used to get a ticker value.\n   * @returns The controller state.\n   */\n  async _executePoll(networkClientId: NetworkClientId): Promise<void> {\n    const networkClient = this.getNetworkClientById(networkClientId);\n    await this.updateExchangeRatesByChainId({\n      chainId: networkClient.configuration.chainId,\n      nativeCurrency: networkClient.configuration.ticker,\n    });\n  }\n\n  /**\n   * Retrieves prices in the given currency for the given tokens on the given\n   * chain. Ensures that token addresses are checksum addresses.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.chainId - The EIP-155 ID of the chain where the tokens live.\n   * @param args.nativeCurrency - The native currency in which to request\n   * prices.\n   * @returns A map of the token addresses (as checksums) to their prices in the\n   * native currency.\n   */\n  async #fetchAndMapExchangeRatesForSupportedNativeCurrency({\n    tokenAddresses,\n    chainId,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    chainId: Hex;\n    nativeCurrency: string;\n  }): Promise<ContractInformations> {\n    let contractNativeInformations;\n    const tokenPricesByTokenAddress = await reduceInBatchesSerially<\n      Hex,\n      Awaited<ReturnType<AbstractTokenPricesService['fetchTokenPrices']>>\n    >({\n      values: [...tokenAddresses].sort(),\n      batchSize: TOKEN_PRICES_BATCH_SIZE,\n      eachBatch: async (allTokenPricesByTokenAddress, batch) => {\n        const tokenPricesByTokenAddressForBatch =\n          await this.#tokenPricesService.fetchTokenPrices({\n            tokenAddresses: batch,\n            chainId,\n            currency: nativeCurrency,\n          });\n\n        return {\n          ...allTokenPricesByTokenAddress,\n          ...tokenPricesByTokenAddressForBatch,\n        };\n      },\n      initialResult: {},\n    });\n    contractNativeInformations = tokenPricesByTokenAddress;\n\n    // fetch for native token\n    if (tokenAddresses.length === 0) {\n      const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';\n\n      const contractNativeInformationsNative =\n        await this.#tokenPricesService.fetchTokenPrices({\n          tokenAddresses: [ZERO_ADDRESS],\n          chainId: this.config.chainId,\n          currency: nativeCurrency,\n        });\n\n      contractNativeInformations = {\n        [ZERO_ADDRESS]: {\n          currency: nativeCurrency,\n          ...contractNativeInformationsNative[ZERO_ADDRESS],\n        },\n      };\n    }\n    return Object.entries(contractNativeInformations).reduce(\n      (obj, [tokenAddress, tokenPrice]) => {\n        obj.marketData = {\n          ...obj.marketData,\n          [tokenAddress.toLowerCase()]: { ...tokenPrice },\n        };\n\n        return obj;\n      },\n      {\n        marketData: {},\n      },\n    );\n  }\n\n  /**\n   * If the price API does not support a given native currency, then we need to\n   * convert it to a fallback currency and feed that currency into the price\n   * API, then convert the prices to our desired native currency.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.nativeCurrency - The native currency in which to request\n   * prices.\n   * @returns A map of the token addresses (as checksums) to their prices in the\n   * native currency.\n   */\n  async #fetchAndMapExchangeRatesForUnsupportedNativeCurrency({\n    tokenAddresses,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    nativeCurrency: string;\n  }): Promise<ContractInformations> {\n    const [\n      contractExchangeInformations,\n      fallbackCurrencyToNativeCurrencyConversionRate,\n    ] = await Promise.all([\n      this.#fetchAndMapExchangeRatesForSupportedNativeCurrency({\n        tokenAddresses,\n        chainId: this.config.chainId,\n        nativeCurrency: FALL_BACK_VS_CURRENCY,\n      }),\n      getCurrencyConversionRate({\n        from: FALL_BACK_VS_CURRENCY,\n        to: nativeCurrency,\n      }),\n    ]);\n\n    if (fallbackCurrencyToNativeCurrencyConversionRate === null) {\n      return {\n        marketData: {},\n      };\n    }\n\n    const updatedContractExchangeRates = Object.entries(\n      contractExchangeInformations.marketData,\n    ).reduce(\n      (obj, [tokenAddress, tokenValue]) => {\n        obj.marketData = {\n          ...obj.marketData,\n          [tokenAddress]: {\n            ...tokenValue,\n            value: tokenValue.value\n              ? tokenValue.value *\n                fallbackCurrencyToNativeCurrencyConversionRate\n              : undefined,\n          },\n        };\n        return obj;\n      },\n      {\n        marketData: {},\n      },\n    );\n\n    return updatedContractExchangeRates;\n  }\n}\n\nexport default TokenRatesController;\n"],"mappings":"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","names":[]}
\ No newline at end of file
diff --git a/dist/chunk-6MY5FIJB.js b/dist/chunk-6MY5FIJB.js
new file mode 100644
index 0000000000000000000000000000000000000000..4b405268453a1c9ddf7e7b72cca1fe10bf600906
--- /dev/null
+++ b/dist/chunk-6MY5FIJB.js
@@ -0,0 +1,441 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunkDYH5P3VYjs = require('./chunk-DYH5P3VY.js');
+
+
+
+var _chunkLS6R3HQLjs = require('./chunk-LS6R3HQL.js');
+
+
+
+
+
+var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
+
+// src/TokenRatesController.ts
+
+
+
+
+
+var _controllerutils = require('@metamask/controller-utils');
+var _pollingcontroller = require('@metamask/polling-controller');
+var _utils = require('@metamask/utils');
+var _lodash = require('lodash');
+async function getCurrencyConversionRate({
+  from,
+  to
+}) {
+  const includeUSDRate = false;
+  try {
+    const result = await _chunkDYH5P3VYjs.fetchExchangeRate.call(void 0, 
+      to,
+      from,
+      includeUSDRate
+    );
+    return result.conversionRate;
+  } catch (error) {
+    if (error instanceof Error && error.message.includes("market does not exist for this coin pair")) {
+      return null;
+    }
+    throw error;
+  }
+}
+var _pollState, _tokenPricesService, _inProcessExchangeRateUpdates, _getTokenAddresses, getTokenAddresses_fn, _stopPoll, stopPoll_fn, _poll, poll_fn, _fetchAndMapExchangeRates, fetchAndMapExchangeRates_fn, _fetchAndMapExchangeRatesForSupportedNativeCurrency, fetchAndMapExchangeRatesForSupportedNativeCurrency_fn, _fetchAndMapExchangeRatesForUnsupportedNativeCurrency, fetchAndMapExchangeRatesForUnsupportedNativeCurrency_fn;
+var TokenRatesController = class extends _pollingcontroller.StaticIntervalPollingControllerV1 {
+  /**
+   * Creates a TokenRatesController instance.
+   *
+   * @param options - The controller options.
+   * @param options.interval - The polling interval in ms
+   * @param options.threshold - The duration in ms before metadata fetched from CoinGecko is considered stale
+   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.
+   * @param options.chainId - The chain ID of the current network.
+   * @param options.ticker - The ticker for the current network.
+   * @param options.selectedAddress - The current selected address.
+   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
+   * @param options.onTokensStateChange - Allows subscribing to token controller state changes.
+   * @param options.onNetworkStateChange - Allows subscribing to network state changes.
+   * @param options.tokenPricesService - An object in charge of retrieving token prices.
+   * @param config - Initial options used to configure this controller.
+   * @param state - Initial state to set on this controller.
+   */
+  constructor({
+    interval = 3 * 60 * 1e3,
+    threshold = 6 * 60 * 60 * 1e3,
+    getNetworkClientById,
+    chainId: initialChainId,
+    ticker: initialTicker,
+    selectedAddress: initialSelectedAddress,
+    onPreferencesStateChange,
+    onTokensStateChange,
+    onNetworkStateChange,
+    tokenPricesService
+  }, config, state) {
+    super(config, state);
+    /**
+     * Get the user's tokens for the given chain.
+     *
+     * @param chainId - The chain ID.
+     * @returns The list of tokens addresses for the current chain
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getTokenAddresses);
+    /**
+     * Clear the active polling timer, if present.
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _stopPoll);
+    /**
+     * Poll for exchange rate updates.
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _poll);
+    /**
+     * Uses the token prices service to retrieve exchange rates for tokens in a
+     * particular currency.
+     *
+     * If the price API does not support the given chain ID, returns an empty
+     * object.
+     *
+     * If the price API does not support the given currency, retrieves exchange
+     * rates in a known currency instead, then converts those rates using the
+     * exchange rate between the known currency and desired currency.
+     *
+     * @param args - The arguments to this function.
+     * @param args.tokenAddresses - Addresses for tokens.
+     * @param args.chainId - The EIP-155 ID of the chain where the tokens live.
+     * @param args.nativeCurrency - The native currency in which to request
+     * exchange rates.
+     * @returns A map from token address to its exchange rate in the native
+     * currency, or an empty map if no exchange rates can be obtained for the
+     * chain ID.
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _fetchAndMapExchangeRates);
+    /**
+     * Retrieves prices in the given currency for the given tokens on the given
+     * chain. Ensures that token addresses are checksum addresses.
+     *
+     * @param args - The arguments to this function.
+     * @param args.tokenAddresses - Addresses for tokens.
+     * @param args.chainId - The EIP-155 ID of the chain where the tokens live.
+     * @param args.nativeCurrency - The native currency in which to request
+     * prices.
+     * @returns A map of the token addresses (as checksums) to their prices in the
+     * native currency.
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _fetchAndMapExchangeRatesForSupportedNativeCurrency);
+    /**
+     * If the price API does not support a given native currency, then we need to
+     * convert it to a fallback currency and feed that currency into the price
+     * API, then convert the prices to our desired native currency.
+     *
+     * @param args - The arguments to this function.
+     * @param args.tokenAddresses - Addresses for tokens.
+     * @param args.nativeCurrency - The native currency in which to request
+     * prices.
+     * @returns A map of the token addresses (as checksums) to their prices in the
+     * native currency.
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _fetchAndMapExchangeRatesForUnsupportedNativeCurrency);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _pollState, "Inactive" /* Inactive */);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _tokenPricesService, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _inProcessExchangeRateUpdates, {});
+    /**
+     * Name of this controller used during composition
+     */
+    this.name = "TokenRatesController";
+    this.defaultConfig = {
+      interval,
+      threshold,
+      disabled: false,
+      nativeCurrency: initialTicker,
+      chainId: initialChainId,
+      selectedAddress: initialSelectedAddress,
+      allTokens: {},
+      // TODO: initialize these correctly, maybe as part of BaseControllerV2 migration
+      allDetectedTokens: {}
+    };
+    this.defaultState = {
+      marketData: {}
+    };
+    this.initialize();
+    this.setIntervalLength(interval);
+    this.getNetworkClientById = getNetworkClientById;
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _tokenPricesService, tokenPricesService);
+    if (config?.disabled) {
+      this.configure({ disabled: true }, false, false);
+    }
+    onPreferencesStateChange(async ({ selectedAddress }) => {
+      if (this.config.selectedAddress !== selectedAddress) {
+        this.configure({ selectedAddress });
+        if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _pollState) === "Active" /* Active */) {
+          await this.updateExchangeRates();
+        }
+      }
+    });
+    onTokensStateChange(async ({ allTokens, allDetectedTokens }) => {
+      const previousTokenAddresses = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getTokenAddresses, getTokenAddresses_fn).call(this, this.config.chainId);
+      this.configure({ allTokens, allDetectedTokens });
+      const newTokenAddresses = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getTokenAddresses, getTokenAddresses_fn).call(this, this.config.chainId);
+      if (!_lodash.isEqual.call(void 0, previousTokenAddresses, newTokenAddresses) && _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _pollState) === "Active" /* Active */) {
+        await this.updateExchangeRates();
+      }
+    });
+    onNetworkStateChange(async ({ providerConfig }) => {
+      const { chainId, ticker } = providerConfig;
+      if (this.config.chainId !== chainId || this.config.nativeCurrency !== ticker) {
+        this.update({ marketData: {} });
+        this.configure({ chainId, nativeCurrency: ticker });
+        if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _pollState) === "Active" /* Active */) {
+          await this.updateExchangeRates();
+        }
+      }
+    });
+  }
+  /**
+   * Start (or restart) polling.
+   */
+  async start() {
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _stopPoll, stopPoll_fn).call(this);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _pollState, "Active" /* Active */);
+    await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _poll, poll_fn).call(this);
+  }
+  /**
+   * Stop polling.
+   */
+  stop() {
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _stopPoll, stopPoll_fn).call(this);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _pollState, "Inactive" /* Inactive */);
+  }
+  /**
+   * Updates exchange rates for all tokens.
+   */
+  async updateExchangeRates() {
+    const { chainId, nativeCurrency } = this.config;
+    await this.updateExchangeRatesByChainId({
+      chainId,
+      nativeCurrency
+    });
+  }
+  /**
+   * Updates exchange rates for all tokens.
+   *
+   * @param options - The options to fetch exchange rates.
+   * @param options.chainId - The chain ID.
+   * @param options.nativeCurrency - The ticker for the chain.
+   */
+  async updateExchangeRatesByChainId({
+    chainId,
+    nativeCurrency
+  }) {
+    if (this.disabled) {
+      return;
+    }
+    const tokenAddresses = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getTokenAddresses, getTokenAddresses_fn).call(this, chainId);
+    const updateKey = `${chainId}:${nativeCurrency}`;
+    if (updateKey in _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _inProcessExchangeRateUpdates)) {
+      await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _inProcessExchangeRateUpdates)[updateKey];
+      return;
+    }
+    const {
+      promise: inProgressUpdate,
+      resolve: updateSucceeded,
+      reject: updateFailed
+    } = _utils.createDeferredPromise.call(void 0, { suppressUnhandledRejection: true });
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _inProcessExchangeRateUpdates)[updateKey] = inProgressUpdate;
+    try {
+      const contractInformations = await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _fetchAndMapExchangeRates, fetchAndMapExchangeRates_fn).call(this, {
+        tokenAddresses,
+        chainId,
+        nativeCurrency
+      });
+      const marketData = {
+        [chainId]: {
+          ...contractInformations.marketData ?? {}
+        }
+      };
+      this.update({
+        marketData
+      });
+      updateSucceeded();
+    } catch (error) {
+      updateFailed(error);
+      throw error;
+    } finally {
+      delete _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _inProcessExchangeRateUpdates)[updateKey];
+    }
+  }
+  /**
+   * Updates token rates for the given networkClientId
+   *
+   * @param networkClientId - The network client ID used to get a ticker value.
+   * @returns The controller state.
+   */
+  async _executePoll(networkClientId) {
+    const networkClient = this.getNetworkClientById(networkClientId);
+    await this.updateExchangeRatesByChainId({
+      chainId: networkClient.configuration.chainId,
+      nativeCurrency: networkClient.configuration.ticker
+    });
+  }
+};
+_pollState = new WeakMap();
+_tokenPricesService = new WeakMap();
+_inProcessExchangeRateUpdates = new WeakMap();
+_getTokenAddresses = new WeakSet();
+getTokenAddresses_fn = function(chainId) {
+  const { allTokens, allDetectedTokens } = this.config;
+  const tokens = allTokens[chainId]?.[this.config.selectedAddress] || [];
+  const detectedTokens = allDetectedTokens[chainId]?.[this.config.selectedAddress] || [];
+  return [
+    ...new Set(
+      [...tokens, ...detectedTokens].map(
+        (token) => _controllerutils.toHex.call(void 0, _controllerutils.toChecksumHexAddress.call(void 0, token.address))
+      )
+    )
+  ].sort();
+};
+_stopPoll = new WeakSet();
+stopPoll_fn = function() {
+  if (this.handle) {
+    clearTimeout(this.handle);
+  }
+};
+_poll = new WeakSet();
+poll_fn = async function() {
+  await _controllerutils.safelyExecute.call(void 0, () => this.updateExchangeRates());
+  this.handle = setTimeout(() => {
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _poll, poll_fn).call(this);
+  }, this.config.interval);
+};
+_fetchAndMapExchangeRates = new WeakSet();
+fetchAndMapExchangeRates_fn = async function({
+  tokenAddresses,
+  chainId,
+  nativeCurrency
+}) {
+  if (!_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _tokenPricesService).validateChainIdSupported(chainId)) {
+    return tokenAddresses.reduce(
+      (obj, tokenAddress) => {
+        obj.marketData = {
+          ...obj.marketData,
+          [tokenAddress]: void 0
+        };
+        return obj;
+      },
+      {
+        marketData: {}
+      }
+    );
+  }
+  if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _tokenPricesService).validateCurrencySupported(nativeCurrency)) {
+    return await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _fetchAndMapExchangeRatesForSupportedNativeCurrency, fetchAndMapExchangeRatesForSupportedNativeCurrency_fn).call(this, {
+      tokenAddresses,
+      chainId,
+      nativeCurrency
+    });
+  }
+  return await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _fetchAndMapExchangeRatesForUnsupportedNativeCurrency, fetchAndMapExchangeRatesForUnsupportedNativeCurrency_fn).call(this, {
+    tokenAddresses,
+    nativeCurrency
+  });
+};
+_fetchAndMapExchangeRatesForSupportedNativeCurrency = new WeakSet();
+fetchAndMapExchangeRatesForSupportedNativeCurrency_fn = async function({
+  tokenAddresses,
+  chainId,
+  nativeCurrency
+}) {
+  let contractNativeInformations;
+  const tokenPricesByTokenAddress = await _chunkLS6R3HQLjs.reduceInBatchesSerially.call(void 0, {
+    values: [...tokenAddresses].sort(),
+    batchSize: _chunkLS6R3HQLjs.TOKEN_PRICES_BATCH_SIZE,
+    eachBatch: async (allTokenPricesByTokenAddress, batch) => {
+      const tokenPricesByTokenAddressForBatch = await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _tokenPricesService).fetchTokenPrices({
+        tokenAddresses: batch,
+        chainId,
+        currency: nativeCurrency
+      });
+      return {
+        ...allTokenPricesByTokenAddress,
+        ...tokenPricesByTokenAddressForBatch
+      };
+    },
+    initialResult: {}
+  });
+  contractNativeInformations = tokenPricesByTokenAddress;
+  if (tokenAddresses.length === 0) {
+    const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
+    const contractNativeInformationsNative = await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _tokenPricesService).fetchTokenPrices({
+      tokenAddresses: [ZERO_ADDRESS],
+      chainId: this.config.chainId,
+      currency: nativeCurrency
+    });
+    contractNativeInformations = {
+      [ZERO_ADDRESS]: {
+        currency: nativeCurrency,
+        ...contractNativeInformationsNative[ZERO_ADDRESS]
+      }
+    };
+  }
+  return Object.entries(contractNativeInformations).reduce(
+    (obj, [tokenAddress, tokenPrice]) => {
+      obj.marketData = {
+        ...obj.marketData,
+        [tokenAddress.toLowerCase()]: { ...tokenPrice }
+      };
+      return obj;
+    },
+    {
+      marketData: {}
+    }
+  );
+};
+_fetchAndMapExchangeRatesForUnsupportedNativeCurrency = new WeakSet();
+fetchAndMapExchangeRatesForUnsupportedNativeCurrency_fn = async function({
+  tokenAddresses,
+  nativeCurrency
+}) {
+  const [
+    contractExchangeInformations,
+    fallbackCurrencyToNativeCurrencyConversionRate
+  ] = await Promise.all([
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _fetchAndMapExchangeRatesForSupportedNativeCurrency, fetchAndMapExchangeRatesForSupportedNativeCurrency_fn).call(this, {
+      tokenAddresses,
+      chainId: this.config.chainId,
+      nativeCurrency: _controllerutils.FALL_BACK_VS_CURRENCY
+    }),
+    getCurrencyConversionRate({
+      from: _controllerutils.FALL_BACK_VS_CURRENCY,
+      to: nativeCurrency
+    })
+  ]);
+  if (fallbackCurrencyToNativeCurrencyConversionRate === null) {
+    return {
+      marketData: {}
+    };
+  }
+  const updatedContractExchangeRates = Object.entries(
+    contractExchangeInformations.marketData
+  ).reduce(
+    (obj, [tokenAddress, tokenValue]) => {
+      obj.marketData = {
+        ...obj.marketData,
+        [tokenAddress]: {
+          ...tokenValue,
+          value: tokenValue.value ? tokenValue.value * fallbackCurrencyToNativeCurrencyConversionRate : void 0
+        }
+      };
+      return obj;
+    },
+    {
+      marketData: {}
+    }
+  );
+  return updatedContractExchangeRates;
+};
+var TokenRatesController_default = TokenRatesController;
+
+
+
+
+exports.TokenRatesController = TokenRatesController; exports.TokenRatesController_default = TokenRatesController_default;
+//# sourceMappingURL=chunk-6MY5FIJB.js.map
\ No newline at end of file
diff --git a/dist/chunk-6MY5FIJB.js.map b/dist/chunk-6MY5FIJB.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..e52baf65d84bde84fd2c9642c3d84da5360e32a5
--- /dev/null
+++ b/dist/chunk-6MY5FIJB.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/TokenRatesController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport {\n  safelyExecute,\n  toChecksumHexAddress,\n  FALL_BACK_VS_CURRENCY,\n  toHex,\n} from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkState,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingControllerV1 } from '@metamask/polling-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { createDeferredPromise, type Hex } from '@metamask/utils';\nimport { isEqual } from 'lodash';\n\nimport { reduceInBatchesSerially, TOKEN_PRICES_BATCH_SIZE } from './assetsUtil';\nimport { fetchExchangeRate as fetchNativeCurrencyExchangeRate } from './crypto-compare';\nimport type { AbstractTokenPricesService } from './token-prices-service/abstract-token-prices-service';\nimport type { TokensState } from './TokensController';\n\n/**\n * @type Token\n *\n * Token representation\n * @property address - Hex address of the token contract\n * @property decimals - Number of decimals the token uses\n * @property symbol - Symbol of the token\n * @property image - Image of the token, url or bit32 image\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface Token {\n  address: string;\n  decimals: number;\n  symbol: string;\n  aggregators?: string[];\n  image?: string;\n  balanceError?: unknown;\n  isERC721?: boolean;\n  name?: string;\n}\n\n/**\n * @type TokenRatesConfig\n *\n * Token rates controller configuration\n * @property interval - Polling interval used to fetch new token rates\n * @property nativeCurrency - Current native currency selected to use base of rates\n * @property chainId - Current network chainId\n * @property tokens - List of tokens to track exchange rates for\n * @property threshold - Threshold to invalidate the supportedChains\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface TokenRatesConfig extends BaseConfig {\n  interval: number;\n  nativeCurrency: string;\n  chainId: Hex;\n  selectedAddress: string;\n  allTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  allDetectedTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  threshold: number;\n}\n\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface ContractExchangeRates {\n  [address: string]: number | undefined;\n}\n\nexport type ContractInformations = {\n  marketData: Record<\n    Hex,\n    {\n      tokenAddress: `0x${string}`;\n      value: number;\n      currency: string;\n      allTimeHigh: number;\n      allTimeLow: number;\n      circulatingSupply: number;\n      dilutedMarketCap: number;\n      high1d: number;\n      low1d: number;\n      marketCap: number;\n      marketCapPercentChange1d: number;\n      price: number;\n      priceChange1d: number;\n      pricePercentChange1d: number;\n      pricePercentChange1h: number;\n      pricePercentChange1y: number;\n      pricePercentChange7d: number;\n      pricePercentChange14d: number;\n      pricePercentChange30d: number;\n      pricePercentChange200d: number;\n      totalVolume: number;\n    }\n  >;\n};\n\nenum PollState {\n  Active = 'Active',\n  Inactive = 'Inactive',\n}\n\n/**\n * @type TokenRatesState\n *\n * Token rates controller state\n * @property marketData - Hash of token contract addresses to market data\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface TokenRatesState extends BaseState {\n  marketData: Record<\n    Hex,\n    Record<\n      Hex,\n      {\n        tokenAddress: `0x${string}`;\n        value: number;\n        currency: string;\n        allTimeHigh: number;\n        allTimeLow: number;\n        circulatingSupply: number;\n        dilutedMarketCap: number;\n        high1d: number;\n        low1d: number;\n        marketCap: number;\n        marketCapPercentChange1d: number;\n        price: number;\n        priceChange1d: number;\n        pricePercentChange1d: number;\n        pricePercentChange1h: number;\n        pricePercentChange1y: number;\n        pricePercentChange7d: number;\n        pricePercentChange14d: number;\n        pricePercentChange30d: number;\n        pricePercentChange200d: number;\n        totalVolume: number;\n      }\n    >\n  >;\n}\n\n/**\n * Uses the CryptoCompare API to fetch the exchange rate between one currency\n * and another, i.e., the multiplier to apply the amount of one currency in\n * order to convert it to another.\n *\n * @param args - The arguments to this function.\n * @param args.from - The currency to convert from.\n * @param args.to - The currency to convert to.\n * @returns The exchange rate between `fromCurrency` to `toCurrency` if one\n * exists, or null if one does not.\n */\nasync function getCurrencyConversionRate({\n  from,\n  to,\n}: {\n  from: string;\n  to: string;\n}) {\n  const includeUSDRate = false;\n  try {\n    const result = await fetchNativeCurrencyExchangeRate(\n      to,\n      from,\n      includeUSDRate,\n    );\n    return result.conversionRate;\n  } catch (error) {\n    if (\n      error instanceof Error &&\n      error.message.includes('market does not exist for this coin pair')\n    ) {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n * Controller that passively polls on a set interval for token-to-fiat exchange rates\n * for tokens stored in the TokensController\n */\nexport class TokenRatesController extends StaticIntervalPollingControllerV1<\n  TokenRatesConfig,\n  TokenRatesState\n> {\n  private handle?: ReturnType<typeof setTimeout>;\n\n  #pollState = PollState.Inactive;\n\n  #tokenPricesService: AbstractTokenPricesService;\n\n  #inProcessExchangeRateUpdates: Record<`${Hex}:${string}`, Promise<void>> = {};\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokenRatesController';\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  /**\n   * Creates a TokenRatesController instance.\n   *\n   * @param options - The controller options.\n   * @param options.interval - The polling interval in ms\n   * @param options.threshold - The duration in ms before metadata fetched from CoinGecko is considered stale\n   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.ticker - The ticker for the current network.\n   * @param options.selectedAddress - The current selected address.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onTokensStateChange - Allows subscribing to token controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network state changes.\n   * @param options.tokenPricesService - An object in charge of retrieving token prices.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      interval = 3 * 60 * 1000,\n      threshold = 6 * 60 * 60 * 1000,\n      getNetworkClientById,\n      chainId: initialChainId,\n      ticker: initialTicker,\n      selectedAddress: initialSelectedAddress,\n      onPreferencesStateChange,\n      onTokensStateChange,\n      onNetworkStateChange,\n      tokenPricesService,\n    }: {\n      interval?: number;\n      threshold?: number;\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n      chainId: Hex;\n      ticker: string;\n      selectedAddress: string;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onTokensStateChange: (\n        listener: (tokensState: TokensState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      tokenPricesService: AbstractTokenPricesService;\n    },\n    config?: Partial<TokenRatesConfig>,\n    state?: Partial<TokenRatesState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval,\n      threshold,\n      disabled: false,\n      nativeCurrency: initialTicker,\n      chainId: initialChainId,\n      selectedAddress: initialSelectedAddress,\n      allTokens: {}, // TODO: initialize these correctly, maybe as part of BaseControllerV2 migration\n      allDetectedTokens: {},\n    };\n\n    this.defaultState = {\n      marketData: {},\n    };\n    this.initialize();\n    this.setIntervalLength(interval);\n    this.getNetworkClientById = getNetworkClientById;\n    this.#tokenPricesService = tokenPricesService;\n\n    if (config?.disabled) {\n      this.configure({ disabled: true }, false, false);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    onPreferencesStateChange(async ({ selectedAddress }) => {\n      if (this.config.selectedAddress !== selectedAddress) {\n        this.configure({ selectedAddress });\n        if (this.#pollState === PollState.Active) {\n          await this.updateExchangeRates();\n        }\n      }\n    });\n\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    onTokensStateChange(async ({ allTokens, allDetectedTokens }) => {\n      const previousTokenAddresses = this.#getTokenAddresses(\n        this.config.chainId,\n      );\n      this.configure({ allTokens, allDetectedTokens });\n      const newTokenAddresses = this.#getTokenAddresses(this.config.chainId);\n      if (\n        !isEqual(previousTokenAddresses, newTokenAddresses) &&\n        this.#pollState === PollState.Active\n      ) {\n        await this.updateExchangeRates();\n      }\n    });\n\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    onNetworkStateChange(async ({ providerConfig }) => {\n      const { chainId, ticker } = providerConfig;\n      if (\n        this.config.chainId !== chainId ||\n        this.config.nativeCurrency !== ticker\n      ) {\n        this.update({ marketData: {} });\n        this.configure({ chainId, nativeCurrency: ticker });\n        if (this.#pollState === PollState.Active) {\n          await this.updateExchangeRates();\n        }\n      }\n    });\n  }\n\n  /**\n   * Get the user's tokens for the given chain.\n   *\n   * @param chainId - The chain ID.\n   * @returns The list of tokens addresses for the current chain\n   */\n  #getTokenAddresses(chainId: Hex): Hex[] {\n    const { allTokens, allDetectedTokens } = this.config;\n    const tokens = allTokens[chainId]?.[this.config.selectedAddress] || [];\n    const detectedTokens =\n      allDetectedTokens[chainId]?.[this.config.selectedAddress] || [];\n\n    return [\n      ...new Set(\n        [...tokens, ...detectedTokens].map((token) =>\n          toHex(toChecksumHexAddress(token.address)),\n        ),\n      ),\n    ].sort();\n  }\n\n  /**\n   * Start (or restart) polling.\n   */\n  async start() {\n    this.#stopPoll();\n    this.#pollState = PollState.Active;\n    await this.#poll();\n  }\n\n  /**\n   * Stop polling.\n   */\n  stop() {\n    this.#stopPoll();\n    this.#pollState = PollState.Inactive;\n  }\n\n  /**\n   * Clear the active polling timer, if present.\n   */\n  #stopPoll() {\n    if (this.handle) {\n      clearTimeout(this.handle);\n    }\n  }\n\n  /**\n   * Poll for exchange rate updates.\n   */\n  async #poll() {\n    await safelyExecute(() => this.updateExchangeRates());\n\n    // Poll using recursive `setTimeout` instead of `setInterval` so that\n    // requests don't stack if they take longer than the polling interval\n    this.handle = setTimeout(() => {\n      this.#poll();\n    }, this.config.interval);\n  }\n\n  /**\n   * Updates exchange rates for all tokens.\n   */\n  async updateExchangeRates() {\n    const { chainId, nativeCurrency } = this.config;\n    await this.updateExchangeRatesByChainId({\n      chainId,\n      nativeCurrency,\n    });\n  }\n\n  /**\n   * Updates exchange rates for all tokens.\n   *\n   * @param options - The options to fetch exchange rates.\n   * @param options.chainId - The chain ID.\n   * @param options.nativeCurrency - The ticker for the chain.\n   */\n  async updateExchangeRatesByChainId({\n    chainId,\n    nativeCurrency,\n  }: {\n    chainId: Hex;\n    nativeCurrency: string;\n  }) {\n    if (this.disabled) {\n      return;\n    }\n\n    const tokenAddresses = this.#getTokenAddresses(chainId);\n\n    const updateKey: `${Hex}:${string}` = `${chainId}:${nativeCurrency}`;\n    if (updateKey in this.#inProcessExchangeRateUpdates) {\n      // This prevents redundant updates\n      // This promise is resolved after the in-progress update has finished,\n      // and state has been updated.\n      await this.#inProcessExchangeRateUpdates[updateKey];\n      return;\n    }\n\n    const {\n      promise: inProgressUpdate,\n      resolve: updateSucceeded,\n      reject: updateFailed,\n    } = createDeferredPromise({ suppressUnhandledRejection: true });\n    this.#inProcessExchangeRateUpdates[updateKey] = inProgressUpdate;\n\n    try {\n      const contractInformations = await this.#fetchAndMapExchangeRates({\n        tokenAddresses,\n        chainId,\n        nativeCurrency,\n      });\n\n      const marketData = {\n        [chainId]: {\n          ...(contractInformations.marketData ?? {}),\n        },\n      };\n\n      this.update({\n        marketData,\n      });\n      updateSucceeded();\n    } catch (error: unknown) {\n      updateFailed(error);\n      throw error;\n    } finally {\n      delete this.#inProcessExchangeRateUpdates[updateKey];\n    }\n  }\n\n  /**\n   * Uses the token prices service to retrieve exchange rates for tokens in a\n   * particular currency.\n   *\n   * If the price API does not support the given chain ID, returns an empty\n   * object.\n   *\n   * If the price API does not support the given currency, retrieves exchange\n   * rates in a known currency instead, then converts those rates using the\n   * exchange rate between the known currency and desired currency.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.chainId - The EIP-155 ID of the chain where the tokens live.\n   * @param args.nativeCurrency - The native currency in which to request\n   * exchange rates.\n   * @returns A map from token address to its exchange rate in the native\n   * currency, or an empty map if no exchange rates can be obtained for the\n   * chain ID.\n   */\n  async #fetchAndMapExchangeRates({\n    tokenAddresses,\n    chainId,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    chainId: Hex;\n    nativeCurrency: string;\n  }): Promise<ContractInformations> {\n    if (!this.#tokenPricesService.validateChainIdSupported(chainId)) {\n      return tokenAddresses.reduce(\n        (obj, tokenAddress) => {\n          obj.marketData = {\n            ...obj.marketData,\n            [tokenAddress]: undefined,\n          };\n\n          return obj;\n        },\n        {\n          marketData: {},\n        },\n      );\n    }\n\n    if (this.#tokenPricesService.validateCurrencySupported(nativeCurrency)) {\n      return await this.#fetchAndMapExchangeRatesForSupportedNativeCurrency({\n        tokenAddresses,\n        chainId,\n        nativeCurrency,\n      });\n    }\n    return await this.#fetchAndMapExchangeRatesForUnsupportedNativeCurrency({\n      tokenAddresses,\n      nativeCurrency,\n    });\n  }\n\n  /**\n   * Updates token rates for the given networkClientId\n   *\n   * @param networkClientId - The network client ID used to get a ticker value.\n   * @returns The controller state.\n   */\n  async _executePoll(networkClientId: NetworkClientId): Promise<void> {\n    const networkClient = this.getNetworkClientById(networkClientId);\n    await this.updateExchangeRatesByChainId({\n      chainId: networkClient.configuration.chainId,\n      nativeCurrency: networkClient.configuration.ticker,\n    });\n  }\n\n  /**\n   * Retrieves prices in the given currency for the given tokens on the given\n   * chain. Ensures that token addresses are checksum addresses.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.chainId - The EIP-155 ID of the chain where the tokens live.\n   * @param args.nativeCurrency - The native currency in which to request\n   * prices.\n   * @returns A map of the token addresses (as checksums) to their prices in the\n   * native currency.\n   */\n  async #fetchAndMapExchangeRatesForSupportedNativeCurrency({\n    tokenAddresses,\n    chainId,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    chainId: Hex;\n    nativeCurrency: string;\n  }): Promise<ContractInformations> {\n    let contractNativeInformations;\n    const tokenPricesByTokenAddress = await reduceInBatchesSerially<\n      Hex,\n      Awaited<ReturnType<AbstractTokenPricesService['fetchTokenPrices']>>\n    >({\n      values: [...tokenAddresses].sort(),\n      batchSize: TOKEN_PRICES_BATCH_SIZE,\n      eachBatch: async (allTokenPricesByTokenAddress, batch) => {\n        const tokenPricesByTokenAddressForBatch =\n          await this.#tokenPricesService.fetchTokenPrices({\n            tokenAddresses: batch,\n            chainId,\n            currency: nativeCurrency,\n          });\n\n        return {\n          ...allTokenPricesByTokenAddress,\n          ...tokenPricesByTokenAddressForBatch,\n        };\n      },\n      initialResult: {},\n    });\n    contractNativeInformations = tokenPricesByTokenAddress;\n\n    // fetch for native token\n    if (tokenAddresses.length === 0) {\n      const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';\n\n      const contractNativeInformationsNative =\n        await this.#tokenPricesService.fetchTokenPrices({\n          tokenAddresses: [ZERO_ADDRESS],\n          chainId: this.config.chainId,\n          currency: nativeCurrency,\n        });\n\n      contractNativeInformations = {\n        [ZERO_ADDRESS]: {\n          currency: nativeCurrency,\n          ...contractNativeInformationsNative[ZERO_ADDRESS],\n        },\n      };\n    }\n    return Object.entries(contractNativeInformations).reduce(\n      (obj, [tokenAddress, tokenPrice]) => {\n        obj.marketData = {\n          ...obj.marketData,\n          [tokenAddress.toLowerCase()]: { ...tokenPrice },\n        };\n\n        return obj;\n      },\n      {\n        marketData: {},\n      },\n    );\n  }\n\n  /**\n   * If the price API does not support a given native currency, then we need to\n   * convert it to a fallback currency and feed that currency into the price\n   * API, then convert the prices to our desired native currency.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.nativeCurrency - The native currency in which to request\n   * prices.\n   * @returns A map of the token addresses (as checksums) to their prices in the\n   * native currency.\n   */\n  async #fetchAndMapExchangeRatesForUnsupportedNativeCurrency({\n    tokenAddresses,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    nativeCurrency: string;\n  }): Promise<ContractInformations> {\n    const [\n      contractExchangeInformations,\n      fallbackCurrencyToNativeCurrencyConversionRate,\n    ] = await Promise.all([\n      this.#fetchAndMapExchangeRatesForSupportedNativeCurrency({\n        tokenAddresses,\n        chainId: this.config.chainId,\n        nativeCurrency: FALL_BACK_VS_CURRENCY,\n      }),\n      getCurrencyConversionRate({\n        from: FALL_BACK_VS_CURRENCY,\n        to: nativeCurrency,\n      }),\n    ]);\n\n    if (fallbackCurrencyToNativeCurrencyConversionRate === null) {\n      return {\n        marketData: {},\n      };\n    }\n\n    const updatedContractExchangeRates = Object.entries(\n      contractExchangeInformations.marketData,\n    ).reduce(\n      (obj, [tokenAddress, tokenValue]) => {\n        obj.marketData = {\n          ...obj.marketData,\n          [tokenAddress]: {\n            ...tokenValue,\n            value: tokenValue.value\n              ? tokenValue.value *\n                fallbackCurrencyToNativeCurrencyConversionRate\n              : undefined,\n          },\n        };\n        return obj;\n      },\n      {\n        marketData: {},\n      },\n    );\n\n    return updatedContractExchangeRates;\n  }\n}\n\nexport default TokenRatesController;\n"]}
\ No newline at end of file
diff --git a/dist/chunk-6XOM7KOQ.mjs b/dist/chunk-6XOM7KOQ.mjs
deleted file mode 100644
index 2dc7a4fdd65673d7432ba7269d1769ba5ea86c3a..0000000000000000000000000000000000000000
--- a/dist/chunk-6XOM7KOQ.mjs
+++ /dev/null
@@ -1,704 +0,0 @@
-import {
-  ERC1155Standard
-} from "./chunk-S7UA2DU7.mjs";
-import {
-  ERC20Standard
-} from "./chunk-LLYYJY7H.mjs";
-import {
-  TOKEN_METADATA_NO_SUPPORT_ERROR,
-  fetchTokenMetadata
-} from "./chunk-NXGX7LZJ.mjs";
-import {
-  formatAggregatorNames,
-  formatIconUrlWithProxy
-} from "./chunk-X5PLVMOQ.mjs";
-
-// src/TokensController.ts
-import { Contract } from "@ethersproject/contracts";
-import { Web3Provider } from "@ethersproject/providers";
-import { BaseControllerV1 } from "@metamask/base-controller";
-import contractsMap from "@metamask/contract-metadata";
-import {
-  toChecksumHexAddress,
-  ERC721_INTERFACE_ID,
-  ORIGIN_METAMASK,
-  ApprovalType,
-  ERC20,
-  ERC721,
-  ERC1155,
-  isValidHexAddress,
-  safelyExecute
-} from "@metamask/controller-utils";
-import { abiERC721 } from "@metamask/metamask-eth-abis";
-import { rpcErrors } from "@metamask/rpc-errors";
-import { Mutex } from "async-mutex";
-import { EventEmitter } from "events";
-import { v1 as random } from "uuid";
-var controllerName = "TokensController";
-var getDefaultTokensState = () => {
-  return {
-    tokens: [],
-    ignoredTokens: [],
-    detectedTokens: [],
-    allTokens: {},
-    allIgnoredTokens: {},
-    allDetectedTokens: {}
-  };
-};
-var TokensController = class extends BaseControllerV1 {
-  /**
-   * Creates a TokensController instance.
-   *
-   * @param options - The controller options.
-   * @param options.chainId - The chain ID of the current network.
-   * @param options.config - Initial options used to configure this controller.
-   * @param options.state - Initial state to set on this controller.
-   * @param options.messenger - The controller messenger.
-   */
-  constructor({
-    chainId: initialChainId,
-    config,
-    state,
-    messenger
-  }) {
-    super(config, state);
-    this.mutex = new Mutex();
-    /**
-     * EventEmitter instance used to listen to specific EIP747 events
-     */
-    this.hub = new EventEmitter();
-    /**
-     * Name of this controller used during composition
-     */
-    this.name = "TokensController";
-    this.defaultConfig = {
-      selectedAddress: "",
-      chainId: initialChainId,
-      provider: void 0,
-      ...config
-    };
-    this.defaultState = {
-      ...getDefaultTokensState(),
-      ...state
-    };
-    this.initialize();
-    this.abortController = new AbortController();
-    this.messagingSystem = messenger;
-    this.messagingSystem.registerActionHandler(
-      `${controllerName}:addDetectedTokens`,
-      this.addDetectedTokens.bind(this)
-    );
-    this.messagingSystem.subscribe(
-      "PreferencesController:stateChange",
-      ({ selectedAddress }) => {
-        const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
-        const { chainId } = this.config;
-        this.configure({ selectedAddress });
-        this.update({
-          tokens: allTokens[chainId]?.[selectedAddress] ?? [],
-          ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] ?? [],
-          detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] ?? []
-        });
-      }
-    );
-    this.messagingSystem.subscribe(
-      "NetworkController:networkDidChange",
-      ({ providerConfig }) => {
-        const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
-        const { selectedAddress } = this.config;
-        const { chainId } = providerConfig;
-        this.abortController.abort();
-        this.abortController = new AbortController();
-        this.configure({ chainId });
-        this.update({
-          tokens: allTokens[chainId]?.[selectedAddress] || [],
-          ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] || [],
-          detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] || []
-        });
-      }
-    );
-    this.messagingSystem.subscribe(
-      "TokenListController:stateChange",
-      ({ tokenList }) => {
-        const { tokens } = this.state;
-        if (tokens.length && !tokens[0].name) {
-          this.updateTokensAttribute(tokenList, "name");
-        }
-      }
-    );
-  }
-  /**
-   * Fetch metadata for a token.
-   *
-   * @param tokenAddress - The address of the token.
-   * @returns The token metadata.
-   */
-  async fetchTokenMetadata(tokenAddress) {
-    try {
-      const token = await fetchTokenMetadata(
-        this.config.chainId,
-        tokenAddress,
-        this.abortController.signal
-      );
-      return token;
-    } catch (error) {
-      if (error instanceof Error && error.message.includes(TOKEN_METADATA_NO_SUPPORT_ERROR)) {
-        return void 0;
-      }
-      throw error;
-    }
-  }
-  /**
-   * Adds a token to the stored token list.
-   *
-   * @param options - The method argument object.
-   * @param options.address - Hex address of the token contract.
-   * @param options.symbol - Symbol of the token.
-   * @param options.decimals - Number of decimals the token uses.
-   * @param options.name - Name of the token.
-   * @param options.image - Image of the token.
-   * @param options.interactingAddress - The address of the account to add a token to.
-   * @param options.networkClientId - Network Client ID.
-   * @returns Current token list.
-   */
-  async addToken({
-    address,
-    symbol,
-    decimals,
-    name,
-    image,
-    interactingAddress,
-    networkClientId
-  }) {
-    const { chainId, selectedAddress } = this.config;
-    const releaseLock = await this.mutex.acquire();
-    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
-    let currentChainId = chainId;
-    if (networkClientId) {
-      currentChainId = this.messagingSystem.call(
-        "NetworkController:getNetworkClientById",
-        networkClientId
-      ).configuration.chainId;
-    }
-    const accountAddress = interactingAddress || selectedAddress;
-    const isInteractingWithWalletAccount = accountAddress === selectedAddress;
-    try {
-      address = toChecksumHexAddress(address);
-      const tokens = allTokens[currentChainId]?.[accountAddress] || [];
-      const ignoredTokens = allIgnoredTokens[currentChainId]?.[accountAddress] || [];
-      const detectedTokens = allDetectedTokens[currentChainId]?.[accountAddress] || [];
-      const newTokens = [...tokens];
-      const [isERC721, tokenMetadata] = await Promise.all([
-        this._detectIsERC721(address, networkClientId),
-        // TODO parameterize the token metadata fetch by networkClientId
-        this.fetchTokenMetadata(address)
-      ]);
-      if (!networkClientId && currentChainId !== this.config.chainId) {
-        throw new Error(
-          "TokensController Error: Switched networks while adding token"
-        );
-      }
-      const newEntry = {
-        address,
-        symbol,
-        decimals,
-        image: image || formatIconUrlWithProxy({
-          chainId: currentChainId,
-          tokenAddress: address
-        }),
-        isERC721,
-        aggregators: formatAggregatorNames(tokenMetadata?.aggregators || []),
-        name
-      };
-      const previousIndex = newTokens.findIndex(
-        (token) => token.address.toLowerCase() === address.toLowerCase()
-      );
-      if (previousIndex !== -1) {
-        newTokens[previousIndex] = newEntry;
-      } else {
-        newTokens.push(newEntry);
-      }
-      const newIgnoredTokens = ignoredTokens.filter(
-        (tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase()
-      );
-      const newDetectedTokens = detectedTokens.filter(
-        (token) => token.address.toLowerCase() !== address.toLowerCase()
-      );
-      const { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens } = this._getNewAllTokensState({
-        newTokens,
-        newIgnoredTokens,
-        newDetectedTokens,
-        interactingAddress: accountAddress,
-        interactingChainId: currentChainId
-      });
-      let newState = {
-        allTokens: newAllTokens,
-        allIgnoredTokens: newAllIgnoredTokens,
-        allDetectedTokens: newAllDetectedTokens
-      };
-      if (isInteractingWithWalletAccount) {
-        newState = {
-          ...newState,
-          tokens: newTokens,
-          ignoredTokens: newIgnoredTokens,
-          detectedTokens: newDetectedTokens
-        };
-      }
-      this.update(newState);
-      return newTokens;
-    } finally {
-      releaseLock();
-    }
-  }
-  /**
-   * Add a batch of tokens.
-   *
-   * @param tokensToImport - Array of tokens to import.
-   * @param networkClientId - Optional network client ID used to determine interacting chain ID.
-   */
-  async addTokens(tokensToImport, networkClientId) {
-    const releaseLock = await this.mutex.acquire();
-    const { tokens, detectedTokens, ignoredTokens } = this.state;
-    const importedTokensMap = {};
-    const newTokensMap = tokens.reduce((output, current) => {
-      output[current.address] = current;
-      return output;
-    }, {});
-    try {
-      tokensToImport.forEach((tokenToAdd) => {
-        const { address, symbol, decimals, image, aggregators, name } = tokenToAdd;
-        const checksumAddress = toChecksumHexAddress(address);
-        const formattedToken = {
-          address: checksumAddress,
-          symbol,
-          decimals,
-          image,
-          aggregators,
-          name
-        };
-        newTokensMap[address] = formattedToken;
-        importedTokensMap[address.toLowerCase()] = true;
-        return formattedToken;
-      });
-      const newTokens = Object.values(newTokensMap);
-      const newDetectedTokens = detectedTokens.filter(
-        (token) => !importedTokensMap[token.address.toLowerCase()]
-      );
-      const newIgnoredTokens = ignoredTokens.filter(
-        (tokenAddress) => !newTokensMap[tokenAddress.toLowerCase()]
-      );
-      let interactingChainId;
-      if (networkClientId) {
-        interactingChainId = this.messagingSystem.call(
-          "NetworkController:getNetworkClientById",
-          networkClientId
-        ).configuration.chainId;
-      }
-      const { newAllTokens, newAllDetectedTokens, newAllIgnoredTokens } = this._getNewAllTokensState({
-        newTokens,
-        newDetectedTokens,
-        newIgnoredTokens,
-        interactingChainId
-      });
-      this.update({
-        tokens: newTokens,
-        allTokens: newAllTokens,
-        detectedTokens: newDetectedTokens,
-        allDetectedTokens: newAllDetectedTokens,
-        ignoredTokens: newIgnoredTokens,
-        allIgnoredTokens: newAllIgnoredTokens
-      });
-    } finally {
-      releaseLock();
-    }
-  }
-  /**
-   * Ignore a batch of tokens.
-   *
-   * @param tokenAddressesToIgnore - Array of token addresses to ignore.
-   */
-  ignoreTokens(tokenAddressesToIgnore) {
-    const { ignoredTokens, detectedTokens, tokens } = this.state;
-    const ignoredTokensMap = {};
-    let newIgnoredTokens = [...ignoredTokens];
-    const checksummedTokenAddresses = tokenAddressesToIgnore.map((address) => {
-      const checksumAddress = toChecksumHexAddress(address);
-      ignoredTokensMap[address.toLowerCase()] = true;
-      return checksumAddress;
-    });
-    newIgnoredTokens = [...ignoredTokens, ...checksummedTokenAddresses];
-    const newDetectedTokens = detectedTokens.filter(
-      (token) => !ignoredTokensMap[token.address.toLowerCase()]
-    );
-    const newTokens = tokens.filter(
-      (token) => !ignoredTokensMap[token.address.toLowerCase()]
-    );
-    const { newAllIgnoredTokens, newAllDetectedTokens, newAllTokens } = this._getNewAllTokensState({
-      newIgnoredTokens,
-      newDetectedTokens,
-      newTokens
-    });
-    this.update({
-      ignoredTokens: newIgnoredTokens,
-      tokens: newTokens,
-      detectedTokens: newDetectedTokens,
-      allIgnoredTokens: newAllIgnoredTokens,
-      allDetectedTokens: newAllDetectedTokens,
-      allTokens: newAllTokens
-    });
-  }
-  /**
-   * Adds a batch of detected tokens to the stored token list.
-   *
-   * @param incomingDetectedTokens - Array of detected tokens to be added or updated.
-   * @param detectionDetails - An object containing the chain ID and address of the currently selected network on which the incomingDetectedTokens were detected.
-   * @param detectionDetails.selectedAddress - the account address on which the incomingDetectedTokens were detected.
-   * @param detectionDetails.chainId - the chainId on which the incomingDetectedTokens were detected.
-   */
-  async addDetectedTokens(incomingDetectedTokens, detectionDetails) {
-    const releaseLock = await this.mutex.acquire();
-    const chainId = detectionDetails?.chainId ?? this.config.chainId;
-    const accountAddress = detectionDetails?.selectedAddress ?? this.config.selectedAddress;
-    const { allTokens, allDetectedTokens, allIgnoredTokens } = this.state;
-    let newTokens = [...allTokens?.[chainId]?.[accountAddress] ?? []];
-    let newDetectedTokens = [
-      ...allDetectedTokens?.[chainId]?.[accountAddress] ?? []
-    ];
-    try {
-      incomingDetectedTokens.forEach((tokenToAdd) => {
-        const {
-          address,
-          symbol,
-          decimals,
-          image,
-          aggregators,
-          isERC721,
-          name
-        } = tokenToAdd;
-        const checksumAddress = toChecksumHexAddress(address);
-        const newEntry = {
-          address: checksumAddress,
-          symbol,
-          decimals,
-          image,
-          isERC721,
-          aggregators,
-          name
-        };
-        const previousImportedIndex = newTokens.findIndex(
-          (token) => token.address.toLowerCase() === checksumAddress.toLowerCase()
-        );
-        if (previousImportedIndex !== -1) {
-          newTokens[previousImportedIndex] = newEntry;
-        } else {
-          const ignoredTokenIndex = allIgnoredTokens?.[chainId]?.[accountAddress]?.indexOf(address) ?? -1;
-          if (ignoredTokenIndex === -1) {
-            const previousDetectedIndex = newDetectedTokens.findIndex(
-              (token) => token.address.toLowerCase() === checksumAddress.toLowerCase()
-            );
-            if (previousDetectedIndex !== -1) {
-              newDetectedTokens[previousDetectedIndex] = newEntry;
-            } else {
-              newDetectedTokens.push(newEntry);
-            }
-          }
-        }
-      });
-      const { newAllTokens, newAllDetectedTokens } = this._getNewAllTokensState(
-        {
-          newTokens,
-          newDetectedTokens,
-          interactingAddress: accountAddress,
-          interactingChainId: chainId
-        }
-      );
-      const { chainId: currentChain, selectedAddress: currentAddress } = this.config;
-      newTokens = newAllTokens?.[currentChain]?.[currentAddress] || [];
-      newDetectedTokens = newAllDetectedTokens?.[currentChain]?.[currentAddress] || [];
-      this.update({
-        tokens: newTokens,
-        allTokens: newAllTokens,
-        detectedTokens: newDetectedTokens,
-        allDetectedTokens: newAllDetectedTokens
-      });
-    } finally {
-      releaseLock();
-    }
-  }
-  /**
-   * Adds isERC721 field to token object. This is called when a user attempts to add tokens that
-   * were previously added which do not yet had isERC721 field.
-   *
-   * @param tokenAddress - The contract address of the token requiring the isERC721 field added.
-   * @returns The new token object with the added isERC721 field.
-   */
-  async updateTokenType(tokenAddress) {
-    const isERC721 = await this._detectIsERC721(tokenAddress);
-    const { tokens } = this.state;
-    const tokenIndex = tokens.findIndex((token) => {
-      return token.address.toLowerCase() === tokenAddress.toLowerCase();
-    });
-    tokens[tokenIndex].isERC721 = isERC721;
-    this.update({ tokens });
-    return tokens[tokenIndex];
-  }
-  /**
-   * This is a function that updates the tokens name for the tokens name if it is not defined.
-   *
-   * @param tokenList - Represents the fetched token list from service API
-   * @param tokenAttribute - Represents the token attribute that we want to update on the token list
-   */
-  updateTokensAttribute(tokenList, tokenAttribute) {
-    const { tokens } = this.state;
-    const newTokens = tokens.map((token) => {
-      const newToken = tokenList[token.address.toLowerCase()];
-      return !token[tokenAttribute] && newToken?.[tokenAttribute] ? { ...token, [tokenAttribute]: newToken[tokenAttribute] } : { ...token };
-    });
-    this.update({ tokens: newTokens });
-  }
-  /**
-   * Detects whether or not a token is ERC-721 compatible.
-   *
-   * @param tokenAddress - The token contract address.
-   * @param networkClientId - Optional network client ID to fetch contract info with.
-   * @returns A boolean indicating whether the token address passed in supports the EIP-721
-   * interface.
-   */
-  async _detectIsERC721(tokenAddress, networkClientId) {
-    const checksumAddress = toChecksumHexAddress(tokenAddress);
-    if (contractsMap[checksumAddress]?.erc721 === true) {
-      return Promise.resolve(true);
-    } else if (contractsMap[checksumAddress]?.erc20 === true) {
-      return Promise.resolve(false);
-    }
-    const tokenContract = this._createEthersContract(
-      tokenAddress,
-      abiERC721,
-      networkClientId
-    );
-    try {
-      return await tokenContract.supportsInterface(ERC721_INTERFACE_ID);
-    } catch (error) {
-      return false;
-    }
-  }
-  _getProvider(networkClientId) {
-    return new Web3Provider(
-      // @ts-expect-error TODO: remove this annotation once the `Eip1193Provider` class is released
-      networkClientId ? this.messagingSystem.call(
-        "NetworkController:getNetworkClientById",
-        networkClientId
-      ).provider : this.config.provider
-    );
-  }
-  _createEthersContract(tokenAddress, abi, networkClientId) {
-    const web3provider = this._getProvider(networkClientId);
-    const tokenContract = new Contract(tokenAddress, abi, web3provider);
-    return tokenContract;
-  }
-  _generateRandomId() {
-    return random();
-  }
-  /**
-   * Adds a new suggestedAsset to the list of watched assets.
-   * Parameters will be validated according to the asset type being watched.
-   *
-   * @param options - The method options.
-   * @param options.asset - The asset to be watched. For now only ERC20 tokens are accepted.
-   * @param options.type - The asset type.
-   * @param options.interactingAddress - The address of the account that is requesting to watch the asset.
-   * @param options.networkClientId - Network Client ID.
-   * @returns A promise that resolves if the asset was watched successfully, and rejects otherwise.
-   */
-  async watchAsset({
-    asset,
-    type,
-    interactingAddress,
-    networkClientId
-  }) {
-    if (type !== ERC20) {
-      throw new Error(`Asset of type ${type} not supported`);
-    }
-    if (!asset.address) {
-      throw rpcErrors.invalidParams("Address must be specified");
-    }
-    if (!isValidHexAddress(asset.address)) {
-      throw rpcErrors.invalidParams(`Invalid address "${asset.address}"`);
-    }
-    if (await this._detectIsERC721(asset.address, networkClientId)) {
-      throw rpcErrors.invalidParams(
-        `Contract ${asset.address} must match type ${type}, but was detected as ${ERC721}`
-      );
-    }
-    const provider = this._getProvider(networkClientId);
-    const isErc1155 = await safelyExecute(
-      () => new ERC1155Standard(provider).contractSupportsBase1155Interface(
-        asset.address
-      )
-    );
-    if (isErc1155) {
-      throw rpcErrors.invalidParams(
-        `Contract ${asset.address} must match type ${type}, but was detected as ${ERC1155}`
-      );
-    }
-    const erc20 = new ERC20Standard(provider);
-    const [contractName, contractSymbol, contractDecimals] = await Promise.all([
-      safelyExecute(() => erc20.getTokenName(asset.address)),
-      safelyExecute(() => erc20.getTokenSymbol(asset.address)),
-      safelyExecute(async () => erc20.getTokenDecimals(asset.address))
-    ]);
-    asset.name = contractName;
-    if (!asset.symbol && !contractSymbol) {
-      throw rpcErrors.invalidParams(
-        "A symbol is required, but was not found in either the request or contract"
-      );
-    }
-    if (contractSymbol !== void 0 && asset.symbol !== void 0 && asset.symbol.toUpperCase() !== contractSymbol.toUpperCase()) {
-      throw rpcErrors.invalidParams(
-        `The symbol in the request (${asset.symbol}) does not match the symbol in the contract (${contractSymbol})`
-      );
-    }
-    asset.symbol = contractSymbol ?? asset.symbol;
-    if (typeof asset.symbol !== "string") {
-      throw rpcErrors.invalidParams(`Invalid symbol: not a string`);
-    }
-    if (asset.symbol.length > 11) {
-      throw rpcErrors.invalidParams(
-        `Invalid symbol "${asset.symbol}": longer than 11 characters`
-      );
-    }
-    if (asset.decimals === void 0 && contractDecimals === void 0) {
-      throw rpcErrors.invalidParams(
-        "Decimals are required, but were not found in either the request or contract"
-      );
-    }
-    if (contractDecimals !== void 0 && asset.decimals !== void 0 && String(asset.decimals) !== contractDecimals) {
-      throw rpcErrors.invalidParams(
-        `The decimals in the request (${asset.decimals}) do not match the decimals in the contract (${contractDecimals})`
-      );
-    }
-    const decimalsStr = contractDecimals ?? asset.decimals;
-    const decimalsNum = parseInt(decimalsStr, 10);
-    if (!Number.isInteger(decimalsNum) || decimalsNum > 36 || decimalsNum < 0) {
-      throw rpcErrors.invalidParams(
-        `Invalid decimals "${decimalsStr}": must be an integer 0 <= 36`
-      );
-    }
-    asset.decimals = decimalsNum;
-    const suggestedAssetMeta = {
-      asset,
-      id: this._generateRandomId(),
-      time: Date.now(),
-      type,
-      interactingAddress: interactingAddress || this.config.selectedAddress
-    };
-    await this._requestApproval(suggestedAssetMeta);
-    const { address, symbol, decimals, name, image } = asset;
-    await this.addToken({
-      address,
-      symbol,
-      decimals,
-      name,
-      image,
-      interactingAddress: suggestedAssetMeta.interactingAddress,
-      networkClientId
-    });
-  }
-  /**
-   * Takes a new tokens and ignoredTokens array for the current network/account combination
-   * and returns new allTokens and allIgnoredTokens state to update to.
-   *
-   * @param params - Object that holds token params.
-   * @param params.newTokens - The new tokens to set for the current network and selected account.
-   * @param params.newIgnoredTokens - The new ignored tokens to set for the current network and selected account.
-   * @param params.newDetectedTokens - The new detected tokens to set for the current network and selected account.
-   * @param params.interactingAddress - The account address to use to store the tokens.
-   * @param params.interactingChainId - The chainId to use to store the tokens.
-   * @returns The updated `allTokens` and `allIgnoredTokens` state.
-   */
-  _getNewAllTokensState(params) {
-    const {
-      newTokens,
-      newIgnoredTokens,
-      newDetectedTokens,
-      interactingAddress,
-      interactingChainId
-    } = params;
-    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
-    const { chainId, selectedAddress } = this.config;
-    const userAddressToAddTokens = interactingAddress ?? selectedAddress;
-    const chainIdToAddTokens = interactingChainId ?? chainId;
-    let newAllTokens = allTokens;
-    if (newTokens?.length || newTokens && allTokens && allTokens[chainIdToAddTokens] && allTokens[chainIdToAddTokens][userAddressToAddTokens]) {
-      const networkTokens = allTokens[chainIdToAddTokens];
-      const newNetworkTokens = {
-        ...networkTokens,
-        ...{ [userAddressToAddTokens]: newTokens }
-      };
-      newAllTokens = {
-        ...allTokens,
-        ...{ [chainIdToAddTokens]: newNetworkTokens }
-      };
-    }
-    let newAllIgnoredTokens = allIgnoredTokens;
-    if (newIgnoredTokens?.length || newIgnoredTokens && allIgnoredTokens && allIgnoredTokens[chainIdToAddTokens] && allIgnoredTokens[chainIdToAddTokens][userAddressToAddTokens]) {
-      const networkIgnoredTokens = allIgnoredTokens[chainIdToAddTokens];
-      const newIgnoredNetworkTokens = {
-        ...networkIgnoredTokens,
-        ...{ [userAddressToAddTokens]: newIgnoredTokens }
-      };
-      newAllIgnoredTokens = {
-        ...allIgnoredTokens,
-        ...{ [chainIdToAddTokens]: newIgnoredNetworkTokens }
-      };
-    }
-    let newAllDetectedTokens = allDetectedTokens;
-    if (newDetectedTokens?.length || newDetectedTokens && allDetectedTokens && allDetectedTokens[chainIdToAddTokens] && allDetectedTokens[chainIdToAddTokens][userAddressToAddTokens]) {
-      const networkDetectedTokens = allDetectedTokens[chainIdToAddTokens];
-      const newDetectedNetworkTokens = {
-        ...networkDetectedTokens,
-        ...{ [userAddressToAddTokens]: newDetectedTokens }
-      };
-      newAllDetectedTokens = {
-        ...allDetectedTokens,
-        ...{ [chainIdToAddTokens]: newDetectedNetworkTokens }
-      };
-    }
-    return { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens };
-  }
-  /**
-   * Removes all tokens from the ignored list.
-   */
-  clearIgnoredTokens() {
-    this.update({ ignoredTokens: [], allIgnoredTokens: {} });
-  }
-  async _requestApproval(suggestedAssetMeta) {
-    return this.messagingSystem.call(
-      "ApprovalController:addRequest",
-      {
-        id: suggestedAssetMeta.id,
-        origin: ORIGIN_METAMASK,
-        type: ApprovalType.WatchAsset,
-        requestData: {
-          id: suggestedAssetMeta.id,
-          interactingAddress: suggestedAssetMeta.interactingAddress,
-          asset: {
-            address: suggestedAssetMeta.asset.address,
-            decimals: suggestedAssetMeta.asset.decimals,
-            symbol: suggestedAssetMeta.asset.symbol,
-            image: suggestedAssetMeta.asset.image || null
-          }
-        }
-      },
-      true
-    );
-  }
-};
-var TokensController_default = TokensController;
-
-export {
-  getDefaultTokensState,
-  TokensController,
-  TokensController_default
-};
-//# sourceMappingURL=chunk-6XOM7KOQ.mjs.map
\ No newline at end of file
diff --git a/dist/chunk-6XOM7KOQ.mjs.map b/dist/chunk-6XOM7KOQ.mjs.map
deleted file mode 100644
index 2efffe9b510b48520ea9bb8d0037678bbbdc495b..0000000000000000000000000000000000000000
--- a/dist/chunk-6XOM7KOQ.mjs.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["../src/TokensController.ts"],"sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport { Web3Provider } from '@ethersproject/providers';\nimport type { AddApprovalRequest } from '@metamask/approval-controller';\nimport type {\n  BaseConfig,\n  BaseState,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseControllerV1 } from '@metamask/base-controller';\nimport contractsMap from '@metamask/contract-metadata';\nimport {\n  toChecksumHexAddress,\n  ERC721_INTERFACE_ID,\n  ORIGIN_METAMASK,\n  ApprovalType,\n  ERC20,\n  ERC721,\n  ERC1155,\n  isValidHexAddress,\n  safelyExecute,\n} from '@metamask/controller-utils';\nimport { abiERC721 } from '@metamask/metamask-eth-abis';\nimport type {\n  NetworkClientId,\n  NetworkControllerGetNetworkClientByIdAction,\n  NetworkControllerNetworkDidChangeEvent,\n  Provider,\n} from '@metamask/network-controller';\nimport type { PreferencesControllerStateChangeEvent } from '@metamask/preferences-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { Hex } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport { EventEmitter } from 'events';\nimport type { Patch } from 'immer/dist/immer';\nimport { v1 as random } from 'uuid';\n\nimport { formatAggregatorNames, formatIconUrlWithProxy } from './assetsUtil';\nimport { ERC20Standard } from './Standards/ERC20Standard';\nimport { ERC1155Standard } from './Standards/NftStandards/ERC1155/ERC1155Standard';\nimport {\n  fetchTokenMetadata,\n  TOKEN_METADATA_NO_SUPPORT_ERROR,\n} from './token-service';\nimport type {\n  TokenListMap,\n  TokenListStateChange,\n  TokenListToken,\n} from './TokenListController';\nimport type { Token } from './TokenRatesController';\n\n/**\n * @type TokensConfig\n *\n * Tokens controller configuration\n * @property selectedAddress - Vault selected address\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface TokensConfig extends BaseConfig {\n  selectedAddress: string;\n  chainId: Hex;\n  provider: Provider | undefined;\n}\n\n/**\n * @type SuggestedAssetMeta\n *\n * Suggested asset by EIP747 meta data\n * @property id - Generated UUID associated with this suggested asset\n * @property time - Timestamp associated with this this suggested asset\n * @property type - Type type this suggested asset\n * @property asset - Asset suggested object\n * @property interactingAddress - Account address that requested watch asset\n */\ntype SuggestedAssetMeta = {\n  id: string;\n  time: number;\n  type: string;\n  asset: Token;\n  interactingAddress: string;\n};\n\n/**\n * @type TokensState\n *\n * Assets controller state\n * @property tokens - List of tokens associated with the active network and address pair\n * @property ignoredTokens - List of ignoredTokens associated with the active network and address pair\n * @property detectedTokens - List of detected tokens associated with the active network and address pair\n * @property allTokens - Object containing tokens by network and account\n * @property allIgnoredTokens - Object containing hidden/ignored tokens by network and account\n * @property allDetectedTokens - Object containing tokens detected with non-zero balances\n */\nexport type TokensState = {\n  tokens: Token[];\n  ignoredTokens: string[];\n  detectedTokens: Token[];\n  allTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  allIgnoredTokens: { [chainId: Hex]: { [key: string]: string[] } };\n  allDetectedTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n};\n\n/**\n * The name of the {@link TokensController}.\n */\nconst controllerName = 'TokensController';\n\nexport type TokensControllerActions =\n  | TokensControllerGetStateAction\n  | TokensControllerAddDetectedTokensAction;\n\n// TODO: Once `TokensController` is upgraded to V2, rewrite this type using the `ControllerGetStateAction` type, which constrains `TokensState` as `Record<string, Json>`.\nexport type TokensControllerGetStateAction = {\n  type: `${typeof controllerName}:getState`;\n  handler: () => TokensState;\n};\n\nexport type TokensControllerAddDetectedTokensAction = {\n  type: `${typeof controllerName}:addDetectedTokens`;\n  handler: TokensController['addDetectedTokens'];\n};\n\n/**\n * The external actions available to the {@link TokensController}.\n */\nexport type AllowedActions =\n  | AddApprovalRequest\n  | NetworkControllerGetNetworkClientByIdAction;\n\n// TODO: Once `TokensController` is upgraded to V2, rewrite this type using the `ControllerStateChangeEvent` type, which constrains `TokensState` as `Record<string, Json>`.\nexport type TokensControllerStateChangeEvent = {\n  type: `${typeof controllerName}:stateChange`;\n  payload: [TokensState, Patch[]];\n};\n\nexport type TokensControllerEvents = TokensControllerStateChangeEvent;\n\nexport type AllowedEvents =\n  | NetworkControllerNetworkDidChangeEvent\n  | PreferencesControllerStateChangeEvent\n  | TokenListStateChange;\n\n/**\n * The messenger of the {@link TokensController}.\n */\nexport type TokensControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  TokensControllerActions | AllowedActions,\n  TokensControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\nexport const getDefaultTokensState = (): TokensState => {\n  return {\n    tokens: [],\n    ignoredTokens: [],\n    detectedTokens: [],\n    allTokens: {},\n    allIgnoredTokens: {},\n    allDetectedTokens: {},\n  };\n};\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class TokensController extends BaseControllerV1<\n  TokensConfig,\n  TokensState & BaseState\n> {\n  private readonly mutex = new Mutex();\n\n  private abortController: AbortController;\n\n  private readonly messagingSystem: TokensControllerMessenger;\n\n  /**\n   * Fetch metadata for a token.\n   *\n   * @param tokenAddress - The address of the token.\n   * @returns The token metadata.\n   */\n  private async fetchTokenMetadata(\n    tokenAddress: string,\n  ): Promise<TokenListToken | undefined> {\n    try {\n      const token = await fetchTokenMetadata<TokenListToken>(\n        this.config.chainId,\n        tokenAddress,\n        this.abortController.signal,\n      );\n      return token;\n    } catch (error) {\n      if (\n        error instanceof Error &&\n        error.message.includes(TOKEN_METADATA_NO_SUPPORT_ERROR)\n      ) {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokensController';\n\n  /**\n   * Creates a TokensController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.config - Initial options used to configure this controller.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.messenger - The controller messenger.\n   */\n  constructor({\n    chainId: initialChainId,\n    config,\n    state,\n    messenger,\n  }: {\n    chainId: Hex;\n    config?: Partial<TokensConfig>;\n    state?: Partial<TokensState>;\n    messenger: TokensControllerMessenger;\n  }) {\n    super(config, state);\n\n    this.defaultConfig = {\n      selectedAddress: '',\n      chainId: initialChainId,\n      provider: undefined,\n      ...config,\n    };\n\n    this.defaultState = {\n      ...getDefaultTokensState(),\n      ...state,\n    };\n\n    this.initialize();\n    this.abortController = new AbortController();\n\n    this.messagingSystem = messenger;\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:addDetectedTokens` as const,\n      this.addDetectedTokens.bind(this),\n    );\n\n    this.messagingSystem.subscribe(\n      'PreferencesController:stateChange',\n      ({ selectedAddress }) => {\n        const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n        const { chainId } = this.config;\n        this.configure({ selectedAddress });\n        this.update({\n          tokens: allTokens[chainId]?.[selectedAddress] ?? [],\n          ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] ?? [],\n          detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] ?? [],\n        });\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'NetworkController:networkDidChange',\n      ({ providerConfig }) => {\n        const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n        const { selectedAddress } = this.config;\n        const { chainId } = providerConfig;\n        this.abortController.abort();\n        this.abortController = new AbortController();\n        this.configure({ chainId });\n        this.update({\n          tokens: allTokens[chainId]?.[selectedAddress] || [],\n          ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] || [],\n          detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] || [],\n        });\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'TokenListController:stateChange',\n      ({ tokenList }) => {\n        const { tokens } = this.state;\n        if (tokens.length && !tokens[0].name) {\n          this.updateTokensAttribute(tokenList, 'name');\n        }\n      },\n    );\n  }\n\n  /**\n   * Adds a token to the stored token list.\n   *\n   * @param options - The method argument object.\n   * @param options.address - Hex address of the token contract.\n   * @param options.symbol - Symbol of the token.\n   * @param options.decimals - Number of decimals the token uses.\n   * @param options.name - Name of the token.\n   * @param options.image - Image of the token.\n   * @param options.interactingAddress - The address of the account to add a token to.\n   * @param options.networkClientId - Network Client ID.\n   * @returns Current token list.\n   */\n  async addToken({\n    address,\n    symbol,\n    decimals,\n    name,\n    image,\n    interactingAddress,\n    networkClientId,\n  }: {\n    address: string;\n    symbol: string;\n    decimals: number;\n    name?: string;\n    image?: string;\n    interactingAddress?: string;\n    networkClientId?: NetworkClientId;\n  }): Promise<Token[]> {\n    const { chainId, selectedAddress } = this.config;\n    const releaseLock = await this.mutex.acquire();\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    let currentChainId = chainId;\n    if (networkClientId) {\n      currentChainId = this.messagingSystem.call(\n        'NetworkController:getNetworkClientById',\n        networkClientId,\n      ).configuration.chainId;\n    }\n\n    const accountAddress = interactingAddress || selectedAddress;\n    const isInteractingWithWalletAccount = accountAddress === selectedAddress;\n\n    try {\n      address = toChecksumHexAddress(address);\n      const tokens = allTokens[currentChainId]?.[accountAddress] || [];\n      const ignoredTokens =\n        allIgnoredTokens[currentChainId]?.[accountAddress] || [];\n      const detectedTokens =\n        allDetectedTokens[currentChainId]?.[accountAddress] || [];\n      const newTokens: Token[] = [...tokens];\n      const [isERC721, tokenMetadata] = await Promise.all([\n        this._detectIsERC721(address, networkClientId),\n        // TODO parameterize the token metadata fetch by networkClientId\n        this.fetchTokenMetadata(address),\n      ]);\n      // TODO remove this once this method is fully parameterized by networkClientId\n      if (!networkClientId && currentChainId !== this.config.chainId) {\n        throw new Error(\n          'TokensController Error: Switched networks while adding token',\n        );\n      }\n      const newEntry: Token = {\n        address,\n        symbol,\n        decimals,\n        image:\n          image ||\n          formatIconUrlWithProxy({\n            chainId: currentChainId,\n            tokenAddress: address,\n          }),\n        isERC721,\n        aggregators: formatAggregatorNames(tokenMetadata?.aggregators || []),\n        name,\n      };\n      const previousIndex = newTokens.findIndex(\n        (token) => token.address.toLowerCase() === address.toLowerCase(),\n      );\n      if (previousIndex !== -1) {\n        newTokens[previousIndex] = newEntry;\n      } else {\n        newTokens.push(newEntry);\n      }\n\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase(),\n      );\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => token.address.toLowerCase() !== address.toLowerCase(),\n      );\n\n      const { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens } =\n        this._getNewAllTokensState({\n          newTokens,\n          newIgnoredTokens,\n          newDetectedTokens,\n          interactingAddress: accountAddress,\n          interactingChainId: currentChainId,\n        });\n\n      let newState: Partial<TokensState> = {\n        allTokens: newAllTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n        allDetectedTokens: newAllDetectedTokens,\n      };\n\n      // Only update active tokens if user is interacting with their active wallet account.\n      if (isInteractingWithWalletAccount) {\n        newState = {\n          ...newState,\n          tokens: newTokens,\n          ignoredTokens: newIgnoredTokens,\n          detectedTokens: newDetectedTokens,\n        };\n      }\n\n      this.update(newState);\n      return newTokens;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Add a batch of tokens.\n   *\n   * @param tokensToImport - Array of tokens to import.\n   * @param networkClientId - Optional network client ID used to determine interacting chain ID.\n   */\n  async addTokens(tokensToImport: Token[], networkClientId?: NetworkClientId) {\n    const releaseLock = await this.mutex.acquire();\n    const { tokens, detectedTokens, ignoredTokens } = this.state;\n    const importedTokensMap: { [key: string]: true } = {};\n    // Used later to dedupe imported tokens\n    const newTokensMap = tokens.reduce((output, current) => {\n      output[current.address] = current;\n      return output;\n    }, {} as { [address: string]: Token });\n    try {\n      tokensToImport.forEach((tokenToAdd) => {\n        const { address, symbol, decimals, image, aggregators, name } =\n          tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const formattedToken: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          aggregators,\n          name,\n        };\n        newTokensMap[address] = formattedToken;\n        importedTokensMap[address.toLowerCase()] = true;\n        return formattedToken;\n      });\n      const newTokens = Object.values(newTokensMap);\n\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => !importedTokensMap[token.address.toLowerCase()],\n      );\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => !newTokensMap[tokenAddress.toLowerCase()],\n      );\n\n      let interactingChainId;\n      if (networkClientId) {\n        interactingChainId = this.messagingSystem.call(\n          'NetworkController:getNetworkClientById',\n          networkClientId,\n        ).configuration.chainId;\n      }\n\n      const { newAllTokens, newAllDetectedTokens, newAllIgnoredTokens } =\n        this._getNewAllTokensState({\n          newTokens,\n          newDetectedTokens,\n          newIgnoredTokens,\n          interactingChainId,\n        });\n\n      this.update({\n        tokens: newTokens,\n        allTokens: newAllTokens,\n        detectedTokens: newDetectedTokens,\n        allDetectedTokens: newAllDetectedTokens,\n        ignoredTokens: newIgnoredTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Ignore a batch of tokens.\n   *\n   * @param tokenAddressesToIgnore - Array of token addresses to ignore.\n   */\n  ignoreTokens(tokenAddressesToIgnore: string[]) {\n    const { ignoredTokens, detectedTokens, tokens } = this.state;\n    const ignoredTokensMap: { [key: string]: true } = {};\n    let newIgnoredTokens: string[] = [...ignoredTokens];\n\n    const checksummedTokenAddresses = tokenAddressesToIgnore.map((address) => {\n      const checksumAddress = toChecksumHexAddress(address);\n      ignoredTokensMap[address.toLowerCase()] = true;\n      return checksumAddress;\n    });\n    newIgnoredTokens = [...ignoredTokens, ...checksummedTokenAddresses];\n    const newDetectedTokens = detectedTokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n    const newTokens = tokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n\n    const { newAllIgnoredTokens, newAllDetectedTokens, newAllTokens } =\n      this._getNewAllTokensState({\n        newIgnoredTokens,\n        newDetectedTokens,\n        newTokens,\n      });\n\n    this.update({\n      ignoredTokens: newIgnoredTokens,\n      tokens: newTokens,\n      detectedTokens: newDetectedTokens,\n      allIgnoredTokens: newAllIgnoredTokens,\n      allDetectedTokens: newAllDetectedTokens,\n      allTokens: newAllTokens,\n    });\n  }\n\n  /**\n   * Adds a batch of detected tokens to the stored token list.\n   *\n   * @param incomingDetectedTokens - Array of detected tokens to be added or updated.\n   * @param detectionDetails - An object containing the chain ID and address of the currently selected network on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.selectedAddress - the account address on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.chainId - the chainId on which the incomingDetectedTokens were detected.\n   */\n  async addDetectedTokens(\n    incomingDetectedTokens: Token[],\n    detectionDetails?: { selectedAddress: string; chainId: Hex },\n  ) {\n    const releaseLock = await this.mutex.acquire();\n\n    // Get existing tokens for the chain + account\n    const chainId = detectionDetails?.chainId ?? this.config.chainId;\n    const accountAddress =\n      detectionDetails?.selectedAddress ?? this.config.selectedAddress;\n\n    const { allTokens, allDetectedTokens, allIgnoredTokens } = this.state;\n    let newTokens = [...(allTokens?.[chainId]?.[accountAddress] ?? [])];\n    let newDetectedTokens = [\n      ...(allDetectedTokens?.[chainId]?.[accountAddress] ?? []),\n    ];\n\n    try {\n      incomingDetectedTokens.forEach((tokenToAdd) => {\n        const {\n          address,\n          symbol,\n          decimals,\n          image,\n          aggregators,\n          isERC721,\n          name,\n        } = tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const newEntry: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          isERC721,\n          aggregators,\n          name,\n        };\n        const previousImportedIndex = newTokens.findIndex(\n          (token) =>\n            token.address.toLowerCase() === checksumAddress.toLowerCase(),\n        );\n        if (previousImportedIndex !== -1) {\n          // Update existing data of imported token\n          newTokens[previousImportedIndex] = newEntry;\n        } else {\n          const ignoredTokenIndex =\n            allIgnoredTokens?.[chainId]?.[accountAddress]?.indexOf(address) ??\n            -1;\n\n          if (ignoredTokenIndex === -1) {\n            // Add detected token\n            const previousDetectedIndex = newDetectedTokens.findIndex(\n              (token) =>\n                token.address.toLowerCase() === checksumAddress.toLowerCase(),\n            );\n            if (previousDetectedIndex !== -1) {\n              newDetectedTokens[previousDetectedIndex] = newEntry;\n            } else {\n              newDetectedTokens.push(newEntry);\n            }\n          }\n        }\n      });\n\n      const { newAllTokens, newAllDetectedTokens } = this._getNewAllTokensState(\n        {\n          newTokens,\n          newDetectedTokens,\n          interactingAddress: accountAddress,\n          interactingChainId: chainId,\n        },\n      );\n\n      // We may be detecting tokens on a different chain/account pair than are currently configured.\n      // Re-point `tokens` and `detectedTokens` to keep them referencing the current chain/account.\n      const { chainId: currentChain, selectedAddress: currentAddress } =\n        this.config;\n\n      newTokens = newAllTokens?.[currentChain]?.[currentAddress] || [];\n      newDetectedTokens =\n        newAllDetectedTokens?.[currentChain]?.[currentAddress] || [];\n\n      this.update({\n        tokens: newTokens,\n        allTokens: newAllTokens,\n        detectedTokens: newDetectedTokens,\n        allDetectedTokens: newAllDetectedTokens,\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds isERC721 field to token object. This is called when a user attempts to add tokens that\n   * were previously added which do not yet had isERC721 field.\n   *\n   * @param tokenAddress - The contract address of the token requiring the isERC721 field added.\n   * @returns The new token object with the added isERC721 field.\n   */\n  async updateTokenType(tokenAddress: string) {\n    const isERC721 = await this._detectIsERC721(tokenAddress);\n    const { tokens } = this.state;\n    const tokenIndex = tokens.findIndex((token) => {\n      return token.address.toLowerCase() === tokenAddress.toLowerCase();\n    });\n    tokens[tokenIndex].isERC721 = isERC721;\n    this.update({ tokens });\n    return tokens[tokenIndex];\n  }\n\n  /**\n   * This is a function that updates the tokens name for the tokens name if it is not defined.\n   *\n   * @param tokenList - Represents the fetched token list from service API\n   * @param tokenAttribute - Represents the token attribute that we want to update on the token list\n   */\n  private updateTokensAttribute(\n    tokenList: TokenListMap,\n    tokenAttribute: keyof Token & keyof TokenListToken,\n  ) {\n    const { tokens } = this.state;\n\n    const newTokens = tokens.map((token) => {\n      const newToken = tokenList[token.address.toLowerCase()];\n\n      return !token[tokenAttribute] && newToken?.[tokenAttribute]\n        ? { ...token, [tokenAttribute]: newToken[tokenAttribute] }\n        : { ...token };\n    });\n\n    this.update({ tokens: newTokens });\n  }\n\n  /**\n   * Detects whether or not a token is ERC-721 compatible.\n   *\n   * @param tokenAddress - The token contract address.\n   * @param networkClientId - Optional network client ID to fetch contract info with.\n   * @returns A boolean indicating whether the token address passed in supports the EIP-721\n   * interface.\n   */\n  async _detectIsERC721(\n    tokenAddress: string,\n    networkClientId?: NetworkClientId,\n  ) {\n    const checksumAddress = toChecksumHexAddress(tokenAddress);\n    // if this token is already in our contract metadata map we don't need\n    // to check against the contract\n    if (contractsMap[checksumAddress]?.erc721 === true) {\n      return Promise.resolve(true);\n    } else if (contractsMap[checksumAddress]?.erc20 === true) {\n      return Promise.resolve(false);\n    }\n\n    const tokenContract = this._createEthersContract(\n      tokenAddress,\n      abiERC721,\n      networkClientId,\n    );\n    try {\n      return await tokenContract.supportsInterface(ERC721_INTERFACE_ID);\n    } catch (error) {\n      // currently we see a variety of errors across different networks when\n      // token contracts are not ERC721 compatible. We need to figure out a better\n      // way of differentiating token interface types but for now if we get an error\n      // we have to assume the token is not ERC721 compatible.\n      return false;\n    }\n  }\n\n  _getProvider(networkClientId?: NetworkClientId): Web3Provider {\n    return new Web3Provider(\n      // @ts-expect-error TODO: remove this annotation once the `Eip1193Provider` class is released\n      networkClientId\n        ? this.messagingSystem.call(\n            'NetworkController:getNetworkClientById',\n            networkClientId,\n          ).provider\n        : this.config.provider,\n    );\n  }\n\n  _createEthersContract(\n    tokenAddress: string,\n    abi: string,\n    networkClientId?: NetworkClientId,\n  ): Contract {\n    const web3provider = this._getProvider(networkClientId);\n    const tokenContract = new Contract(tokenAddress, abi, web3provider);\n    return tokenContract;\n  }\n\n  _generateRandomId(): string {\n    return random();\n  }\n\n  /**\n   * Adds a new suggestedAsset to the list of watched assets.\n   * Parameters will be validated according to the asset type being watched.\n   *\n   * @param options - The method options.\n   * @param options.asset - The asset to be watched. For now only ERC20 tokens are accepted.\n   * @param options.type - The asset type.\n   * @param options.interactingAddress - The address of the account that is requesting to watch the asset.\n   * @param options.networkClientId - Network Client ID.\n   * @returns A promise that resolves if the asset was watched successfully, and rejects otherwise.\n   */\n  async watchAsset({\n    asset,\n    type,\n    interactingAddress,\n    networkClientId,\n  }: {\n    asset: Token;\n    type: string;\n    interactingAddress?: string;\n    networkClientId?: NetworkClientId;\n  }): Promise<void> {\n    if (type !== ERC20) {\n      throw new Error(`Asset of type ${type} not supported`);\n    }\n\n    if (!asset.address) {\n      throw rpcErrors.invalidParams('Address must be specified');\n    }\n\n    if (!isValidHexAddress(asset.address)) {\n      throw rpcErrors.invalidParams(`Invalid address \"${asset.address}\"`);\n    }\n\n    // Validate contract\n\n    if (await this._detectIsERC721(asset.address, networkClientId)) {\n      throw rpcErrors.invalidParams(\n        `Contract ${asset.address} must match type ${type}, but was detected as ${ERC721}`,\n      );\n    }\n\n    const provider = this._getProvider(networkClientId);\n    const isErc1155 = await safelyExecute(() =>\n      new ERC1155Standard(provider).contractSupportsBase1155Interface(\n        asset.address,\n      ),\n    );\n    if (isErc1155) {\n      throw rpcErrors.invalidParams(\n        `Contract ${asset.address} must match type ${type}, but was detected as ${ERC1155}`,\n      );\n    }\n\n    const erc20 = new ERC20Standard(provider);\n    const [contractName, contractSymbol, contractDecimals] = await Promise.all([\n      safelyExecute(() => erc20.getTokenName(asset.address)),\n      safelyExecute(() => erc20.getTokenSymbol(asset.address)),\n      safelyExecute(async () => erc20.getTokenDecimals(asset.address)),\n    ]);\n\n    asset.name = contractName;\n\n    // Validate symbol\n\n    if (!asset.symbol && !contractSymbol) {\n      throw rpcErrors.invalidParams(\n        'A symbol is required, but was not found in either the request or contract',\n      );\n    }\n\n    if (\n      contractSymbol !== undefined &&\n      asset.symbol !== undefined &&\n      asset.symbol.toUpperCase() !== contractSymbol.toUpperCase()\n    ) {\n      throw rpcErrors.invalidParams(\n        `The symbol in the request (${asset.symbol}) does not match the symbol in the contract (${contractSymbol})`,\n      );\n    }\n\n    asset.symbol = contractSymbol ?? asset.symbol;\n    if (typeof asset.symbol !== 'string') {\n      throw rpcErrors.invalidParams(`Invalid symbol: not a string`);\n    }\n\n    if (asset.symbol.length > 11) {\n      throw rpcErrors.invalidParams(\n        `Invalid symbol \"${asset.symbol}\": longer than 11 characters`,\n      );\n    }\n\n    // Validate decimals\n\n    if (asset.decimals === undefined && contractDecimals === undefined) {\n      throw rpcErrors.invalidParams(\n        'Decimals are required, but were not found in either the request or contract',\n      );\n    }\n\n    if (\n      contractDecimals !== undefined &&\n      asset.decimals !== undefined &&\n      String(asset.decimals) !== contractDecimals\n    ) {\n      throw rpcErrors.invalidParams(\n        `The decimals in the request (${asset.decimals}) do not match the decimals in the contract (${contractDecimals})`,\n      );\n    }\n\n    const decimalsStr = contractDecimals ?? asset.decimals;\n    const decimalsNum = parseInt(decimalsStr as unknown as string, 10);\n    if (!Number.isInteger(decimalsNum) || decimalsNum > 36 || decimalsNum < 0) {\n      throw rpcErrors.invalidParams(\n        `Invalid decimals \"${decimalsStr}\": must be an integer 0 <= 36`,\n      );\n    }\n    asset.decimals = decimalsNum;\n\n    const suggestedAssetMeta: SuggestedAssetMeta = {\n      asset,\n      id: this._generateRandomId(),\n      time: Date.now(),\n      type,\n      interactingAddress: interactingAddress || this.config.selectedAddress,\n    };\n\n    await this._requestApproval(suggestedAssetMeta);\n\n    const { address, symbol, decimals, name, image } = asset;\n    await this.addToken({\n      address,\n      symbol,\n      decimals,\n      name,\n      image,\n      interactingAddress: suggestedAssetMeta.interactingAddress,\n      networkClientId,\n    });\n  }\n\n  /**\n   * Takes a new tokens and ignoredTokens array for the current network/account combination\n   * and returns new allTokens and allIgnoredTokens state to update to.\n   *\n   * @param params - Object that holds token params.\n   * @param params.newTokens - The new tokens to set for the current network and selected account.\n   * @param params.newIgnoredTokens - The new ignored tokens to set for the current network and selected account.\n   * @param params.newDetectedTokens - The new detected tokens to set for the current network and selected account.\n   * @param params.interactingAddress - The account address to use to store the tokens.\n   * @param params.interactingChainId - The chainId to use to store the tokens.\n   * @returns The updated `allTokens` and `allIgnoredTokens` state.\n   */\n  _getNewAllTokensState(params: {\n    newTokens?: Token[];\n    newIgnoredTokens?: string[];\n    newDetectedTokens?: Token[];\n    interactingAddress?: string;\n    interactingChainId?: Hex;\n  }) {\n    const {\n      newTokens,\n      newIgnoredTokens,\n      newDetectedTokens,\n      interactingAddress,\n      interactingChainId,\n    } = params;\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    const { chainId, selectedAddress } = this.config;\n\n    const userAddressToAddTokens = interactingAddress ?? selectedAddress;\n    const chainIdToAddTokens = interactingChainId ?? chainId;\n\n    let newAllTokens = allTokens;\n    if (\n      newTokens?.length ||\n      (newTokens &&\n        allTokens &&\n        allTokens[chainIdToAddTokens] &&\n        allTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkTokens = allTokens[chainIdToAddTokens];\n      const newNetworkTokens = {\n        ...networkTokens,\n        ...{ [userAddressToAddTokens]: newTokens },\n      };\n      newAllTokens = {\n        ...allTokens,\n        ...{ [chainIdToAddTokens]: newNetworkTokens },\n      };\n    }\n\n    let newAllIgnoredTokens = allIgnoredTokens;\n    if (\n      newIgnoredTokens?.length ||\n      (newIgnoredTokens &&\n        allIgnoredTokens &&\n        allIgnoredTokens[chainIdToAddTokens] &&\n        allIgnoredTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkIgnoredTokens = allIgnoredTokens[chainIdToAddTokens];\n      const newIgnoredNetworkTokens = {\n        ...networkIgnoredTokens,\n        ...{ [userAddressToAddTokens]: newIgnoredTokens },\n      };\n      newAllIgnoredTokens = {\n        ...allIgnoredTokens,\n        ...{ [chainIdToAddTokens]: newIgnoredNetworkTokens },\n      };\n    }\n\n    let newAllDetectedTokens = allDetectedTokens;\n    if (\n      newDetectedTokens?.length ||\n      (newDetectedTokens &&\n        allDetectedTokens &&\n        allDetectedTokens[chainIdToAddTokens] &&\n        allDetectedTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkDetectedTokens = allDetectedTokens[chainIdToAddTokens];\n      const newDetectedNetworkTokens = {\n        ...networkDetectedTokens,\n        ...{ [userAddressToAddTokens]: newDetectedTokens },\n      };\n      newAllDetectedTokens = {\n        ...allDetectedTokens,\n        ...{ [chainIdToAddTokens]: newDetectedNetworkTokens },\n      };\n    }\n    return { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens };\n  }\n\n  /**\n   * Removes all tokens from the ignored list.\n   */\n  clearIgnoredTokens() {\n    this.update({ ignoredTokens: [], allIgnoredTokens: {} });\n  }\n\n  async _requestApproval(suggestedAssetMeta: SuggestedAssetMeta) {\n    return this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        id: suggestedAssetMeta.id,\n        origin: ORIGIN_METAMASK,\n        type: ApprovalType.WatchAsset,\n        requestData: {\n          id: suggestedAssetMeta.id,\n          interactingAddress: suggestedAssetMeta.interactingAddress,\n          asset: {\n            address: suggestedAssetMeta.asset.address,\n            decimals: suggestedAssetMeta.asset.decimals,\n            symbol: suggestedAssetMeta.asset.symbol,\n            image: suggestedAssetMeta.asset.image || null,\n          },\n        },\n      },\n      true,\n    );\n  }\n}\n\nexport default TokensController;\n"],"mappings":"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","names":[]}
\ No newline at end of file
diff --git a/dist/chunk-7RV5HGC4.mjs b/dist/chunk-7RV5HGC4.mjs
new file mode 100644
index 0000000000000000000000000000000000000000..b573c2f9c1990568cb8ebc7a007fdc88695d0e0b
--- /dev/null
+++ b/dist/chunk-7RV5HGC4.mjs
@@ -0,0 +1,379 @@
+import {
+  __privateAdd,
+  __privateGet,
+  __privateSet
+} from "./chunk-XUI43LEZ.mjs";
+
+// src/token-prices-service/codefi-v2.ts
+import { handleFetch } from "@metamask/controller-utils";
+import { hexToNumber } from "@metamask/utils";
+import {
+  circuitBreaker,
+  ConsecutiveBreaker,
+  ExponentialBackoff,
+  handleAll,
+  retry,
+  wrap,
+  CircuitState
+} from "cockatiel";
+var SUPPORTED_CURRENCIES = [
+  // Bitcoin
+  "btc",
+  // Ether
+  "eth",
+  // Litecoin
+  "ltc",
+  // Bitcoin Cash
+  "bch",
+  // Binance Coin
+  "bnb",
+  // EOS
+  "eos",
+  // XRP
+  "xrp",
+  // Lumens
+  "xlm",
+  // Chainlink
+  "link",
+  // Polkadot
+  "dot",
+  // Yearn.finance
+  "yfi",
+  // US Dollar
+  "usd",
+  // United Arab Emirates Dirham
+  "aed",
+  // Argentine Peso
+  "ars",
+  // Australian Dollar
+  "aud",
+  // Bangladeshi Taka
+  "bdt",
+  // Bahraini Dinar
+  "bhd",
+  // Bermudian Dollar
+  "bmd",
+  // Brazil Real
+  "brl",
+  // Canadian Dollar
+  "cad",
+  // Swiss Franc
+  "chf",
+  // Chilean Peso
+  "clp",
+  // Chinese Yuan
+  "cny",
+  // Czech Koruna
+  "czk",
+  // Danish Krone
+  "dkk",
+  // Euro
+  "eur",
+  // British Pound Sterling
+  "gbp",
+  // Hong Kong Dollar
+  "hkd",
+  // Hungarian Forint
+  "huf",
+  // Indonesian Rupiah
+  "idr",
+  // Israeli New Shekel
+  "ils",
+  // Indian Rupee
+  "inr",
+  // Japanese Yen
+  "jpy",
+  // South Korean Won
+  "krw",
+  // Kuwaiti Dinar
+  "kwd",
+  // Sri Lankan Rupee
+  "lkr",
+  // Burmese Kyat
+  "mmk",
+  // Mexican Peso
+  "mxn",
+  // Malaysian Ringgit
+  "myr",
+  // Nigerian Naira
+  "ngn",
+  // Norwegian Krone
+  "nok",
+  // New Zealand Dollar
+  "nzd",
+  // Philippine Peso
+  "php",
+  // Pakistani Rupee
+  "pkr",
+  // Polish Zloty
+  "pln",
+  // Russian Ruble
+  "rub",
+  // Saudi Riyal
+  "sar",
+  // Swedish Krona
+  "sek",
+  // Singapore Dollar
+  "sgd",
+  // Thai Baht
+  "thb",
+  // Turkish Lira
+  "try",
+  // New Taiwan Dollar
+  "twd",
+  // Ukrainian hryvnia
+  "uah",
+  // Venezuelan bolívar fuerte
+  "vef",
+  // Vietnamese đồng
+  "vnd",
+  // South African Rand
+  "zar",
+  // IMF Special Drawing Rights
+  "xdr",
+  // Silver - Troy Ounce
+  "xag",
+  // Gold - Troy Ounce
+  "xau",
+  // Bits
+  "bits",
+  // Satoshi
+  "sats"
+];
+var SUPPORTED_CHAIN_IDS = [
+  // Ethereum Mainnet
+  "0x1",
+  // OP Mainnet
+  "0xa",
+  // Cronos Mainnet
+  "0x19",
+  // BNB Smart Chain Mainnet
+  "0x38",
+  // Syscoin Mainnet
+  "0x39",
+  // OKXChain Mainnet
+  "0x42",
+  // Hoo Smart Chain
+  "0x46",
+  // Meter Mainnet
+  "0x52",
+  // TomoChain
+  "0x58",
+  // Gnosis
+  "0x64",
+  // Velas EVM Mainnet
+  "0x6a",
+  // Fuse Mainnet
+  "0x7a",
+  // Huobi ECO Chain Mainnet
+  "0x80",
+  // Polygon Mainnet
+  "0x89",
+  // Fantom Opera
+  "0xfa",
+  // Boba Network
+  "0x120",
+  // KCC Mainnet
+  "0x141",
+  // zkSync Era Mainnet
+  "0x144",
+  // Theta Mainnet
+  "0x169",
+  // Metis Andromeda Mainnet
+  "0x440",
+  // Moonbeam
+  "0x504",
+  // Moonriver
+  "0x505",
+  // Base
+  "0x2105",
+  // Shiden
+  "0x150",
+  // Smart Bitcoin Cash
+  "0x2710",
+  // Arbitrum One
+  "0xa4b1",
+  // Celo Mainnet
+  "0xa4ec",
+  // Oasis Emerald
+  "0xa516",
+  // Avalanche C-Chain
+  "0xa86a",
+  // Polis Mainnet
+  "0x518af",
+  // Aurora Mainnet
+  "0x4e454152",
+  // Harmony Mainnet Shard 0
+  "0x63564c40",
+  // Linea Mainnet
+  "0xe708"
+];
+var BASE_URL = "https://price-api.metafi.codefi.network/v2";
+var DEFAULT_TOKEN_PRICE_RETRIES = 3;
+var DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES = (1 + DEFAULT_TOKEN_PRICE_RETRIES) * 3;
+var DEFAULT_DEGRADED_THRESHOLD = 5e3;
+var _tokenPricePolicy;
+var CodefiTokenPricesServiceV2 = class {
+  /**
+   * Construct a Codefi Token Price Service.
+   *
+   * @param options - Constructor options
+   * @param options.degradedThreshold - The threshold between "normal" and "degrated" service,
+   * in milliseconds.
+   * @param options.retries - Number of retry attempts for each token price update.
+   * @param options.maximumConsecutiveFailures - The maximum number of consecutive failures
+   * allowed before breaking the circuit and pausing further updates.
+   * @param options.onBreak - An event handler for when the circuit breaks, useful for capturing
+   * metrics about network failures.
+   * @param options.onDegraded - An event handler for when the circuit remains closed, but requests
+   * are failing or resolving too slowly (i.e. resolving more slowly than the `degradedThreshold).
+   * @param options.circuitBreakDuration - The amount of time to wait when the circuit breaks
+   * from too many consecutive failures.
+   */
+  constructor({
+    degradedThreshold = DEFAULT_DEGRADED_THRESHOLD,
+    retries = DEFAULT_TOKEN_PRICE_RETRIES,
+    maximumConsecutiveFailures = DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES,
+    onBreak,
+    onDegraded,
+    circuitBreakDuration = 30 * 60 * 1e3
+  } = {}) {
+    __privateAdd(this, _tokenPricePolicy, void 0);
+    const retryPolicy = retry(handleAll, {
+      maxAttempts: retries,
+      backoff: new ExponentialBackoff()
+    });
+    const circuitBreakerPolicy = circuitBreaker(handleAll, {
+      halfOpenAfter: circuitBreakDuration,
+      breaker: new ConsecutiveBreaker(maximumConsecutiveFailures)
+    });
+    if (onBreak) {
+      circuitBreakerPolicy.onBreak(onBreak);
+    }
+    if (onDegraded) {
+      retryPolicy.onGiveUp(() => {
+        if (circuitBreakerPolicy.state === CircuitState.Closed) {
+          onDegraded();
+        }
+      });
+      retryPolicy.onSuccess(({ duration }) => {
+        if (circuitBreakerPolicy.state === CircuitState.Closed && duration > degradedThreshold) {
+          onDegraded();
+        }
+      });
+    }
+    __privateSet(this, _tokenPricePolicy, wrap(retryPolicy, circuitBreakerPolicy));
+  }
+  /**
+   * Retrieves prices in the given currency for the tokens identified by the
+   * given addresses which are expected to live on the given chain.
+   *
+   * @param args - The arguments to function.
+   * @param args.chainId - An EIP-155 chain ID.
+   * @param args.tokenAddresses - Addresses for tokens that live on the chain.
+   * @param args.currency - The desired currency of the token prices.
+   * @returns The prices for the requested tokens.
+   */
+  async fetchTokenPrices({
+    chainId,
+    tokenAddresses,
+    currency
+  }) {
+    const chainIdAsNumber = hexToNumber(chainId);
+    const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
+    const url = new URL(`${BASE_URL}/chains/${chainIdAsNumber}/spot-prices`);
+    url.searchParams.append(
+      "tokenAddresses",
+      [ZERO_ADDRESS, ...tokenAddresses].join(",")
+    );
+    url.searchParams.append("vsCurrency", currency);
+    url.searchParams.append("includeMarketData", "true");
+    const pricesByCurrencyByTokenAddress = await __privateGet(this, _tokenPricePolicy).execute(
+      () => handleFetch(url, { headers: { "Cache-Control": "no-cache" } })
+    );
+    return [ZERO_ADDRESS, ...tokenAddresses].reduce(
+      (obj, tokenAddress) => {
+        const lowercasedTokenAddress = tokenAddress.toLowerCase();
+        const tokenData = pricesByCurrencyByTokenAddress[lowercasedTokenAddress] || {};
+        const {
+          price,
+          pricePercentChange1d,
+          priceChange1d,
+          allTimeHigh,
+          allTimeLow,
+          circulatingSupply,
+          dilutedMarketCap,
+          high1d,
+          marketCap,
+          totalVolume,
+          low1d,
+          marketCapPercentChange1d,
+          pricePercentChange1h,
+          pricePercentChange7d,
+          pricePercentChange14d,
+          pricePercentChange30d,
+          pricePercentChange200d,
+          pricePercentChange1y
+        } = tokenData;
+        const tokenPrice = {
+          tokenAddress,
+          value: price,
+          currency,
+          pricePercentChange1d,
+          priceChange1d,
+          allTimeHigh,
+          allTimeLow,
+          circulatingSupply,
+          dilutedMarketCap,
+          high1d,
+          marketCap,
+          totalVolume,
+          low1d,
+          marketCapPercentChange1d,
+          pricePercentChange1h,
+          pricePercentChange7d,
+          pricePercentChange14d,
+          pricePercentChange30d,
+          pricePercentChange200d,
+          pricePercentChange1y
+        };
+        return {
+          ...obj,
+          ...tokenPrice.value !== void 0 ? { [tokenAddress]: tokenPrice } : {}
+        };
+      },
+      {}
+    );
+  }
+  /**
+   * Type guard for whether the API can return token prices for the given chain
+   * ID.
+   *
+   * @param chainId - The chain ID to check.
+   * @returns True if the API supports the chain ID, false otherwise.
+   */
+  validateChainIdSupported(chainId) {
+    const supportedChainIds = SUPPORTED_CHAIN_IDS;
+    return typeof chainId === "string" && supportedChainIds.includes(chainId);
+  }
+  /**
+   * Type guard for whether the API can return token prices in the given
+   * currency.
+   *
+   * @param currency - The currency to check. If a string, can be either
+   * lowercase or uppercase.
+   * @returns True if the API supports the currency, false otherwise.
+   */
+  validateCurrencySupported(currency) {
+    const supportedCurrencies = SUPPORTED_CURRENCIES;
+    return typeof currency === "string" && supportedCurrencies.includes(currency.toLowerCase());
+  }
+};
+_tokenPricePolicy = new WeakMap();
+
+export {
+  SUPPORTED_CURRENCIES,
+  SUPPORTED_CHAIN_IDS,
+  CodefiTokenPricesServiceV2
+};
+//# sourceMappingURL=chunk-7RV5HGC4.mjs.map
\ No newline at end of file
diff --git a/dist/chunk-7RV5HGC4.mjs.map b/dist/chunk-7RV5HGC4.mjs.map
new file mode 100644
index 0000000000000000000000000000000000000000..b727be741085e9d6a05a4f65518422153491415d
--- /dev/null
+++ b/dist/chunk-7RV5HGC4.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/token-prices-service/codefi-v2.ts"],"sourcesContent":["import { handleFetch } from '@metamask/controller-utils';\nimport type { Hex } from '@metamask/utils';\nimport { hexToNumber } from '@metamask/utils';\nimport {\n  circuitBreaker,\n  ConsecutiveBreaker,\n  ExponentialBackoff,\n  handleAll,\n  type IPolicy,\n  retry,\n  wrap,\n  CircuitState,\n} from 'cockatiel';\n\nimport type {\n  AbstractTokenPricesService,\n  TokenPrice,\n  TokenPricesByTokenAddress,\n} from './abstract-token-prices-service';\n\n/**\n * The list of currencies that can be supplied as the `vsCurrency` parameter to\n * the `/spot-prices` endpoint, in lowercase form.\n */\nexport const SUPPORTED_CURRENCIES = [\n  // Bitcoin\n  'btc',\n  // Ether\n  'eth',\n  // Litecoin\n  'ltc',\n  // Bitcoin Cash\n  'bch',\n  // Binance Coin\n  'bnb',\n  // EOS\n  'eos',\n  // XRP\n  'xrp',\n  // Lumens\n  'xlm',\n  // Chainlink\n  'link',\n  // Polkadot\n  'dot',\n  // Yearn.finance\n  'yfi',\n  // US Dollar\n  'usd',\n  // United Arab Emirates Dirham\n  'aed',\n  // Argentine Peso\n  'ars',\n  // Australian Dollar\n  'aud',\n  // Bangladeshi Taka\n  'bdt',\n  // Bahraini Dinar\n  'bhd',\n  // Bermudian Dollar\n  'bmd',\n  // Brazil Real\n  'brl',\n  // Canadian Dollar\n  'cad',\n  // Swiss Franc\n  'chf',\n  // Chilean Peso\n  'clp',\n  // Chinese Yuan\n  'cny',\n  // Czech Koruna\n  'czk',\n  // Danish Krone\n  'dkk',\n  // Euro\n  'eur',\n  // British Pound Sterling\n  'gbp',\n  // Hong Kong Dollar\n  'hkd',\n  // Hungarian Forint\n  'huf',\n  // Indonesian Rupiah\n  'idr',\n  // Israeli New Shekel\n  'ils',\n  // Indian Rupee\n  'inr',\n  // Japanese Yen\n  'jpy',\n  // South Korean Won\n  'krw',\n  // Kuwaiti Dinar\n  'kwd',\n  // Sri Lankan Rupee\n  'lkr',\n  // Burmese Kyat\n  'mmk',\n  // Mexican Peso\n  'mxn',\n  // Malaysian Ringgit\n  'myr',\n  // Nigerian Naira\n  'ngn',\n  // Norwegian Krone\n  'nok',\n  // New Zealand Dollar\n  'nzd',\n  // Philippine Peso\n  'php',\n  // Pakistani Rupee\n  'pkr',\n  // Polish Zloty\n  'pln',\n  // Russian Ruble\n  'rub',\n  // Saudi Riyal\n  'sar',\n  // Swedish Krona\n  'sek',\n  // Singapore Dollar\n  'sgd',\n  // Thai Baht\n  'thb',\n  // Turkish Lira\n  'try',\n  // New Taiwan Dollar\n  'twd',\n  // Ukrainian hryvnia\n  'uah',\n  // Venezuelan bolívar fuerte\n  'vef',\n  // Vietnamese đồng\n  'vnd',\n  // South African Rand\n  'zar',\n  // IMF Special Drawing Rights\n  'xdr',\n  // Silver - Troy Ounce\n  'xag',\n  // Gold - Troy Ounce\n  'xau',\n  // Bits\n  'bits',\n  // Satoshi\n  'sats',\n] as const;\n\n/**\n * A currency that can be supplied as the `vsCurrency` parameter to\n * the `/spot-prices` endpoint. Covers both uppercase and lowercase versions.\n */\ntype SupportedCurrency =\n  | (typeof SUPPORTED_CURRENCIES)[number]\n  | Uppercase<(typeof SUPPORTED_CURRENCIES)[number]>;\n\n/**\n * The list of chain IDs that can be supplied in the URL for the `/spot-prices`\n * endpoint, but in hexadecimal form (for consistency with how we represent\n * chain IDs in other places).\n * @see Used by {@link CodefiTokenPricesServiceV2} to validate that a given chain ID is supported by V2 of the Codefi Price API.\n */\nexport const SUPPORTED_CHAIN_IDS = [\n  // Ethereum Mainnet\n  '0x1',\n  // OP Mainnet\n  '0xa',\n  // Cronos Mainnet\n  '0x19',\n  // BNB Smart Chain Mainnet\n  '0x38',\n  // Syscoin Mainnet\n  '0x39',\n  // OKXChain Mainnet\n  '0x42',\n  // Hoo Smart Chain\n  '0x46',\n  // Meter Mainnet\n  '0x52',\n  // TomoChain\n  '0x58',\n  // Gnosis\n  '0x64',\n  // Velas EVM Mainnet\n  '0x6a',\n  // Fuse Mainnet\n  '0x7a',\n  // Huobi ECO Chain Mainnet\n  '0x80',\n  // Polygon Mainnet\n  '0x89',\n  // Fantom Opera\n  '0xfa',\n  // Boba Network\n  '0x120',\n  // KCC Mainnet\n  '0x141',\n  // zkSync Era Mainnet\n  '0x144',\n  // Theta Mainnet\n  '0x169',\n  // Metis Andromeda Mainnet\n  '0x440',\n  // Moonbeam\n  '0x504',\n  // Moonriver\n  '0x505',\n  // Base\n  '0x2105',\n  // Shiden\n  '0x150',\n  // Smart Bitcoin Cash\n  '0x2710',\n  // Arbitrum One\n  '0xa4b1',\n  // Celo Mainnet\n  '0xa4ec',\n  // Oasis Emerald\n  '0xa516',\n  // Avalanche C-Chain\n  '0xa86a',\n  // Polis Mainnet\n  '0x518af',\n  // Aurora Mainnet\n  '0x4e454152',\n  // Harmony Mainnet Shard 0\n  '0x63564c40',\n  // Linea Mainnet\n  '0xe708',\n] as const;\n\n/**\n * A chain ID that can be supplied in the URL for the `/spot-prices` endpoint,\n * but in hexadecimal form (for consistency with how we represent chain IDs in\n * other places).\n */\ntype SupportedChainId = (typeof SUPPORTED_CHAIN_IDS)[number];\n\n/**\n * All requests to V2 of the Price API start with this.\n */\nconst BASE_URL = 'https://price-api.metafi.codefi.network/v2';\n\nconst DEFAULT_TOKEN_PRICE_RETRIES = 3;\n// Each update attempt will result (1 + retries) calls if the server is down\nconst DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES =\n  (1 + DEFAULT_TOKEN_PRICE_RETRIES) * 3;\n\nconst DEFAULT_DEGRADED_THRESHOLD = 5_000;\n\ntype CryptoData = {\n  allTimeHigh: number;\n  allTimeLow: number;\n  circulatingSupply: number;\n  dilutedMarketCap: number;\n  high1d: number;\n  low1d: number;\n  marketCap: number;\n  marketCapPercentChange1d: number;\n  price: number;\n  priceChange1d: number;\n  pricePercentChange1d: number;\n  pricePercentChange1h: number;\n  pricePercentChange1y: number;\n  pricePercentChange7d: number;\n  pricePercentChange14d: number;\n  pricePercentChange30d: number;\n  pricePercentChange200d: number;\n  totalVolume: number;\n};\n\ntype AddressCryptoDataMap = { [address: Hex]: CryptoData };\n\n/**\n * This version of the token prices service uses V2 of the Codefi Price API to\n * fetch token prices.\n */\nexport class CodefiTokenPricesServiceV2\n  implements\n    AbstractTokenPricesService<SupportedChainId, Hex, SupportedCurrency>\n{\n  #tokenPricePolicy: IPolicy;\n\n  /**\n   * Construct a Codefi Token Price Service.\n   *\n   * @param options - Constructor options\n   * @param options.degradedThreshold - The threshold between \"normal\" and \"degrated\" service,\n   * in milliseconds.\n   * @param options.retries - Number of retry attempts for each token price update.\n   * @param options.maximumConsecutiveFailures - The maximum number of consecutive failures\n   * allowed before breaking the circuit and pausing further updates.\n   * @param options.onBreak - An event handler for when the circuit breaks, useful for capturing\n   * metrics about network failures.\n   * @param options.onDegraded - An event handler for when the circuit remains closed, but requests\n   * are failing or resolving too slowly (i.e. resolving more slowly than the `degradedThreshold).\n   * @param options.circuitBreakDuration - The amount of time to wait when the circuit breaks\n   * from too many consecutive failures.\n   */\n  constructor({\n    degradedThreshold = DEFAULT_DEGRADED_THRESHOLD,\n    retries = DEFAULT_TOKEN_PRICE_RETRIES,\n    maximumConsecutiveFailures = DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES,\n    onBreak,\n    onDegraded,\n    circuitBreakDuration = 30 * 60 * 1000,\n  }: {\n    degradedThreshold?: number;\n    retries?: number;\n    maximumConsecutiveFailures?: number;\n    onBreak?: () => void;\n    onDegraded?: () => void;\n    circuitBreakDuration?: number;\n  } = {}) {\n    // Construct a policy that will retry each update, and halt further updates\n    // for a certain period after too many consecutive failures.\n    const retryPolicy = retry(handleAll, {\n      maxAttempts: retries,\n      backoff: new ExponentialBackoff(),\n    });\n    const circuitBreakerPolicy = circuitBreaker(handleAll, {\n      halfOpenAfter: circuitBreakDuration,\n      breaker: new ConsecutiveBreaker(maximumConsecutiveFailures),\n    });\n    if (onBreak) {\n      circuitBreakerPolicy.onBreak(onBreak);\n    }\n    if (onDegraded) {\n      retryPolicy.onGiveUp(() => {\n        if (circuitBreakerPolicy.state === CircuitState.Closed) {\n          onDegraded();\n        }\n      });\n      retryPolicy.onSuccess(({ duration }) => {\n        if (\n          circuitBreakerPolicy.state === CircuitState.Closed &&\n          duration > degradedThreshold\n        ) {\n          onDegraded();\n        }\n      });\n    }\n    this.#tokenPricePolicy = wrap(retryPolicy, circuitBreakerPolicy);\n  }\n\n  /**\n   * Retrieves prices in the given currency for the tokens identified by the\n   * given addresses which are expected to live on the given chain.\n   *\n   * @param args - The arguments to function.\n   * @param args.chainId - An EIP-155 chain ID.\n   * @param args.tokenAddresses - Addresses for tokens that live on the chain.\n   * @param args.currency - The desired currency of the token prices.\n   * @returns The prices for the requested tokens.\n   */\n  async fetchTokenPrices({\n    chainId,\n    tokenAddresses,\n    currency,\n  }: {\n    chainId: SupportedChainId;\n    tokenAddresses: Hex[];\n    currency: SupportedCurrency;\n  }): Promise<Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>> {\n    const chainIdAsNumber = hexToNumber(chainId);\n    const ZERO_ADDRESS: `0x${string}` =\n      '0x0000000000000000000000000000000000000000';\n\n    const url = new URL(`${BASE_URL}/chains/${chainIdAsNumber}/spot-prices`);\n    url.searchParams.append(\n      'tokenAddresses',\n      [ZERO_ADDRESS, ...tokenAddresses].join(','),\n    );\n    url.searchParams.append('vsCurrency', currency);\n    url.searchParams.append('includeMarketData', 'true');\n\n    const pricesByCurrencyByTokenAddress: AddressCryptoDataMap =\n      await this.#tokenPricePolicy.execute(() =>\n        handleFetch(url, { headers: { 'Cache-Control': 'no-cache' } }),\n      );\n\n    return [ZERO_ADDRESS, ...tokenAddresses].reduce(\n      (\n        obj: Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>,\n        tokenAddress,\n      ) => {\n        // The Price API lowercases both currency and token addresses, so we have\n        // to keep track of them and make sure we return the original versions.\n        const lowercasedTokenAddress =\n          tokenAddress.toLowerCase() as Lowercase<Hex>;\n\n        const tokenData =\n          pricesByCurrencyByTokenAddress[lowercasedTokenAddress] || {};\n\n        const {\n          price,\n          pricePercentChange1d,\n          priceChange1d,\n          allTimeHigh,\n          allTimeLow,\n          circulatingSupply,\n          dilutedMarketCap,\n          high1d,\n          marketCap,\n          totalVolume,\n          low1d,\n          marketCapPercentChange1d,\n          pricePercentChange1h,\n          pricePercentChange7d,\n          pricePercentChange14d,\n          pricePercentChange30d,\n          pricePercentChange200d,\n          pricePercentChange1y,\n        } = tokenData;\n\n        const tokenPrice: TokenPrice<Hex, SupportedCurrency> = {\n          tokenAddress,\n          value: price,\n          currency,\n          pricePercentChange1d,\n          priceChange1d,\n          allTimeHigh,\n          allTimeLow,\n          circulatingSupply,\n          dilutedMarketCap,\n          high1d,\n          marketCap,\n          totalVolume,\n          low1d,\n          marketCapPercentChange1d,\n          pricePercentChange1h,\n          pricePercentChange7d,\n          pricePercentChange14d,\n          pricePercentChange30d,\n          pricePercentChange200d,\n          pricePercentChange1y,\n        };\n\n        return {\n          ...obj,\n          ...(tokenPrice.value !== undefined\n            ? { [tokenAddress]: tokenPrice }\n            : {}),\n        };\n      },\n      {},\n    ) as Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>;\n  }\n\n  /**\n   * Type guard for whether the API can return token prices for the given chain\n   * ID.\n   *\n   * @param chainId - The chain ID to check.\n   * @returns True if the API supports the chain ID, false otherwise.\n   */\n  validateChainIdSupported(chainId: unknown): chainId is SupportedChainId {\n    const supportedChainIds: readonly string[] = SUPPORTED_CHAIN_IDS;\n    return typeof chainId === 'string' && supportedChainIds.includes(chainId);\n  }\n\n  /**\n   * Type guard for whether the API can return token prices in the given\n   * currency.\n   *\n   * @param currency - The currency to check. If a string, can be either\n   * lowercase or uppercase.\n   * @returns True if the API supports the currency, false otherwise.\n   */\n  validateCurrencySupported(currency: unknown): currency is SupportedCurrency {\n    const supportedCurrencies: readonly string[] = SUPPORTED_CURRENCIES;\n    return (\n      typeof currency === 'string' &&\n      supportedCurrencies.includes(currency.toLowerCase())\n    );\n  }\n}\n"],"mappings":"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","names":[]}
\ No newline at end of file
diff --git a/dist/chunk-AVPUXAZY.js b/dist/chunk-AVPUXAZY.js
new file mode 100644
index 0000000000000000000000000000000000000000..10479e5ec15669a304f1e88e177d4c66984234fe
--- /dev/null
+++ b/dist/chunk-AVPUXAZY.js
@@ -0,0 +1,704 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+var _chunk3ZHN4GFTjs = require('./chunk-3ZHN4GFT.js');
+
+
+var _chunkBO2WZDUMjs = require('./chunk-BO2WZDUM.js');
+
+
+
+var _chunkOKEA7NPVjs = require('./chunk-OKEA7NPV.js');
+
+
+
+var _chunkLS6R3HQLjs = require('./chunk-LS6R3HQL.js');
+
+// src/TokensController.ts
+var _contracts = require('@ethersproject/contracts');
+var _providers = require('@ethersproject/providers');
+var _basecontroller = require('@metamask/base-controller');
+var _contractmetadata = require('@metamask/contract-metadata'); var _contractmetadata2 = _interopRequireDefault(_contractmetadata);
+
+
+
+
+
+
+
+
+
+
+var _controllerutils = require('@metamask/controller-utils');
+var _metamaskethabis = require('@metamask/metamask-eth-abis');
+var _rpcerrors = require('@metamask/rpc-errors');
+var _asyncmutex = require('async-mutex');
+var _events = require('events');
+var _uuid = require('uuid');
+var controllerName = "TokensController";
+var getDefaultTokensState = () => {
+  return {
+    tokens: [],
+    ignoredTokens: [],
+    detectedTokens: [],
+    allTokens: {},
+    allIgnoredTokens: {},
+    allDetectedTokens: {}
+  };
+};
+var TokensController = class extends _basecontroller.BaseControllerV1 {
+  /**
+   * Creates a TokensController instance.
+   *
+   * @param options - The controller options.
+   * @param options.chainId - The chain ID of the current network.
+   * @param options.config - Initial options used to configure this controller.
+   * @param options.state - Initial state to set on this controller.
+   * @param options.messenger - The controller messenger.
+   */
+  constructor({
+    chainId: initialChainId,
+    config,
+    state,
+    messenger
+  }) {
+    super(config, state);
+    this.mutex = new (0, _asyncmutex.Mutex)();
+    /**
+     * EventEmitter instance used to listen to specific EIP747 events
+     */
+    this.hub = new (0, _events.EventEmitter)();
+    /**
+     * Name of this controller used during composition
+     */
+    this.name = "TokensController";
+    this.defaultConfig = {
+      selectedAddress: "",
+      chainId: initialChainId,
+      provider: void 0,
+      ...config
+    };
+    this.defaultState = {
+      ...getDefaultTokensState(),
+      ...state
+    };
+    this.initialize();
+    this.abortController = new AbortController();
+    this.messagingSystem = messenger;
+    this.messagingSystem.registerActionHandler(
+      `${controllerName}:addDetectedTokens`,
+      this.addDetectedTokens.bind(this)
+    );
+    this.messagingSystem.subscribe(
+      "PreferencesController:stateChange",
+      ({ selectedAddress }) => {
+        const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
+        const { chainId } = this.config;
+        this.configure({ selectedAddress });
+        this.update({
+          tokens: allTokens[chainId]?.[selectedAddress] ?? [],
+          ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] ?? [],
+          detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] ?? []
+        });
+      }
+    );
+    this.messagingSystem.subscribe(
+      "NetworkController:networkDidChange",
+      ({ providerConfig }) => {
+        const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
+        const { selectedAddress } = this.config;
+        const { chainId } = providerConfig;
+        this.abortController.abort();
+        this.abortController = new AbortController();
+        this.configure({ chainId });
+        this.update({
+          tokens: allTokens[chainId]?.[selectedAddress] || [],
+          ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] || [],
+          detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] || []
+        });
+      }
+    );
+    this.messagingSystem.subscribe(
+      "TokenListController:stateChange",
+      ({ tokenList }) => {
+        const { tokens } = this.state;
+        if (tokens.length && !tokens[0].name) {
+          this.updateTokensAttribute(tokenList, "name");
+        }
+      }
+    );
+  }
+  /**
+   * Fetch metadata for a token.
+   *
+   * @param tokenAddress - The address of the token.
+   * @returns The token metadata.
+   */
+  async fetchTokenMetadata(tokenAddress) {
+    try {
+      const token = await _chunkOKEA7NPVjs.fetchTokenMetadata.call(void 0, 
+        this.config.chainId,
+        tokenAddress,
+        this.abortController.signal
+      );
+      return token;
+    } catch (error) {
+      if (error instanceof Error && error.message.includes(_chunkOKEA7NPVjs.TOKEN_METADATA_NO_SUPPORT_ERROR)) {
+        return void 0;
+      }
+      throw error;
+    }
+  }
+  /**
+   * Adds a token to the stored token list.
+   *
+   * @param options - The method argument object.
+   * @param options.address - Hex address of the token contract.
+   * @param options.symbol - Symbol of the token.
+   * @param options.decimals - Number of decimals the token uses.
+   * @param options.name - Name of the token.
+   * @param options.image - Image of the token.
+   * @param options.interactingAddress - The address of the account to add a token to.
+   * @param options.networkClientId - Network Client ID.
+   * @returns Current token list.
+   */
+  async addToken({
+    address,
+    symbol,
+    decimals,
+    name,
+    image,
+    interactingAddress,
+    networkClientId
+  }) {
+    const { chainId, selectedAddress } = this.config;
+    const releaseLock = await this.mutex.acquire();
+    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
+    let currentChainId = chainId;
+    if (networkClientId) {
+      currentChainId = this.messagingSystem.call(
+        "NetworkController:getNetworkClientById",
+        networkClientId
+      ).configuration.chainId;
+    }
+    const accountAddress = interactingAddress || selectedAddress;
+    const isInteractingWithWalletAccount = accountAddress === selectedAddress;
+    try {
+      address = _controllerutils.toChecksumHexAddress.call(void 0, address);
+      const tokens = allTokens[currentChainId]?.[accountAddress] || [];
+      const ignoredTokens = allIgnoredTokens[currentChainId]?.[accountAddress] || [];
+      const detectedTokens = allDetectedTokens[currentChainId]?.[accountAddress] || [];
+      const newTokens = [...tokens];
+      const [isERC721, tokenMetadata] = await Promise.all([
+        this._detectIsERC721(address, networkClientId),
+        // TODO parameterize the token metadata fetch by networkClientId
+        this.fetchTokenMetadata(address)
+      ]);
+      if (!networkClientId && currentChainId !== this.config.chainId) {
+        throw new Error(
+          "TokensController Error: Switched networks while adding token"
+        );
+      }
+      const newEntry = {
+        address,
+        symbol,
+        decimals,
+        image: image || _chunkLS6R3HQLjs.formatIconUrlWithProxy.call(void 0, {
+          chainId: currentChainId,
+          tokenAddress: address
+        }),
+        isERC721,
+        aggregators: _chunkLS6R3HQLjs.formatAggregatorNames.call(void 0, tokenMetadata?.aggregators || []),
+        name
+      };
+      const previousIndex = newTokens.findIndex(
+        (token) => token.address.toLowerCase() === address.toLowerCase()
+      );
+      if (previousIndex !== -1) {
+        newTokens[previousIndex] = newEntry;
+      } else {
+        newTokens.push(newEntry);
+      }
+      const newIgnoredTokens = ignoredTokens.filter(
+        (tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase()
+      );
+      const newDetectedTokens = detectedTokens.filter(
+        (token) => token.address.toLowerCase() !== address.toLowerCase()
+      );
+      const { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens } = this._getNewAllTokensState({
+        newTokens,
+        newIgnoredTokens,
+        newDetectedTokens,
+        interactingAddress: accountAddress,
+        interactingChainId: currentChainId
+      });
+      let newState = {
+        allTokens: newAllTokens,
+        allIgnoredTokens: newAllIgnoredTokens,
+        allDetectedTokens: newAllDetectedTokens
+      };
+      if (isInteractingWithWalletAccount) {
+        newState = {
+          ...newState,
+          tokens: newTokens,
+          ignoredTokens: newIgnoredTokens,
+          detectedTokens: newDetectedTokens
+        };
+      }
+      this.update(newState);
+      return newTokens;
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Add a batch of tokens.
+   *
+   * @param tokensToImport - Array of tokens to import.
+   * @param networkClientId - Optional network client ID used to determine interacting chain ID.
+   */
+  async addTokens(tokensToImport, networkClientId) {
+    const releaseLock = await this.mutex.acquire();
+    const { tokens, detectedTokens, ignoredTokens } = this.state;
+    const importedTokensMap = {};
+    const newTokensMap = tokens.reduce((output, current) => {
+      output[current.address] = current;
+      return output;
+    }, {});
+    try {
+      tokensToImport.forEach((tokenToAdd) => {
+        const { address, symbol, decimals, image, aggregators, name } = tokenToAdd;
+        const checksumAddress = _controllerutils.toChecksumHexAddress.call(void 0, address);
+        const formattedToken = {
+          address: checksumAddress,
+          symbol,
+          decimals,
+          image,
+          aggregators,
+          name
+        };
+        newTokensMap[address] = formattedToken;
+        importedTokensMap[address.toLowerCase()] = true;
+        return formattedToken;
+      });
+      const newTokens = Object.values(newTokensMap);
+      const newDetectedTokens = detectedTokens.filter(
+        (token) => !importedTokensMap[token.address.toLowerCase()]
+      );
+      const newIgnoredTokens = ignoredTokens.filter(
+        (tokenAddress) => !newTokensMap[tokenAddress.toLowerCase()]
+      );
+      let interactingChainId;
+      if (networkClientId) {
+        interactingChainId = this.messagingSystem.call(
+          "NetworkController:getNetworkClientById",
+          networkClientId
+        ).configuration.chainId;
+      }
+      const { newAllTokens, newAllDetectedTokens, newAllIgnoredTokens } = this._getNewAllTokensState({
+        newTokens,
+        newDetectedTokens,
+        newIgnoredTokens,
+        interactingChainId
+      });
+      this.update({
+        tokens: newTokens,
+        allTokens: newAllTokens,
+        detectedTokens: newDetectedTokens,
+        allDetectedTokens: newAllDetectedTokens,
+        ignoredTokens: newIgnoredTokens,
+        allIgnoredTokens: newAllIgnoredTokens
+      });
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Ignore a batch of tokens.
+   *
+   * @param tokenAddressesToIgnore - Array of token addresses to ignore.
+   */
+  ignoreTokens(tokenAddressesToIgnore) {
+    const { ignoredTokens, detectedTokens, tokens } = this.state;
+    const ignoredTokensMap = {};
+    let newIgnoredTokens = [...ignoredTokens];
+    const checksummedTokenAddresses = tokenAddressesToIgnore.map((address) => {
+      const checksumAddress = _controllerutils.toChecksumHexAddress.call(void 0, address);
+      ignoredTokensMap[address.toLowerCase()] = true;
+      return checksumAddress;
+    });
+    newIgnoredTokens = [...ignoredTokens, ...checksummedTokenAddresses];
+    const newDetectedTokens = detectedTokens.filter(
+      (token) => !ignoredTokensMap[token.address.toLowerCase()]
+    );
+    const newTokens = tokens.filter(
+      (token) => !ignoredTokensMap[token.address.toLowerCase()]
+    );
+    const { newAllIgnoredTokens, newAllDetectedTokens, newAllTokens } = this._getNewAllTokensState({
+      newIgnoredTokens,
+      newDetectedTokens,
+      newTokens
+    });
+    this.update({
+      ignoredTokens: newIgnoredTokens,
+      tokens: newTokens,
+      detectedTokens: newDetectedTokens,
+      allIgnoredTokens: newAllIgnoredTokens,
+      allDetectedTokens: newAllDetectedTokens,
+      allTokens: newAllTokens
+    });
+  }
+  /**
+   * Adds a batch of detected tokens to the stored token list.
+   *
+   * @param incomingDetectedTokens - Array of detected tokens to be added or updated.
+   * @param detectionDetails - An object containing the chain ID and address of the currently selected network on which the incomingDetectedTokens were detected.
+   * @param detectionDetails.selectedAddress - the account address on which the incomingDetectedTokens were detected.
+   * @param detectionDetails.chainId - the chainId on which the incomingDetectedTokens were detected.
+   */
+  async addDetectedTokens(incomingDetectedTokens, detectionDetails) {
+    const releaseLock = await this.mutex.acquire();
+    const chainId = detectionDetails?.chainId ?? this.config.chainId;
+    const accountAddress = detectionDetails?.selectedAddress ?? this.config.selectedAddress;
+    const { allTokens, allDetectedTokens, allIgnoredTokens } = this.state;
+    let newTokens = [...allTokens?.[chainId]?.[accountAddress] ?? []];
+    let newDetectedTokens = [
+      ...allDetectedTokens?.[chainId]?.[accountAddress] ?? []
+    ];
+    try {
+      incomingDetectedTokens.forEach((tokenToAdd) => {
+        const {
+          address,
+          symbol,
+          decimals,
+          image,
+          aggregators,
+          isERC721,
+          name
+        } = tokenToAdd;
+        const checksumAddress = _controllerutils.toChecksumHexAddress.call(void 0, address);
+        const newEntry = {
+          address: checksumAddress,
+          symbol,
+          decimals,
+          image,
+          isERC721,
+          aggregators,
+          name
+        };
+        const previousImportedIndex = newTokens.findIndex(
+          (token) => token.address.toLowerCase() === checksumAddress.toLowerCase()
+        );
+        if (previousImportedIndex !== -1) {
+          newTokens[previousImportedIndex] = newEntry;
+        } else {
+          const ignoredTokenIndex = allIgnoredTokens?.[chainId]?.[accountAddress]?.indexOf(address) ?? -1;
+          if (ignoredTokenIndex === -1) {
+            const previousDetectedIndex = newDetectedTokens.findIndex(
+              (token) => token.address.toLowerCase() === checksumAddress.toLowerCase()
+            );
+            if (previousDetectedIndex !== -1) {
+              newDetectedTokens[previousDetectedIndex] = newEntry;
+            } else {
+              newDetectedTokens.push(newEntry);
+            }
+          }
+        }
+      });
+      const { newAllTokens, newAllDetectedTokens } = this._getNewAllTokensState(
+        {
+          newTokens,
+          newDetectedTokens,
+          interactingAddress: accountAddress,
+          interactingChainId: chainId
+        }
+      );
+      const { chainId: currentChain, selectedAddress: currentAddress } = this.config;
+      newTokens = newAllTokens?.[currentChain]?.[currentAddress] || [];
+      newDetectedTokens = newAllDetectedTokens?.[currentChain]?.[currentAddress] || [];
+      this.update({
+        tokens: newTokens,
+        allTokens: newAllTokens,
+        detectedTokens: newDetectedTokens,
+        allDetectedTokens: newAllDetectedTokens
+      });
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Adds isERC721 field to token object. This is called when a user attempts to add tokens that
+   * were previously added which do not yet had isERC721 field.
+   *
+   * @param tokenAddress - The contract address of the token requiring the isERC721 field added.
+   * @returns The new token object with the added isERC721 field.
+   */
+  async updateTokenType(tokenAddress) {
+    const isERC721 = await this._detectIsERC721(tokenAddress);
+    const { tokens } = this.state;
+    const tokenIndex = tokens.findIndex((token) => {
+      return token.address.toLowerCase() === tokenAddress.toLowerCase();
+    });
+    tokens[tokenIndex].isERC721 = isERC721;
+    this.update({ tokens });
+    return tokens[tokenIndex];
+  }
+  /**
+   * This is a function that updates the tokens name for the tokens name if it is not defined.
+   *
+   * @param tokenList - Represents the fetched token list from service API
+   * @param tokenAttribute - Represents the token attribute that we want to update on the token list
+   */
+  updateTokensAttribute(tokenList, tokenAttribute) {
+    const { tokens } = this.state;
+    const newTokens = tokens.map((token) => {
+      const newToken = tokenList[token.address.toLowerCase()];
+      return !token[tokenAttribute] && newToken?.[tokenAttribute] ? { ...token, [tokenAttribute]: newToken[tokenAttribute] } : { ...token };
+    });
+    this.update({ tokens: newTokens });
+  }
+  /**
+   * Detects whether or not a token is ERC-721 compatible.
+   *
+   * @param tokenAddress - The token contract address.
+   * @param networkClientId - Optional network client ID to fetch contract info with.
+   * @returns A boolean indicating whether the token address passed in supports the EIP-721
+   * interface.
+   */
+  async _detectIsERC721(tokenAddress, networkClientId) {
+    const checksumAddress = _controllerutils.toChecksumHexAddress.call(void 0, tokenAddress);
+    if (_contractmetadata2.default[checksumAddress]?.erc721 === true) {
+      return Promise.resolve(true);
+    } else if (_contractmetadata2.default[checksumAddress]?.erc20 === true) {
+      return Promise.resolve(false);
+    }
+    const tokenContract = this._createEthersContract(
+      tokenAddress,
+      _metamaskethabis.abiERC721,
+      networkClientId
+    );
+    try {
+      return await tokenContract.supportsInterface(_controllerutils.ERC721_INTERFACE_ID);
+    } catch (error) {
+      return false;
+    }
+  }
+  _getProvider(networkClientId) {
+    return new (0, _providers.Web3Provider)(
+      // @ts-expect-error TODO: remove this annotation once the `Eip1193Provider` class is released
+      networkClientId ? this.messagingSystem.call(
+        "NetworkController:getNetworkClientById",
+        networkClientId
+      ).provider : this.config.provider
+    );
+  }
+  _createEthersContract(tokenAddress, abi, networkClientId) {
+    const web3provider = this._getProvider(networkClientId);
+    const tokenContract = new (0, _contracts.Contract)(tokenAddress, abi, web3provider);
+    return tokenContract;
+  }
+  _generateRandomId() {
+    return _uuid.v1.call(void 0, );
+  }
+  /**
+   * Adds a new suggestedAsset to the list of watched assets.
+   * Parameters will be validated according to the asset type being watched.
+   *
+   * @param options - The method options.
+   * @param options.asset - The asset to be watched. For now only ERC20 tokens are accepted.
+   * @param options.type - The asset type.
+   * @param options.interactingAddress - The address of the account that is requesting to watch the asset.
+   * @param options.networkClientId - Network Client ID.
+   * @returns A promise that resolves if the asset was watched successfully, and rejects otherwise.
+   */
+  async watchAsset({
+    asset,
+    type,
+    interactingAddress,
+    networkClientId
+  }) {
+    if (type !== _controllerutils.ERC20) {
+      throw new Error(`Asset of type ${type} not supported`);
+    }
+    if (!asset.address) {
+      throw _rpcerrors.rpcErrors.invalidParams("Address must be specified");
+    }
+    if (!_controllerutils.isValidHexAddress.call(void 0, asset.address)) {
+      throw _rpcerrors.rpcErrors.invalidParams(`Invalid address "${asset.address}"`);
+    }
+    if (await this._detectIsERC721(asset.address, networkClientId)) {
+      throw _rpcerrors.rpcErrors.invalidParams(
+        `Contract ${asset.address} must match type ${type}, but was detected as ${_controllerutils.ERC721}`
+      );
+    }
+    const provider = this._getProvider(networkClientId);
+    const isErc1155 = await _controllerutils.safelyExecute.call(void 0, 
+      () => new (0, _chunk3ZHN4GFTjs.ERC1155Standard)(provider).contractSupportsBase1155Interface(
+        asset.address
+      )
+    );
+    if (isErc1155) {
+      throw _rpcerrors.rpcErrors.invalidParams(
+        `Contract ${asset.address} must match type ${type}, but was detected as ${_controllerutils.ERC1155}`
+      );
+    }
+    const erc20 = new (0, _chunkBO2WZDUMjs.ERC20Standard)(provider);
+    const [contractName, contractSymbol, contractDecimals] = await Promise.all([
+      _controllerutils.safelyExecute.call(void 0, () => erc20.getTokenName(asset.address)),
+      _controllerutils.safelyExecute.call(void 0, () => erc20.getTokenSymbol(asset.address)),
+      _controllerutils.safelyExecute.call(void 0, async () => erc20.getTokenDecimals(asset.address))
+    ]);
+    asset.name = contractName;
+    if (!asset.symbol && !contractSymbol) {
+      throw _rpcerrors.rpcErrors.invalidParams(
+        "A symbol is required, but was not found in either the request or contract"
+      );
+    }
+    if (contractSymbol !== void 0 && asset.symbol !== void 0 && asset.symbol.toUpperCase() !== contractSymbol.toUpperCase()) {
+      throw _rpcerrors.rpcErrors.invalidParams(
+        `The symbol in the request (${asset.symbol}) does not match the symbol in the contract (${contractSymbol})`
+      );
+    }
+    asset.symbol = contractSymbol ?? asset.symbol;
+    if (typeof asset.symbol !== "string") {
+      throw _rpcerrors.rpcErrors.invalidParams(`Invalid symbol: not a string`);
+    }
+    if (asset.symbol.length > 11) {
+      throw _rpcerrors.rpcErrors.invalidParams(
+        `Invalid symbol "${asset.symbol}": longer than 11 characters`
+      );
+    }
+    if (asset.decimals === void 0 && contractDecimals === void 0) {
+      throw _rpcerrors.rpcErrors.invalidParams(
+        "Decimals are required, but were not found in either the request or contract"
+      );
+    }
+    if (contractDecimals !== void 0 && asset.decimals !== void 0 && String(asset.decimals) !== contractDecimals) {
+      throw _rpcerrors.rpcErrors.invalidParams(
+        `The decimals in the request (${asset.decimals}) do not match the decimals in the contract (${contractDecimals})`
+      );
+    }
+    const decimalsStr = contractDecimals ?? asset.decimals;
+    const decimalsNum = parseInt(decimalsStr, 10);
+    if (!Number.isInteger(decimalsNum) || decimalsNum > 36 || decimalsNum < 0) {
+      throw _rpcerrors.rpcErrors.invalidParams(
+        `Invalid decimals "${decimalsStr}": must be an integer 0 <= 36`
+      );
+    }
+    asset.decimals = decimalsNum;
+    const suggestedAssetMeta = {
+      asset,
+      id: this._generateRandomId(),
+      time: Date.now(),
+      type,
+      interactingAddress: interactingAddress || this.config.selectedAddress
+    };
+    await this._requestApproval(suggestedAssetMeta);
+    const { address, symbol, decimals, name, image } = asset;
+    await this.addToken({
+      address,
+      symbol,
+      decimals,
+      name,
+      image,
+      interactingAddress: suggestedAssetMeta.interactingAddress,
+      networkClientId
+    });
+  }
+  /**
+   * Takes a new tokens and ignoredTokens array for the current network/account combination
+   * and returns new allTokens and allIgnoredTokens state to update to.
+   *
+   * @param params - Object that holds token params.
+   * @param params.newTokens - The new tokens to set for the current network and selected account.
+   * @param params.newIgnoredTokens - The new ignored tokens to set for the current network and selected account.
+   * @param params.newDetectedTokens - The new detected tokens to set for the current network and selected account.
+   * @param params.interactingAddress - The account address to use to store the tokens.
+   * @param params.interactingChainId - The chainId to use to store the tokens.
+   * @returns The updated `allTokens` and `allIgnoredTokens` state.
+   */
+  _getNewAllTokensState(params) {
+    const {
+      newTokens,
+      newIgnoredTokens,
+      newDetectedTokens,
+      interactingAddress,
+      interactingChainId
+    } = params;
+    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
+    const { chainId, selectedAddress } = this.config;
+    const userAddressToAddTokens = interactingAddress ?? selectedAddress;
+    const chainIdToAddTokens = interactingChainId ?? chainId;
+    let newAllTokens = allTokens;
+    if (newTokens?.length || newTokens && allTokens && allTokens[chainIdToAddTokens] && allTokens[chainIdToAddTokens][userAddressToAddTokens]) {
+      const networkTokens = allTokens[chainIdToAddTokens];
+      const newNetworkTokens = {
+        ...networkTokens,
+        ...{ [userAddressToAddTokens]: newTokens }
+      };
+      newAllTokens = {
+        ...allTokens,
+        ...{ [chainIdToAddTokens]: newNetworkTokens }
+      };
+    }
+    let newAllIgnoredTokens = allIgnoredTokens;
+    if (newIgnoredTokens?.length || newIgnoredTokens && allIgnoredTokens && allIgnoredTokens[chainIdToAddTokens] && allIgnoredTokens[chainIdToAddTokens][userAddressToAddTokens]) {
+      const networkIgnoredTokens = allIgnoredTokens[chainIdToAddTokens];
+      const newIgnoredNetworkTokens = {
+        ...networkIgnoredTokens,
+        ...{ [userAddressToAddTokens]: newIgnoredTokens }
+      };
+      newAllIgnoredTokens = {
+        ...allIgnoredTokens,
+        ...{ [chainIdToAddTokens]: newIgnoredNetworkTokens }
+      };
+    }
+    let newAllDetectedTokens = allDetectedTokens;
+    if (newDetectedTokens?.length || newDetectedTokens && allDetectedTokens && allDetectedTokens[chainIdToAddTokens] && allDetectedTokens[chainIdToAddTokens][userAddressToAddTokens]) {
+      const networkDetectedTokens = allDetectedTokens[chainIdToAddTokens];
+      const newDetectedNetworkTokens = {
+        ...networkDetectedTokens,
+        ...{ [userAddressToAddTokens]: newDetectedTokens }
+      };
+      newAllDetectedTokens = {
+        ...allDetectedTokens,
+        ...{ [chainIdToAddTokens]: newDetectedNetworkTokens }
+      };
+    }
+    return { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens };
+  }
+  /**
+   * Removes all tokens from the ignored list.
+   */
+  clearIgnoredTokens() {
+    this.update({ ignoredTokens: [], allIgnoredTokens: {} });
+  }
+  async _requestApproval(suggestedAssetMeta) {
+    return this.messagingSystem.call(
+      "ApprovalController:addRequest",
+      {
+        id: suggestedAssetMeta.id,
+        origin: _controllerutils.ORIGIN_METAMASK,
+        type: _controllerutils.ApprovalType.WatchAsset,
+        requestData: {
+          id: suggestedAssetMeta.id,
+          interactingAddress: suggestedAssetMeta.interactingAddress,
+          asset: {
+            address: suggestedAssetMeta.asset.address,
+            decimals: suggestedAssetMeta.asset.decimals,
+            symbol: suggestedAssetMeta.asset.symbol,
+            image: suggestedAssetMeta.asset.image || null
+          }
+        }
+      },
+      true
+    );
+  }
+};
+var TokensController_default = TokensController;
+
+
+
+
+
+exports.getDefaultTokensState = getDefaultTokensState; exports.TokensController = TokensController; exports.TokensController_default = TokensController_default;
+//# sourceMappingURL=chunk-AVPUXAZY.js.map
\ No newline at end of file
diff --git a/dist/chunk-AVPUXAZY.js.map b/dist/chunk-AVPUXAZY.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..8316c2629b0a4fa06ba69744fc28040afa71b573
--- /dev/null
+++ b/dist/chunk-AVPUXAZY.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/TokensController.ts"],"names":[],"mappings":"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","sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport { Web3Provider } from '@ethersproject/providers';\nimport type { AddApprovalRequest } from '@metamask/approval-controller';\nimport type {\n  BaseConfig,\n  BaseState,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseControllerV1 } from '@metamask/base-controller';\nimport contractsMap from '@metamask/contract-metadata';\nimport {\n  toChecksumHexAddress,\n  ERC721_INTERFACE_ID,\n  ORIGIN_METAMASK,\n  ApprovalType,\n  ERC20,\n  ERC721,\n  ERC1155,\n  isValidHexAddress,\n  safelyExecute,\n} from '@metamask/controller-utils';\nimport { abiERC721 } from '@metamask/metamask-eth-abis';\nimport type {\n  NetworkClientId,\n  NetworkControllerGetNetworkClientByIdAction,\n  NetworkControllerNetworkDidChangeEvent,\n  Provider,\n} from '@metamask/network-controller';\nimport type { PreferencesControllerStateChangeEvent } from '@metamask/preferences-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { Hex } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport { EventEmitter } from 'events';\nimport type { Patch } from 'immer/dist/immer';\nimport { v1 as random } from 'uuid';\n\nimport { formatAggregatorNames, formatIconUrlWithProxy } from './assetsUtil';\nimport { ERC20Standard } from './Standards/ERC20Standard';\nimport { ERC1155Standard } from './Standards/NftStandards/ERC1155/ERC1155Standard';\nimport {\n  fetchTokenMetadata,\n  TOKEN_METADATA_NO_SUPPORT_ERROR,\n} from './token-service';\nimport type {\n  TokenListMap,\n  TokenListStateChange,\n  TokenListToken,\n} from './TokenListController';\nimport type { Token } from './TokenRatesController';\n\n/**\n * @type TokensConfig\n *\n * Tokens controller configuration\n * @property selectedAddress - Vault selected address\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface TokensConfig extends BaseConfig {\n  selectedAddress: string;\n  chainId: Hex;\n  provider: Provider | undefined;\n}\n\n/**\n * @type SuggestedAssetMeta\n *\n * Suggested asset by EIP747 meta data\n * @property id - Generated UUID associated with this suggested asset\n * @property time - Timestamp associated with this this suggested asset\n * @property type - Type type this suggested asset\n * @property asset - Asset suggested object\n * @property interactingAddress - Account address that requested watch asset\n */\ntype SuggestedAssetMeta = {\n  id: string;\n  time: number;\n  type: string;\n  asset: Token;\n  interactingAddress: string;\n};\n\n/**\n * @type TokensState\n *\n * Assets controller state\n * @property tokens - List of tokens associated with the active network and address pair\n * @property ignoredTokens - List of ignoredTokens associated with the active network and address pair\n * @property detectedTokens - List of detected tokens associated with the active network and address pair\n * @property allTokens - Object containing tokens by network and account\n * @property allIgnoredTokens - Object containing hidden/ignored tokens by network and account\n * @property allDetectedTokens - Object containing tokens detected with non-zero balances\n */\nexport type TokensState = {\n  tokens: Token[];\n  ignoredTokens: string[];\n  detectedTokens: Token[];\n  allTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  allIgnoredTokens: { [chainId: Hex]: { [key: string]: string[] } };\n  allDetectedTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n};\n\n/**\n * The name of the {@link TokensController}.\n */\nconst controllerName = 'TokensController';\n\nexport type TokensControllerActions =\n  | TokensControllerGetStateAction\n  | TokensControllerAddDetectedTokensAction;\n\n// TODO: Once `TokensController` is upgraded to V2, rewrite this type using the `ControllerGetStateAction` type, which constrains `TokensState` as `Record<string, Json>`.\nexport type TokensControllerGetStateAction = {\n  type: `${typeof controllerName}:getState`;\n  handler: () => TokensState;\n};\n\nexport type TokensControllerAddDetectedTokensAction = {\n  type: `${typeof controllerName}:addDetectedTokens`;\n  handler: TokensController['addDetectedTokens'];\n};\n\n/**\n * The external actions available to the {@link TokensController}.\n */\nexport type AllowedActions =\n  | AddApprovalRequest\n  | NetworkControllerGetNetworkClientByIdAction;\n\n// TODO: Once `TokensController` is upgraded to V2, rewrite this type using the `ControllerStateChangeEvent` type, which constrains `TokensState` as `Record<string, Json>`.\nexport type TokensControllerStateChangeEvent = {\n  type: `${typeof controllerName}:stateChange`;\n  payload: [TokensState, Patch[]];\n};\n\nexport type TokensControllerEvents = TokensControllerStateChangeEvent;\n\nexport type AllowedEvents =\n  | NetworkControllerNetworkDidChangeEvent\n  | PreferencesControllerStateChangeEvent\n  | TokenListStateChange;\n\n/**\n * The messenger of the {@link TokensController}.\n */\nexport type TokensControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  TokensControllerActions | AllowedActions,\n  TokensControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\nexport const getDefaultTokensState = (): TokensState => {\n  return {\n    tokens: [],\n    ignoredTokens: [],\n    detectedTokens: [],\n    allTokens: {},\n    allIgnoredTokens: {},\n    allDetectedTokens: {},\n  };\n};\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class TokensController extends BaseControllerV1<\n  TokensConfig,\n  TokensState & BaseState\n> {\n  private readonly mutex = new Mutex();\n\n  private abortController: AbortController;\n\n  private readonly messagingSystem: TokensControllerMessenger;\n\n  /**\n   * Fetch metadata for a token.\n   *\n   * @param tokenAddress - The address of the token.\n   * @returns The token metadata.\n   */\n  private async fetchTokenMetadata(\n    tokenAddress: string,\n  ): Promise<TokenListToken | undefined> {\n    try {\n      const token = await fetchTokenMetadata<TokenListToken>(\n        this.config.chainId,\n        tokenAddress,\n        this.abortController.signal,\n      );\n      return token;\n    } catch (error) {\n      if (\n        error instanceof Error &&\n        error.message.includes(TOKEN_METADATA_NO_SUPPORT_ERROR)\n      ) {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokensController';\n\n  /**\n   * Creates a TokensController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.config - Initial options used to configure this controller.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.messenger - The controller messenger.\n   */\n  constructor({\n    chainId: initialChainId,\n    config,\n    state,\n    messenger,\n  }: {\n    chainId: Hex;\n    config?: Partial<TokensConfig>;\n    state?: Partial<TokensState>;\n    messenger: TokensControllerMessenger;\n  }) {\n    super(config, state);\n\n    this.defaultConfig = {\n      selectedAddress: '',\n      chainId: initialChainId,\n      provider: undefined,\n      ...config,\n    };\n\n    this.defaultState = {\n      ...getDefaultTokensState(),\n      ...state,\n    };\n\n    this.initialize();\n    this.abortController = new AbortController();\n\n    this.messagingSystem = messenger;\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:addDetectedTokens` as const,\n      this.addDetectedTokens.bind(this),\n    );\n\n    this.messagingSystem.subscribe(\n      'PreferencesController:stateChange',\n      ({ selectedAddress }) => {\n        const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n        const { chainId } = this.config;\n        this.configure({ selectedAddress });\n        this.update({\n          tokens: allTokens[chainId]?.[selectedAddress] ?? [],\n          ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] ?? [],\n          detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] ?? [],\n        });\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'NetworkController:networkDidChange',\n      ({ providerConfig }) => {\n        const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n        const { selectedAddress } = this.config;\n        const { chainId } = providerConfig;\n        this.abortController.abort();\n        this.abortController = new AbortController();\n        this.configure({ chainId });\n        this.update({\n          tokens: allTokens[chainId]?.[selectedAddress] || [],\n          ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] || [],\n          detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] || [],\n        });\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'TokenListController:stateChange',\n      ({ tokenList }) => {\n        const { tokens } = this.state;\n        if (tokens.length && !tokens[0].name) {\n          this.updateTokensAttribute(tokenList, 'name');\n        }\n      },\n    );\n  }\n\n  /**\n   * Adds a token to the stored token list.\n   *\n   * @param options - The method argument object.\n   * @param options.address - Hex address of the token contract.\n   * @param options.symbol - Symbol of the token.\n   * @param options.decimals - Number of decimals the token uses.\n   * @param options.name - Name of the token.\n   * @param options.image - Image of the token.\n   * @param options.interactingAddress - The address of the account to add a token to.\n   * @param options.networkClientId - Network Client ID.\n   * @returns Current token list.\n   */\n  async addToken({\n    address,\n    symbol,\n    decimals,\n    name,\n    image,\n    interactingAddress,\n    networkClientId,\n  }: {\n    address: string;\n    symbol: string;\n    decimals: number;\n    name?: string;\n    image?: string;\n    interactingAddress?: string;\n    networkClientId?: NetworkClientId;\n  }): Promise<Token[]> {\n    const { chainId, selectedAddress } = this.config;\n    const releaseLock = await this.mutex.acquire();\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    let currentChainId = chainId;\n    if (networkClientId) {\n      currentChainId = this.messagingSystem.call(\n        'NetworkController:getNetworkClientById',\n        networkClientId,\n      ).configuration.chainId;\n    }\n\n    const accountAddress = interactingAddress || selectedAddress;\n    const isInteractingWithWalletAccount = accountAddress === selectedAddress;\n\n    try {\n      address = toChecksumHexAddress(address);\n      const tokens = allTokens[currentChainId]?.[accountAddress] || [];\n      const ignoredTokens =\n        allIgnoredTokens[currentChainId]?.[accountAddress] || [];\n      const detectedTokens =\n        allDetectedTokens[currentChainId]?.[accountAddress] || [];\n      const newTokens: Token[] = [...tokens];\n      const [isERC721, tokenMetadata] = await Promise.all([\n        this._detectIsERC721(address, networkClientId),\n        // TODO parameterize the token metadata fetch by networkClientId\n        this.fetchTokenMetadata(address),\n      ]);\n      // TODO remove this once this method is fully parameterized by networkClientId\n      if (!networkClientId && currentChainId !== this.config.chainId) {\n        throw new Error(\n          'TokensController Error: Switched networks while adding token',\n        );\n      }\n      const newEntry: Token = {\n        address,\n        symbol,\n        decimals,\n        image:\n          image ||\n          formatIconUrlWithProxy({\n            chainId: currentChainId,\n            tokenAddress: address,\n          }),\n        isERC721,\n        aggregators: formatAggregatorNames(tokenMetadata?.aggregators || []),\n        name,\n      };\n      const previousIndex = newTokens.findIndex(\n        (token) => token.address.toLowerCase() === address.toLowerCase(),\n      );\n      if (previousIndex !== -1) {\n        newTokens[previousIndex] = newEntry;\n      } else {\n        newTokens.push(newEntry);\n      }\n\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase(),\n      );\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => token.address.toLowerCase() !== address.toLowerCase(),\n      );\n\n      const { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens } =\n        this._getNewAllTokensState({\n          newTokens,\n          newIgnoredTokens,\n          newDetectedTokens,\n          interactingAddress: accountAddress,\n          interactingChainId: currentChainId,\n        });\n\n      let newState: Partial<TokensState> = {\n        allTokens: newAllTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n        allDetectedTokens: newAllDetectedTokens,\n      };\n\n      // Only update active tokens if user is interacting with their active wallet account.\n      if (isInteractingWithWalletAccount) {\n        newState = {\n          ...newState,\n          tokens: newTokens,\n          ignoredTokens: newIgnoredTokens,\n          detectedTokens: newDetectedTokens,\n        };\n      }\n\n      this.update(newState);\n      return newTokens;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Add a batch of tokens.\n   *\n   * @param tokensToImport - Array of tokens to import.\n   * @param networkClientId - Optional network client ID used to determine interacting chain ID.\n   */\n  async addTokens(tokensToImport: Token[], networkClientId?: NetworkClientId) {\n    const releaseLock = await this.mutex.acquire();\n    const { tokens, detectedTokens, ignoredTokens } = this.state;\n    const importedTokensMap: { [key: string]: true } = {};\n    // Used later to dedupe imported tokens\n    const newTokensMap = tokens.reduce((output, current) => {\n      output[current.address] = current;\n      return output;\n    }, {} as { [address: string]: Token });\n    try {\n      tokensToImport.forEach((tokenToAdd) => {\n        const { address, symbol, decimals, image, aggregators, name } =\n          tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const formattedToken: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          aggregators,\n          name,\n        };\n        newTokensMap[address] = formattedToken;\n        importedTokensMap[address.toLowerCase()] = true;\n        return formattedToken;\n      });\n      const newTokens = Object.values(newTokensMap);\n\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => !importedTokensMap[token.address.toLowerCase()],\n      );\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => !newTokensMap[tokenAddress.toLowerCase()],\n      );\n\n      let interactingChainId;\n      if (networkClientId) {\n        interactingChainId = this.messagingSystem.call(\n          'NetworkController:getNetworkClientById',\n          networkClientId,\n        ).configuration.chainId;\n      }\n\n      const { newAllTokens, newAllDetectedTokens, newAllIgnoredTokens } =\n        this._getNewAllTokensState({\n          newTokens,\n          newDetectedTokens,\n          newIgnoredTokens,\n          interactingChainId,\n        });\n\n      this.update({\n        tokens: newTokens,\n        allTokens: newAllTokens,\n        detectedTokens: newDetectedTokens,\n        allDetectedTokens: newAllDetectedTokens,\n        ignoredTokens: newIgnoredTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Ignore a batch of tokens.\n   *\n   * @param tokenAddressesToIgnore - Array of token addresses to ignore.\n   */\n  ignoreTokens(tokenAddressesToIgnore: string[]) {\n    const { ignoredTokens, detectedTokens, tokens } = this.state;\n    const ignoredTokensMap: { [key: string]: true } = {};\n    let newIgnoredTokens: string[] = [...ignoredTokens];\n\n    const checksummedTokenAddresses = tokenAddressesToIgnore.map((address) => {\n      const checksumAddress = toChecksumHexAddress(address);\n      ignoredTokensMap[address.toLowerCase()] = true;\n      return checksumAddress;\n    });\n    newIgnoredTokens = [...ignoredTokens, ...checksummedTokenAddresses];\n    const newDetectedTokens = detectedTokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n    const newTokens = tokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n\n    const { newAllIgnoredTokens, newAllDetectedTokens, newAllTokens } =\n      this._getNewAllTokensState({\n        newIgnoredTokens,\n        newDetectedTokens,\n        newTokens,\n      });\n\n    this.update({\n      ignoredTokens: newIgnoredTokens,\n      tokens: newTokens,\n      detectedTokens: newDetectedTokens,\n      allIgnoredTokens: newAllIgnoredTokens,\n      allDetectedTokens: newAllDetectedTokens,\n      allTokens: newAllTokens,\n    });\n  }\n\n  /**\n   * Adds a batch of detected tokens to the stored token list.\n   *\n   * @param incomingDetectedTokens - Array of detected tokens to be added or updated.\n   * @param detectionDetails - An object containing the chain ID and address of the currently selected network on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.selectedAddress - the account address on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.chainId - the chainId on which the incomingDetectedTokens were detected.\n   */\n  async addDetectedTokens(\n    incomingDetectedTokens: Token[],\n    detectionDetails?: { selectedAddress: string; chainId: Hex },\n  ) {\n    const releaseLock = await this.mutex.acquire();\n\n    // Get existing tokens for the chain + account\n    const chainId = detectionDetails?.chainId ?? this.config.chainId;\n    const accountAddress =\n      detectionDetails?.selectedAddress ?? this.config.selectedAddress;\n\n    const { allTokens, allDetectedTokens, allIgnoredTokens } = this.state;\n    let newTokens = [...(allTokens?.[chainId]?.[accountAddress] ?? [])];\n    let newDetectedTokens = [\n      ...(allDetectedTokens?.[chainId]?.[accountAddress] ?? []),\n    ];\n\n    try {\n      incomingDetectedTokens.forEach((tokenToAdd) => {\n        const {\n          address,\n          symbol,\n          decimals,\n          image,\n          aggregators,\n          isERC721,\n          name,\n        } = tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const newEntry: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          isERC721,\n          aggregators,\n          name,\n        };\n        const previousImportedIndex = newTokens.findIndex(\n          (token) =>\n            token.address.toLowerCase() === checksumAddress.toLowerCase(),\n        );\n        if (previousImportedIndex !== -1) {\n          // Update existing data of imported token\n          newTokens[previousImportedIndex] = newEntry;\n        } else {\n          const ignoredTokenIndex =\n            allIgnoredTokens?.[chainId]?.[accountAddress]?.indexOf(address) ??\n            -1;\n\n          if (ignoredTokenIndex === -1) {\n            // Add detected token\n            const previousDetectedIndex = newDetectedTokens.findIndex(\n              (token) =>\n                token.address.toLowerCase() === checksumAddress.toLowerCase(),\n            );\n            if (previousDetectedIndex !== -1) {\n              newDetectedTokens[previousDetectedIndex] = newEntry;\n            } else {\n              newDetectedTokens.push(newEntry);\n            }\n          }\n        }\n      });\n\n      const { newAllTokens, newAllDetectedTokens } = this._getNewAllTokensState(\n        {\n          newTokens,\n          newDetectedTokens,\n          interactingAddress: accountAddress,\n          interactingChainId: chainId,\n        },\n      );\n\n      // We may be detecting tokens on a different chain/account pair than are currently configured.\n      // Re-point `tokens` and `detectedTokens` to keep them referencing the current chain/account.\n      const { chainId: currentChain, selectedAddress: currentAddress } =\n        this.config;\n\n      newTokens = newAllTokens?.[currentChain]?.[currentAddress] || [];\n      newDetectedTokens =\n        newAllDetectedTokens?.[currentChain]?.[currentAddress] || [];\n\n      this.update({\n        tokens: newTokens,\n        allTokens: newAllTokens,\n        detectedTokens: newDetectedTokens,\n        allDetectedTokens: newAllDetectedTokens,\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds isERC721 field to token object. This is called when a user attempts to add tokens that\n   * were previously added which do not yet had isERC721 field.\n   *\n   * @param tokenAddress - The contract address of the token requiring the isERC721 field added.\n   * @returns The new token object with the added isERC721 field.\n   */\n  async updateTokenType(tokenAddress: string) {\n    const isERC721 = await this._detectIsERC721(tokenAddress);\n    const { tokens } = this.state;\n    const tokenIndex = tokens.findIndex((token) => {\n      return token.address.toLowerCase() === tokenAddress.toLowerCase();\n    });\n    tokens[tokenIndex].isERC721 = isERC721;\n    this.update({ tokens });\n    return tokens[tokenIndex];\n  }\n\n  /**\n   * This is a function that updates the tokens name for the tokens name if it is not defined.\n   *\n   * @param tokenList - Represents the fetched token list from service API\n   * @param tokenAttribute - Represents the token attribute that we want to update on the token list\n   */\n  private updateTokensAttribute(\n    tokenList: TokenListMap,\n    tokenAttribute: keyof Token & keyof TokenListToken,\n  ) {\n    const { tokens } = this.state;\n\n    const newTokens = tokens.map((token) => {\n      const newToken = tokenList[token.address.toLowerCase()];\n\n      return !token[tokenAttribute] && newToken?.[tokenAttribute]\n        ? { ...token, [tokenAttribute]: newToken[tokenAttribute] }\n        : { ...token };\n    });\n\n    this.update({ tokens: newTokens });\n  }\n\n  /**\n   * Detects whether or not a token is ERC-721 compatible.\n   *\n   * @param tokenAddress - The token contract address.\n   * @param networkClientId - Optional network client ID to fetch contract info with.\n   * @returns A boolean indicating whether the token address passed in supports the EIP-721\n   * interface.\n   */\n  async _detectIsERC721(\n    tokenAddress: string,\n    networkClientId?: NetworkClientId,\n  ) {\n    const checksumAddress = toChecksumHexAddress(tokenAddress);\n    // if this token is already in our contract metadata map we don't need\n    // to check against the contract\n    if (contractsMap[checksumAddress]?.erc721 === true) {\n      return Promise.resolve(true);\n    } else if (contractsMap[checksumAddress]?.erc20 === true) {\n      return Promise.resolve(false);\n    }\n\n    const tokenContract = this._createEthersContract(\n      tokenAddress,\n      abiERC721,\n      networkClientId,\n    );\n    try {\n      return await tokenContract.supportsInterface(ERC721_INTERFACE_ID);\n    } catch (error) {\n      // currently we see a variety of errors across different networks when\n      // token contracts are not ERC721 compatible. We need to figure out a better\n      // way of differentiating token interface types but for now if we get an error\n      // we have to assume the token is not ERC721 compatible.\n      return false;\n    }\n  }\n\n  _getProvider(networkClientId?: NetworkClientId): Web3Provider {\n    return new Web3Provider(\n      // @ts-expect-error TODO: remove this annotation once the `Eip1193Provider` class is released\n      networkClientId\n        ? this.messagingSystem.call(\n            'NetworkController:getNetworkClientById',\n            networkClientId,\n          ).provider\n        : this.config.provider,\n    );\n  }\n\n  _createEthersContract(\n    tokenAddress: string,\n    abi: string,\n    networkClientId?: NetworkClientId,\n  ): Contract {\n    const web3provider = this._getProvider(networkClientId);\n    const tokenContract = new Contract(tokenAddress, abi, web3provider);\n    return tokenContract;\n  }\n\n  _generateRandomId(): string {\n    return random();\n  }\n\n  /**\n   * Adds a new suggestedAsset to the list of watched assets.\n   * Parameters will be validated according to the asset type being watched.\n   *\n   * @param options - The method options.\n   * @param options.asset - The asset to be watched. For now only ERC20 tokens are accepted.\n   * @param options.type - The asset type.\n   * @param options.interactingAddress - The address of the account that is requesting to watch the asset.\n   * @param options.networkClientId - Network Client ID.\n   * @returns A promise that resolves if the asset was watched successfully, and rejects otherwise.\n   */\n  async watchAsset({\n    asset,\n    type,\n    interactingAddress,\n    networkClientId,\n  }: {\n    asset: Token;\n    type: string;\n    interactingAddress?: string;\n    networkClientId?: NetworkClientId;\n  }): Promise<void> {\n    if (type !== ERC20) {\n      throw new Error(`Asset of type ${type} not supported`);\n    }\n\n    if (!asset.address) {\n      throw rpcErrors.invalidParams('Address must be specified');\n    }\n\n    if (!isValidHexAddress(asset.address)) {\n      throw rpcErrors.invalidParams(`Invalid address \"${asset.address}\"`);\n    }\n\n    // Validate contract\n\n    if (await this._detectIsERC721(asset.address, networkClientId)) {\n      throw rpcErrors.invalidParams(\n        `Contract ${asset.address} must match type ${type}, but was detected as ${ERC721}`,\n      );\n    }\n\n    const provider = this._getProvider(networkClientId);\n    const isErc1155 = await safelyExecute(() =>\n      new ERC1155Standard(provider).contractSupportsBase1155Interface(\n        asset.address,\n      ),\n    );\n    if (isErc1155) {\n      throw rpcErrors.invalidParams(\n        `Contract ${asset.address} must match type ${type}, but was detected as ${ERC1155}`,\n      );\n    }\n\n    const erc20 = new ERC20Standard(provider);\n    const [contractName, contractSymbol, contractDecimals] = await Promise.all([\n      safelyExecute(() => erc20.getTokenName(asset.address)),\n      safelyExecute(() => erc20.getTokenSymbol(asset.address)),\n      safelyExecute(async () => erc20.getTokenDecimals(asset.address)),\n    ]);\n\n    asset.name = contractName;\n\n    // Validate symbol\n\n    if (!asset.symbol && !contractSymbol) {\n      throw rpcErrors.invalidParams(\n        'A symbol is required, but was not found in either the request or contract',\n      );\n    }\n\n    if (\n      contractSymbol !== undefined &&\n      asset.symbol !== undefined &&\n      asset.symbol.toUpperCase() !== contractSymbol.toUpperCase()\n    ) {\n      throw rpcErrors.invalidParams(\n        `The symbol in the request (${asset.symbol}) does not match the symbol in the contract (${contractSymbol})`,\n      );\n    }\n\n    asset.symbol = contractSymbol ?? asset.symbol;\n    if (typeof asset.symbol !== 'string') {\n      throw rpcErrors.invalidParams(`Invalid symbol: not a string`);\n    }\n\n    if (asset.symbol.length > 11) {\n      throw rpcErrors.invalidParams(\n        `Invalid symbol \"${asset.symbol}\": longer than 11 characters`,\n      );\n    }\n\n    // Validate decimals\n\n    if (asset.decimals === undefined && contractDecimals === undefined) {\n      throw rpcErrors.invalidParams(\n        'Decimals are required, but were not found in either the request or contract',\n      );\n    }\n\n    if (\n      contractDecimals !== undefined &&\n      asset.decimals !== undefined &&\n      String(asset.decimals) !== contractDecimals\n    ) {\n      throw rpcErrors.invalidParams(\n        `The decimals in the request (${asset.decimals}) do not match the decimals in the contract (${contractDecimals})`,\n      );\n    }\n\n    const decimalsStr = contractDecimals ?? asset.decimals;\n    const decimalsNum = parseInt(decimalsStr as unknown as string, 10);\n    if (!Number.isInteger(decimalsNum) || decimalsNum > 36 || decimalsNum < 0) {\n      throw rpcErrors.invalidParams(\n        `Invalid decimals \"${decimalsStr}\": must be an integer 0 <= 36`,\n      );\n    }\n    asset.decimals = decimalsNum;\n\n    const suggestedAssetMeta: SuggestedAssetMeta = {\n      asset,\n      id: this._generateRandomId(),\n      time: Date.now(),\n      type,\n      interactingAddress: interactingAddress || this.config.selectedAddress,\n    };\n\n    await this._requestApproval(suggestedAssetMeta);\n\n    const { address, symbol, decimals, name, image } = asset;\n    await this.addToken({\n      address,\n      symbol,\n      decimals,\n      name,\n      image,\n      interactingAddress: suggestedAssetMeta.interactingAddress,\n      networkClientId,\n    });\n  }\n\n  /**\n   * Takes a new tokens and ignoredTokens array for the current network/account combination\n   * and returns new allTokens and allIgnoredTokens state to update to.\n   *\n   * @param params - Object that holds token params.\n   * @param params.newTokens - The new tokens to set for the current network and selected account.\n   * @param params.newIgnoredTokens - The new ignored tokens to set for the current network and selected account.\n   * @param params.newDetectedTokens - The new detected tokens to set for the current network and selected account.\n   * @param params.interactingAddress - The account address to use to store the tokens.\n   * @param params.interactingChainId - The chainId to use to store the tokens.\n   * @returns The updated `allTokens` and `allIgnoredTokens` state.\n   */\n  _getNewAllTokensState(params: {\n    newTokens?: Token[];\n    newIgnoredTokens?: string[];\n    newDetectedTokens?: Token[];\n    interactingAddress?: string;\n    interactingChainId?: Hex;\n  }) {\n    const {\n      newTokens,\n      newIgnoredTokens,\n      newDetectedTokens,\n      interactingAddress,\n      interactingChainId,\n    } = params;\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    const { chainId, selectedAddress } = this.config;\n\n    const userAddressToAddTokens = interactingAddress ?? selectedAddress;\n    const chainIdToAddTokens = interactingChainId ?? chainId;\n\n    let newAllTokens = allTokens;\n    if (\n      newTokens?.length ||\n      (newTokens &&\n        allTokens &&\n        allTokens[chainIdToAddTokens] &&\n        allTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkTokens = allTokens[chainIdToAddTokens];\n      const newNetworkTokens = {\n        ...networkTokens,\n        ...{ [userAddressToAddTokens]: newTokens },\n      };\n      newAllTokens = {\n        ...allTokens,\n        ...{ [chainIdToAddTokens]: newNetworkTokens },\n      };\n    }\n\n    let newAllIgnoredTokens = allIgnoredTokens;\n    if (\n      newIgnoredTokens?.length ||\n      (newIgnoredTokens &&\n        allIgnoredTokens &&\n        allIgnoredTokens[chainIdToAddTokens] &&\n        allIgnoredTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkIgnoredTokens = allIgnoredTokens[chainIdToAddTokens];\n      const newIgnoredNetworkTokens = {\n        ...networkIgnoredTokens,\n        ...{ [userAddressToAddTokens]: newIgnoredTokens },\n      };\n      newAllIgnoredTokens = {\n        ...allIgnoredTokens,\n        ...{ [chainIdToAddTokens]: newIgnoredNetworkTokens },\n      };\n    }\n\n    let newAllDetectedTokens = allDetectedTokens;\n    if (\n      newDetectedTokens?.length ||\n      (newDetectedTokens &&\n        allDetectedTokens &&\n        allDetectedTokens[chainIdToAddTokens] &&\n        allDetectedTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkDetectedTokens = allDetectedTokens[chainIdToAddTokens];\n      const newDetectedNetworkTokens = {\n        ...networkDetectedTokens,\n        ...{ [userAddressToAddTokens]: newDetectedTokens },\n      };\n      newAllDetectedTokens = {\n        ...allDetectedTokens,\n        ...{ [chainIdToAddTokens]: newDetectedNetworkTokens },\n      };\n    }\n    return { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens };\n  }\n\n  /**\n   * Removes all tokens from the ignored list.\n   */\n  clearIgnoredTokens() {\n    this.update({ ignoredTokens: [], allIgnoredTokens: {} });\n  }\n\n  async _requestApproval(suggestedAssetMeta: SuggestedAssetMeta) {\n    return this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        id: suggestedAssetMeta.id,\n        origin: ORIGIN_METAMASK,\n        type: ApprovalType.WatchAsset,\n        requestData: {\n          id: suggestedAssetMeta.id,\n          interactingAddress: suggestedAssetMeta.interactingAddress,\n          asset: {\n            address: suggestedAssetMeta.asset.address,\n            decimals: suggestedAssetMeta.asset.decimals,\n            symbol: suggestedAssetMeta.asset.symbol,\n            image: suggestedAssetMeta.asset.image || null,\n          },\n        },\n      },\n      true,\n    );\n  }\n}\n\nexport default TokensController;\n"]}
\ No newline at end of file
diff --git a/dist/chunk-C64L6MMU.mjs b/dist/chunk-C64L6MMU.mjs
new file mode 100644
index 0000000000000000000000000000000000000000..151a9c024bb883ad126a0cff3a6546bf6c073101
--- /dev/null
+++ b/dist/chunk-C64L6MMU.mjs
@@ -0,0 +1,284 @@
+import {
+  fetchTokenListByChainId
+} from "./chunk-S6KASB6I.mjs";
+import {
+  formatAggregatorNames,
+  formatIconUrlWithProxy,
+  isTokenListSupportedForNetwork
+} from "./chunk-X5PLVMOQ.mjs";
+import {
+  __privateAdd,
+  __privateMethod
+} from "./chunk-XUI43LEZ.mjs";
+
+// src/TokenListController.ts
+import { safelyExecute } from "@metamask/controller-utils";
+import { StaticIntervalPollingController } from "@metamask/polling-controller";
+import { Mutex } from "async-mutex";
+var DEFAULT_INTERVAL = 24 * 60 * 60 * 1e3;
+var DEFAULT_THRESHOLD = 24 * 60 * 60 * 1e3;
+var name = "TokenListController";
+var metadata = {
+  tokenList: { persist: true, anonymous: true },
+  tokensChainsCache: { persist: true, anonymous: true },
+  preventPollingOnNetworkRestart: { persist: true, anonymous: true }
+};
+var getDefaultTokenListState = () => {
+  return {
+    tokenList: {},
+    tokensChainsCache: {},
+    preventPollingOnNetworkRestart: false
+  };
+};
+var _onNetworkControllerStateChange, onNetworkControllerStateChange_fn, _fetchFromCache, fetchFromCache_fn;
+var TokenListController = class extends StaticIntervalPollingController {
+  /**
+   * Creates a TokenListController instance.
+   *
+   * @param options - The controller options.
+   * @param options.chainId - The chain ID of the current network.
+   * @param options.onNetworkStateChange - A function for registering an event handler for network state changes.
+   * @param options.interval - The polling interval, in milliseconds.
+   * @param options.cacheRefreshThreshold - The token cache expiry time, in milliseconds.
+   * @param options.messenger - A restricted controller messenger.
+   * @param options.state - Initial state to set on this controller.
+   * @param options.preventPollingOnNetworkRestart - Determines whether to prevent poilling on network restart in extension.
+   */
+  constructor({
+    chainId,
+    preventPollingOnNetworkRestart = false,
+    onNetworkStateChange,
+    interval = DEFAULT_INTERVAL,
+    cacheRefreshThreshold = DEFAULT_THRESHOLD,
+    messenger,
+    state
+  }) {
+    super({
+      name,
+      metadata,
+      messenger,
+      state: { ...getDefaultTokenListState(), ...state }
+    });
+    /**
+     * Updates state and restarts polling on changes to the network controller
+     * state.
+     *
+     * @param networkControllerState - The updated network controller state.
+     */
+    __privateAdd(this, _onNetworkControllerStateChange);
+    /**
+     * Checks if the Cache timestamp is valid,
+     * if yes data in cache will be returned
+     * otherwise null will be returned.
+     * @param chainId - The chain ID of the network for which to fetch the cache.
+     * @returns The cached data, or `null` if the cache was expired.
+     */
+    __privateAdd(this, _fetchFromCache);
+    this.mutex = new Mutex();
+    this.intervalDelay = interval;
+    this.cacheRefreshThreshold = cacheRefreshThreshold;
+    this.chainId = chainId;
+    this.updatePreventPollingOnNetworkRestart(preventPollingOnNetworkRestart);
+    this.abortController = new AbortController();
+    if (onNetworkStateChange) {
+      onNetworkStateChange(async (networkControllerState) => {
+        await __privateMethod(this, _onNetworkControllerStateChange, onNetworkControllerStateChange_fn).call(this, networkControllerState);
+      });
+    } else {
+      this.messagingSystem.subscribe(
+        "NetworkController:stateChange",
+        async (networkControllerState) => {
+          await __privateMethod(this, _onNetworkControllerStateChange, onNetworkControllerStateChange_fn).call(this, networkControllerState);
+        }
+      );
+    }
+  }
+  /**
+   * Start polling for the token list.
+   */
+  async start() {
+    if (!isTokenListSupportedForNetwork(this.chainId)) {
+      return;
+    }
+    await this.startPolling();
+  }
+  /**
+   * Restart polling for the token list.
+   */
+  async restart() {
+    this.stopPolling();
+    await this.startPolling();
+  }
+  /**
+   * Stop polling for the token list.
+   */
+  stop() {
+    this.stopPolling();
+  }
+  /**
+   * Prepare to discard this controller.
+   *
+   * This stops any active polling.
+   */
+  destroy() {
+    super.destroy();
+    this.stopPolling();
+  }
+  stopPolling() {
+    if (this.intervalId) {
+      clearInterval(this.intervalId);
+    }
+  }
+  /**
+   * Starts a new polling interval.
+   */
+  async startPolling() {
+    await safelyExecute(() => this.fetchTokenList());
+    this.intervalId = setInterval(async () => {
+      await safelyExecute(() => this.fetchTokenList());
+    }, this.intervalDelay);
+  }
+  /**
+   * Fetching token list from the Token Service API.
+   *
+   * @private
+   * @param networkClientId - The ID of the network client triggering the fetch.
+   * @returns A promise that resolves when this operation completes.
+   */
+  async _executePoll(networkClientId) {
+    return this.fetchTokenList(networkClientId);
+  }
+  /**
+   * Fetching token list from the Token Service API.
+   *
+   * @param networkClientId - The ID of the network client triggering the fetch.
+   */
+  async fetchTokenList(networkClientId) {
+    const releaseLock = await this.mutex.acquire();
+    let networkClient;
+    if (networkClientId) {
+      networkClient = this.messagingSystem.call(
+        "NetworkController:getNetworkClientById",
+        networkClientId
+      );
+    }
+    const chainId = networkClient?.configuration.chainId ?? this.chainId;
+    try {
+      const { tokensChainsCache } = this.state;
+      let tokenList = {};
+      const cachedTokens = await safelyExecute(
+        () => __privateMethod(this, _fetchFromCache, fetchFromCache_fn).call(this, chainId)
+      );
+      if (cachedTokens) {
+        tokenList = { ...cachedTokens };
+      } else {
+        const tokensFromAPI = await safelyExecute(
+          () => fetchTokenListByChainId(
+            chainId,
+            this.abortController.signal
+          )
+        );
+        if (!tokensFromAPI) {
+          tokenList = { ...tokensChainsCache[chainId]?.data || {} };
+          this.update(() => {
+            return {
+              ...this.state,
+              tokenList,
+              tokensChainsCache
+            };
+          });
+          return;
+        }
+        for (const token of tokensFromAPI) {
+          const formattedToken = {
+            ...token,
+            aggregators: formatAggregatorNames(token.aggregators),
+            iconUrl: formatIconUrlWithProxy({
+              chainId,
+              tokenAddress: token.address
+            })
+          };
+          tokenList[token.address] = formattedToken;
+        }
+      }
+      const updatedTokensChainsCache = {
+        ...tokensChainsCache,
+        [chainId]: {
+          timestamp: Date.now(),
+          data: tokenList
+        }
+      };
+      this.update(() => {
+        return {
+          ...this.state,
+          tokenList,
+          tokensChainsCache: updatedTokensChainsCache
+        };
+      });
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Clearing tokenList and tokensChainsCache explicitly.
+   */
+  clearingTokenListData() {
+    this.update(() => {
+      return {
+        ...this.state,
+        tokenList: {},
+        tokensChainsCache: {}
+      };
+    });
+  }
+  /**
+   * Updates preventPollingOnNetworkRestart from extension.
+   *
+   * @param shouldPreventPolling - Determine whether to prevent polling on network change
+   */
+  updatePreventPollingOnNetworkRestart(shouldPreventPolling) {
+    this.update(() => {
+      return {
+        ...this.state,
+        preventPollingOnNetworkRestart: shouldPreventPolling
+      };
+    });
+  }
+};
+_onNetworkControllerStateChange = new WeakSet();
+onNetworkControllerStateChange_fn = async function(networkControllerState) {
+  if (this.chainId !== networkControllerState.providerConfig.chainId) {
+    this.abortController.abort();
+    this.abortController = new AbortController();
+    this.chainId = networkControllerState.providerConfig.chainId;
+    if (this.state.preventPollingOnNetworkRestart) {
+      this.clearingTokenListData();
+    } else {
+      this.update(() => {
+        return {
+          ...this.state,
+          tokenList: this.state.tokensChainsCache[this.chainId]?.data || {}
+        };
+      });
+      await this.restart();
+    }
+  }
+};
+_fetchFromCache = new WeakSet();
+fetchFromCache_fn = async function(chainId) {
+  const { tokensChainsCache } = this.state;
+  const dataCache = tokensChainsCache[chainId];
+  const now = Date.now();
+  if (dataCache?.data && now - dataCache?.timestamp < this.cacheRefreshThreshold) {
+    return dataCache.data;
+  }
+  return null;
+};
+var TokenListController_default = TokenListController;
+
+export {
+  getDefaultTokenListState,
+  TokenListController,
+  TokenListController_default
+};
+//# sourceMappingURL=chunk-C64L6MMU.mjs.map
\ No newline at end of file
diff --git a/dist/chunk-C64L6MMU.mjs.map b/dist/chunk-C64L6MMU.mjs.map
new file mode 100644
index 0000000000000000000000000000000000000000..a05d2fc634a092464a4ec07bd751c914337ce7e6
--- /dev/null
+++ b/dist/chunk-C64L6MMU.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/TokenListController.ts"],"sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { safelyExecute } from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkControllerStateChangeEvent,\n  NetworkState,\n  NetworkControllerGetNetworkClientByIdAction,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingController } from '@metamask/polling-controller';\nimport type { Hex } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\n\nimport {\n  isTokenListSupportedForNetwork,\n  formatAggregatorNames,\n  formatIconUrlWithProxy,\n} from './assetsUtil';\nimport { fetchTokenListByChainId } from './token-service';\n\nconst DEFAULT_INTERVAL = 24 * 60 * 60 * 1000;\nconst DEFAULT_THRESHOLD = 24 * 60 * 60 * 1000;\n\nconst name = 'TokenListController';\n\nexport type TokenListToken = {\n  name: string;\n  symbol: string;\n  decimals: number;\n  address: string;\n  occurrences: number;\n  aggregators: string[];\n  iconUrl: string;\n};\n\nexport type TokenListMap = Record<string, TokenListToken>;\n\ntype DataCache = {\n  timestamp: number;\n  data: TokenListMap;\n};\ntype TokensChainsCache = {\n  [chainId: Hex]: DataCache;\n};\n\nexport type TokenListState = {\n  tokenList: TokenListMap;\n  tokensChainsCache: TokensChainsCache;\n  preventPollingOnNetworkRestart: boolean;\n};\n\nexport type TokenListStateChange = ControllerStateChangeEvent<\n  typeof name,\n  TokenListState\n>;\n\nexport type TokenListControllerEvents = TokenListStateChange;\n\nexport type GetTokenListState = ControllerGetStateAction<\n  typeof name,\n  TokenListState\n>;\n\nexport type TokenListControllerActions = GetTokenListState;\n\ntype AllowedActions = NetworkControllerGetNetworkClientByIdAction;\n\ntype AllowedEvents = NetworkControllerStateChangeEvent;\n\nexport type TokenListControllerMessenger = RestrictedControllerMessenger<\n  typeof name,\n  TokenListControllerActions | AllowedActions,\n  TokenListControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\nconst metadata = {\n  tokenList: { persist: true, anonymous: true },\n  tokensChainsCache: { persist: true, anonymous: true },\n  preventPollingOnNetworkRestart: { persist: true, anonymous: true },\n};\n\nexport const getDefaultTokenListState = (): TokenListState => {\n  return {\n    tokenList: {},\n    tokensChainsCache: {},\n    preventPollingOnNetworkRestart: false,\n  };\n};\n\n/**\n * Controller that passively polls on a set interval for the list of tokens from metaswaps api\n */\nexport class TokenListController extends StaticIntervalPollingController<\n  typeof name,\n  TokenListState,\n  TokenListControllerMessenger\n> {\n  private readonly mutex = new Mutex();\n\n  private intervalId?: ReturnType<typeof setTimeout>;\n\n  private readonly intervalDelay: number;\n\n  private readonly cacheRefreshThreshold: number;\n\n  private chainId: Hex;\n\n  private abortController: AbortController;\n\n  /**\n   * Creates a TokenListController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onNetworkStateChange - A function for registering an event handler for network state changes.\n   * @param options.interval - The polling interval, in milliseconds.\n   * @param options.cacheRefreshThreshold - The token cache expiry time, in milliseconds.\n   * @param options.messenger - A restricted controller messenger.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.preventPollingOnNetworkRestart - Determines whether to prevent poilling on network restart in extension.\n   */\n  constructor({\n    chainId,\n    preventPollingOnNetworkRestart = false,\n    onNetworkStateChange,\n    interval = DEFAULT_INTERVAL,\n    cacheRefreshThreshold = DEFAULT_THRESHOLD,\n    messenger,\n    state,\n  }: {\n    chainId: Hex;\n    preventPollingOnNetworkRestart?: boolean;\n    onNetworkStateChange?: (\n      listener: (networkState: NetworkState) => void,\n    ) => void;\n    interval?: number;\n    cacheRefreshThreshold?: number;\n    messenger: TokenListControllerMessenger;\n    state?: Partial<TokenListState>;\n  }) {\n    super({\n      name,\n      metadata,\n      messenger,\n      state: { ...getDefaultTokenListState(), ...state },\n    });\n    this.intervalDelay = interval;\n    this.cacheRefreshThreshold = cacheRefreshThreshold;\n    this.chainId = chainId;\n    this.updatePreventPollingOnNetworkRestart(preventPollingOnNetworkRestart);\n    this.abortController = new AbortController();\n    if (onNetworkStateChange) {\n      onNetworkStateChange(async (networkControllerState) => {\n        await this.#onNetworkControllerStateChange(networkControllerState);\n      });\n    } else {\n      this.messagingSystem.subscribe(\n        'NetworkController:stateChange',\n        async (networkControllerState) => {\n          await this.#onNetworkControllerStateChange(networkControllerState);\n        },\n      );\n    }\n  }\n\n  /**\n   * Updates state and restarts polling on changes to the network controller\n   * state.\n   *\n   * @param networkControllerState - The updated network controller state.\n   */\n  async #onNetworkControllerStateChange(networkControllerState: NetworkState) {\n    if (this.chainId !== networkControllerState.providerConfig.chainId) {\n      this.abortController.abort();\n      this.abortController = new AbortController();\n      this.chainId = networkControllerState.providerConfig.chainId;\n      if (this.state.preventPollingOnNetworkRestart) {\n        this.clearingTokenListData();\n      } else {\n        // Ensure tokenList is referencing data from correct network\n        this.update(() => {\n          return {\n            ...this.state,\n            tokenList: this.state.tokensChainsCache[this.chainId]?.data || {},\n          };\n        });\n        await this.restart();\n      }\n    }\n  }\n\n  /**\n   * Start polling for the token list.\n   */\n  async start() {\n    if (!isTokenListSupportedForNetwork(this.chainId)) {\n      return;\n    }\n    await this.startPolling();\n  }\n\n  /**\n   * Restart polling for the token list.\n   */\n  async restart() {\n    this.stopPolling();\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for the token list.\n   */\n  stop() {\n    this.stopPolling();\n  }\n\n  /**\n   * Prepare to discard this controller.\n   *\n   * This stops any active polling.\n   */\n  override destroy() {\n    super.destroy();\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   */\n  private async startPolling(): Promise<void> {\n    await safelyExecute(() => this.fetchTokenList());\n    this.intervalId = setInterval(async () => {\n      await safelyExecute(() => this.fetchTokenList());\n    }, this.intervalDelay);\n  }\n\n  /**\n   * Fetching token list from the Token Service API.\n   *\n   * @private\n   * @param networkClientId - The ID of the network client triggering the fetch.\n   * @returns A promise that resolves when this operation completes.\n   */\n  async _executePoll(networkClientId: string): Promise<void> {\n    return this.fetchTokenList(networkClientId);\n  }\n\n  /**\n   * Fetching token list from the Token Service API.\n   *\n   * @param networkClientId - The ID of the network client triggering the fetch.\n   */\n  async fetchTokenList(networkClientId?: NetworkClientId): Promise<void> {\n    const releaseLock = await this.mutex.acquire();\n    let networkClient;\n    if (networkClientId) {\n      networkClient = this.messagingSystem.call(\n        'NetworkController:getNetworkClientById',\n        networkClientId,\n      );\n    }\n    const chainId = networkClient?.configuration.chainId ?? this.chainId;\n    try {\n      const { tokensChainsCache } = this.state;\n      let tokenList: TokenListMap = {};\n      const cachedTokens = await safelyExecute(() =>\n        this.#fetchFromCache(chainId),\n      );\n      if (cachedTokens) {\n        // Use non-expired cached tokens\n        tokenList = { ...cachedTokens };\n      } else {\n        // Fetch fresh token list\n        const tokensFromAPI = await safelyExecute(\n          () =>\n            fetchTokenListByChainId(\n              chainId,\n              this.abortController.signal,\n            ) as Promise<TokenListToken[]>,\n        );\n\n        if (!tokensFromAPI) {\n          // Fallback to expired cached tokens\n          tokenList = { ...(tokensChainsCache[chainId]?.data || {}) };\n          this.update(() => {\n            return {\n              ...this.state,\n              tokenList,\n              tokensChainsCache,\n            };\n          });\n          return;\n        }\n        for (const token of tokensFromAPI) {\n          const formattedToken: TokenListToken = {\n            ...token,\n            aggregators: formatAggregatorNames(token.aggregators),\n            iconUrl: formatIconUrlWithProxy({\n              chainId,\n              tokenAddress: token.address,\n            }),\n          };\n          tokenList[token.address] = formattedToken;\n        }\n      }\n      const updatedTokensChainsCache: TokensChainsCache = {\n        ...tokensChainsCache,\n        [chainId]: {\n          timestamp: Date.now(),\n          data: tokenList,\n        },\n      };\n      this.update(() => {\n        return {\n          ...this.state,\n          tokenList,\n          tokensChainsCache: updatedTokensChainsCache,\n        };\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Checks if the Cache timestamp is valid,\n   * if yes data in cache will be returned\n   * otherwise null will be returned.\n   * @param chainId - The chain ID of the network for which to fetch the cache.\n   * @returns The cached data, or `null` if the cache was expired.\n   */\n  async #fetchFromCache(chainId: Hex): Promise<TokenListMap | null> {\n    const { tokensChainsCache }: TokenListState = this.state;\n    const dataCache = tokensChainsCache[chainId];\n    const now = Date.now();\n    if (\n      dataCache?.data &&\n      now - dataCache?.timestamp < this.cacheRefreshThreshold\n    ) {\n      return dataCache.data;\n    }\n    return null;\n  }\n\n  /**\n   * Clearing tokenList and tokensChainsCache explicitly.\n   */\n  clearingTokenListData(): void {\n    this.update(() => {\n      return {\n        ...this.state,\n        tokenList: {},\n        tokensChainsCache: {},\n      };\n    });\n  }\n\n  /**\n   * Updates preventPollingOnNetworkRestart from extension.\n   *\n   * @param shouldPreventPolling - Determine whether to prevent polling on network change\n   */\n  updatePreventPollingOnNetworkRestart(shouldPreventPolling: boolean): void {\n    this.update(() => {\n      return {\n        ...this.state,\n        preventPollingOnNetworkRestart: shouldPreventPolling,\n      };\n    });\n  }\n}\n\nexport default TokenListController;\n"],"mappings":"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","names":[]}
\ No newline at end of file
diff --git a/dist/chunk-DEQZ35QE.js b/dist/chunk-DEQZ35QE.js
deleted file mode 100644
index 1040ba109bb6da90c65b4a74fa7f9c7ea873d22c..0000000000000000000000000000000000000000
--- a/dist/chunk-DEQZ35QE.js
+++ /dev/null
@@ -1,284 +0,0 @@
-"use strict";Object.defineProperty(exports, "__esModule", {value: true});
-
-var _chunkOHSQRYVLjs = require('./chunk-OHSQRYVL.js');
-
-
-
-
-var _chunkLS6R3HQLjs = require('./chunk-LS6R3HQL.js');
-
-
-
-var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
-
-// src/TokenListController.ts
-var _controllerutils = require('@metamask/controller-utils');
-var _pollingcontroller = require('@metamask/polling-controller');
-var _asyncmutex = require('async-mutex');
-var DEFAULT_INTERVAL = 24 * 60 * 60 * 1e3;
-var DEFAULT_THRESHOLD = 24 * 60 * 60 * 1e3;
-var name = "TokenListController";
-var metadata = {
-  tokenList: { persist: true, anonymous: true },
-  tokensChainsCache: { persist: true, anonymous: true },
-  preventPollingOnNetworkRestart: { persist: true, anonymous: true }
-};
-var getDefaultTokenListState = () => {
-  return {
-    tokenList: {},
-    tokensChainsCache: {},
-    preventPollingOnNetworkRestart: false
-  };
-};
-var _onNetworkControllerStateChange, onNetworkControllerStateChange_fn, _fetchFromCache, fetchFromCache_fn;
-var TokenListController = class extends _pollingcontroller.StaticIntervalPollingController {
-  /**
-   * Creates a TokenListController instance.
-   *
-   * @param options - The controller options.
-   * @param options.chainId - The chain ID of the current network.
-   * @param options.onNetworkStateChange - A function for registering an event handler for network state changes.
-   * @param options.interval - The polling interval, in milliseconds.
-   * @param options.cacheRefreshThreshold - The token cache expiry time, in milliseconds.
-   * @param options.messenger - A restricted controller messenger.
-   * @param options.state - Initial state to set on this controller.
-   * @param options.preventPollingOnNetworkRestart - Determines whether to prevent poilling on network restart in extension.
-   */
-  constructor({
-    chainId,
-    preventPollingOnNetworkRestart = false,
-    onNetworkStateChange,
-    interval = DEFAULT_INTERVAL,
-    cacheRefreshThreshold = DEFAULT_THRESHOLD,
-    messenger,
-    state
-  }) {
-    super({
-      name,
-      metadata,
-      messenger,
-      state: { ...getDefaultTokenListState(), ...state }
-    });
-    /**
-     * Updates state and restarts polling on changes to the network controller
-     * state.
-     *
-     * @param networkControllerState - The updated network controller state.
-     */
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _onNetworkControllerStateChange);
-    /**
-     * Checks if the Cache timestamp is valid,
-     * if yes data in cache will be returned
-     * otherwise null will be returned.
-     * @param chainId - The chain ID of the network for which to fetch the cache.
-     * @returns The cached data, or `null` if the cache was expired.
-     */
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _fetchFromCache);
-    this.mutex = new (0, _asyncmutex.Mutex)();
-    this.intervalDelay = interval;
-    this.cacheRefreshThreshold = cacheRefreshThreshold;
-    this.chainId = chainId;
-    this.updatePreventPollingOnNetworkRestart(preventPollingOnNetworkRestart);
-    this.abortController = new AbortController();
-    if (onNetworkStateChange) {
-      onNetworkStateChange(async (networkControllerState) => {
-        await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _onNetworkControllerStateChange, onNetworkControllerStateChange_fn).call(this, networkControllerState);
-      });
-    } else {
-      this.messagingSystem.subscribe(
-        "NetworkController:stateChange",
-        async (networkControllerState) => {
-          await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _onNetworkControllerStateChange, onNetworkControllerStateChange_fn).call(this, networkControllerState);
-        }
-      );
-    }
-  }
-  /**
-   * Start polling for the token list.
-   */
-  async start() {
-    if (!_chunkLS6R3HQLjs.isTokenListSupportedForNetwork.call(void 0, this.chainId)) {
-      return;
-    }
-    await this.startPolling();
-  }
-  /**
-   * Restart polling for the token list.
-   */
-  async restart() {
-    this.stopPolling();
-    await this.startPolling();
-  }
-  /**
-   * Stop polling for the token list.
-   */
-  stop() {
-    this.stopPolling();
-  }
-  /**
-   * Prepare to discard this controller.
-   *
-   * This stops any active polling.
-   */
-  destroy() {
-    super.destroy();
-    this.stopPolling();
-  }
-  stopPolling() {
-    if (this.intervalId) {
-      clearInterval(this.intervalId);
-    }
-  }
-  /**
-   * Starts a new polling interval.
-   */
-  async startPolling() {
-    await _controllerutils.safelyExecute.call(void 0, () => this.fetchTokenList());
-    this.intervalId = setInterval(async () => {
-      await _controllerutils.safelyExecute.call(void 0, () => this.fetchTokenList());
-    }, this.intervalDelay);
-  }
-  /**
-   * Fetching token list from the Token Service API.
-   *
-   * @private
-   * @param networkClientId - The ID of the network client triggering the fetch.
-   * @returns A promise that resolves when this operation completes.
-   */
-  async _executePoll(networkClientId) {
-    return this.fetchTokenList(networkClientId);
-  }
-  /**
-   * Fetching token list from the Token Service API.
-   *
-   * @param networkClientId - The ID of the network client triggering the fetch.
-   */
-  async fetchTokenList(networkClientId) {
-    const releaseLock = await this.mutex.acquire();
-    let networkClient;
-    if (networkClientId) {
-      networkClient = this.messagingSystem.call(
-        "NetworkController:getNetworkClientById",
-        networkClientId
-      );
-    }
-    const chainId = networkClient?.configuration.chainId ?? this.chainId;
-    try {
-      const { tokensChainsCache } = this.state;
-      let tokenList = {};
-      const cachedTokens = await _controllerutils.safelyExecute.call(void 0, 
-        () => _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _fetchFromCache, fetchFromCache_fn).call(this, chainId)
-      );
-      if (cachedTokens) {
-        tokenList = { ...cachedTokens };
-      } else {
-        const tokensFromAPI = await _controllerutils.safelyExecute.call(void 0, 
-          () => _chunkOHSQRYVLjs.fetchTokenListByChainId.call(void 0, 
-            chainId,
-            this.abortController.signal
-          )
-        );
-        if (!tokensFromAPI) {
-          tokenList = { ...tokensChainsCache[chainId]?.data || {} };
-          this.update(() => {
-            return {
-              ...this.state,
-              tokenList,
-              tokensChainsCache
-            };
-          });
-          return;
-        }
-        for (const token of tokensFromAPI) {
-          const formattedToken = {
-            ...token,
-            aggregators: _chunkLS6R3HQLjs.formatAggregatorNames.call(void 0, token.aggregators),
-            iconUrl: _chunkLS6R3HQLjs.formatIconUrlWithProxy.call(void 0, {
-              chainId,
-              tokenAddress: token.address
-            })
-          };
-          tokenList[token.address] = formattedToken;
-        }
-      }
-      const updatedTokensChainsCache = {
-        ...tokensChainsCache,
-        [chainId]: {
-          timestamp: Date.now(),
-          data: tokenList
-        }
-      };
-      this.update(() => {
-        return {
-          ...this.state,
-          tokenList,
-          tokensChainsCache: updatedTokensChainsCache
-        };
-      });
-    } finally {
-      releaseLock();
-    }
-  }
-  /**
-   * Clearing tokenList and tokensChainsCache explicitly.
-   */
-  clearingTokenListData() {
-    this.update(() => {
-      return {
-        ...this.state,
-        tokenList: {},
-        tokensChainsCache: {}
-      };
-    });
-  }
-  /**
-   * Updates preventPollingOnNetworkRestart from extension.
-   *
-   * @param shouldPreventPolling - Determine whether to prevent polling on network change
-   */
-  updatePreventPollingOnNetworkRestart(shouldPreventPolling) {
-    this.update(() => {
-      return {
-        ...this.state,
-        preventPollingOnNetworkRestart: shouldPreventPolling
-      };
-    });
-  }
-};
-_onNetworkControllerStateChange = new WeakSet();
-onNetworkControllerStateChange_fn = async function(networkControllerState) {
-  if (this.chainId !== networkControllerState.providerConfig.chainId) {
-    this.abortController.abort();
-    this.abortController = new AbortController();
-    this.chainId = networkControllerState.providerConfig.chainId;
-    if (this.state.preventPollingOnNetworkRestart) {
-      this.clearingTokenListData();
-    } else {
-      this.update(() => {
-        return {
-          ...this.state,
-          tokenList: this.state.tokensChainsCache[this.chainId]?.data || {}
-        };
-      });
-      await this.restart();
-    }
-  }
-};
-_fetchFromCache = new WeakSet();
-fetchFromCache_fn = async function(chainId) {
-  const { tokensChainsCache } = this.state;
-  const dataCache = tokensChainsCache[chainId];
-  const now = Date.now();
-  if (dataCache?.data && now - dataCache?.timestamp < this.cacheRefreshThreshold) {
-    return dataCache.data;
-  }
-  return null;
-};
-var TokenListController_default = TokenListController;
-
-
-
-
-
-exports.getDefaultTokenListState = getDefaultTokenListState; exports.TokenListController = TokenListController; exports.TokenListController_default = TokenListController_default;
-//# sourceMappingURL=chunk-DEQZ35QE.js.map
\ No newline at end of file
diff --git a/dist/chunk-DEQZ35QE.js.map b/dist/chunk-DEQZ35QE.js.map
deleted file mode 100644
index 3fecf02e65893f4642b548fa908200f9c5d94954..0000000000000000000000000000000000000000
--- a/dist/chunk-DEQZ35QE.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["../src/TokenListController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { safelyExecute } from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkControllerStateChangeEvent,\n  NetworkState,\n  NetworkControllerGetNetworkClientByIdAction,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingController } from '@metamask/polling-controller';\nimport type { Hex } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\n\nimport {\n  isTokenListSupportedForNetwork,\n  formatAggregatorNames,\n  formatIconUrlWithProxy,\n} from './assetsUtil';\nimport { fetchTokenListByChainId } from './token-service';\n\nconst DEFAULT_INTERVAL = 24 * 60 * 60 * 1000;\nconst DEFAULT_THRESHOLD = 24 * 60 * 60 * 1000;\n\nconst name = 'TokenListController';\n\nexport type TokenListToken = {\n  name: string;\n  symbol: string;\n  decimals: number;\n  address: string;\n  occurrences: number;\n  aggregators: string[];\n  iconUrl: string;\n};\n\nexport type TokenListMap = Record<string, TokenListToken>;\n\ntype DataCache = {\n  timestamp: number;\n  data: TokenListMap;\n};\ntype TokensChainsCache = {\n  [chainId: Hex]: DataCache;\n};\n\nexport type TokenListState = {\n  tokenList: TokenListMap;\n  tokensChainsCache: TokensChainsCache;\n  preventPollingOnNetworkRestart: boolean;\n};\n\nexport type TokenListStateChange = ControllerStateChangeEvent<\n  typeof name,\n  TokenListState\n>;\n\nexport type TokenListControllerEvents = TokenListStateChange;\n\nexport type GetTokenListState = ControllerGetStateAction<\n  typeof name,\n  TokenListState\n>;\n\nexport type TokenListControllerActions = GetTokenListState;\n\ntype AllowedActions = NetworkControllerGetNetworkClientByIdAction;\n\ntype AllowedEvents = NetworkControllerStateChangeEvent;\n\nexport type TokenListControllerMessenger = RestrictedControllerMessenger<\n  typeof name,\n  TokenListControllerActions | AllowedActions,\n  TokenListControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\nconst metadata = {\n  tokenList: { persist: true, anonymous: true },\n  tokensChainsCache: { persist: true, anonymous: true },\n  preventPollingOnNetworkRestart: { persist: true, anonymous: true },\n};\n\nexport const getDefaultTokenListState = (): TokenListState => {\n  return {\n    tokenList: {},\n    tokensChainsCache: {},\n    preventPollingOnNetworkRestart: false,\n  };\n};\n\n/**\n * Controller that passively polls on a set interval for the list of tokens from metaswaps api\n */\nexport class TokenListController extends StaticIntervalPollingController<\n  typeof name,\n  TokenListState,\n  TokenListControllerMessenger\n> {\n  private readonly mutex = new Mutex();\n\n  private intervalId?: ReturnType<typeof setTimeout>;\n\n  private readonly intervalDelay: number;\n\n  private readonly cacheRefreshThreshold: number;\n\n  private chainId: Hex;\n\n  private abortController: AbortController;\n\n  /**\n   * Creates a TokenListController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onNetworkStateChange - A function for registering an event handler for network state changes.\n   * @param options.interval - The polling interval, in milliseconds.\n   * @param options.cacheRefreshThreshold - The token cache expiry time, in milliseconds.\n   * @param options.messenger - A restricted controller messenger.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.preventPollingOnNetworkRestart - Determines whether to prevent poilling on network restart in extension.\n   */\n  constructor({\n    chainId,\n    preventPollingOnNetworkRestart = false,\n    onNetworkStateChange,\n    interval = DEFAULT_INTERVAL,\n    cacheRefreshThreshold = DEFAULT_THRESHOLD,\n    messenger,\n    state,\n  }: {\n    chainId: Hex;\n    preventPollingOnNetworkRestart?: boolean;\n    onNetworkStateChange?: (\n      listener: (networkState: NetworkState) => void,\n    ) => void;\n    interval?: number;\n    cacheRefreshThreshold?: number;\n    messenger: TokenListControllerMessenger;\n    state?: Partial<TokenListState>;\n  }) {\n    super({\n      name,\n      metadata,\n      messenger,\n      state: { ...getDefaultTokenListState(), ...state },\n    });\n    this.intervalDelay = interval;\n    this.cacheRefreshThreshold = cacheRefreshThreshold;\n    this.chainId = chainId;\n    this.updatePreventPollingOnNetworkRestart(preventPollingOnNetworkRestart);\n    this.abortController = new AbortController();\n    if (onNetworkStateChange) {\n      onNetworkStateChange(async (networkControllerState) => {\n        await this.#onNetworkControllerStateChange(networkControllerState);\n      });\n    } else {\n      this.messagingSystem.subscribe(\n        'NetworkController:stateChange',\n        async (networkControllerState) => {\n          await this.#onNetworkControllerStateChange(networkControllerState);\n        },\n      );\n    }\n  }\n\n  /**\n   * Updates state and restarts polling on changes to the network controller\n   * state.\n   *\n   * @param networkControllerState - The updated network controller state.\n   */\n  async #onNetworkControllerStateChange(networkControllerState: NetworkState) {\n    if (this.chainId !== networkControllerState.providerConfig.chainId) {\n      this.abortController.abort();\n      this.abortController = new AbortController();\n      this.chainId = networkControllerState.providerConfig.chainId;\n      if (this.state.preventPollingOnNetworkRestart) {\n        this.clearingTokenListData();\n      } else {\n        // Ensure tokenList is referencing data from correct network\n        this.update(() => {\n          return {\n            ...this.state,\n            tokenList: this.state.tokensChainsCache[this.chainId]?.data || {},\n          };\n        });\n        await this.restart();\n      }\n    }\n  }\n\n  /**\n   * Start polling for the token list.\n   */\n  async start() {\n    if (!isTokenListSupportedForNetwork(this.chainId)) {\n      return;\n    }\n    await this.startPolling();\n  }\n\n  /**\n   * Restart polling for the token list.\n   */\n  async restart() {\n    this.stopPolling();\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for the token list.\n   */\n  stop() {\n    this.stopPolling();\n  }\n\n  /**\n   * Prepare to discard this controller.\n   *\n   * This stops any active polling.\n   */\n  override destroy() {\n    super.destroy();\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   */\n  private async startPolling(): Promise<void> {\n    await safelyExecute(() => this.fetchTokenList());\n    this.intervalId = setInterval(async () => {\n      await safelyExecute(() => this.fetchTokenList());\n    }, this.intervalDelay);\n  }\n\n  /**\n   * Fetching token list from the Token Service API.\n   *\n   * @private\n   * @param networkClientId - The ID of the network client triggering the fetch.\n   * @returns A promise that resolves when this operation completes.\n   */\n  async _executePoll(networkClientId: string): Promise<void> {\n    return this.fetchTokenList(networkClientId);\n  }\n\n  /**\n   * Fetching token list from the Token Service API.\n   *\n   * @param networkClientId - The ID of the network client triggering the fetch.\n   */\n  async fetchTokenList(networkClientId?: NetworkClientId): Promise<void> {\n    const releaseLock = await this.mutex.acquire();\n    let networkClient;\n    if (networkClientId) {\n      networkClient = this.messagingSystem.call(\n        'NetworkController:getNetworkClientById',\n        networkClientId,\n      );\n    }\n    const chainId = networkClient?.configuration.chainId ?? this.chainId;\n    try {\n      const { tokensChainsCache } = this.state;\n      let tokenList: TokenListMap = {};\n      const cachedTokens = await safelyExecute(() =>\n        this.#fetchFromCache(chainId),\n      );\n      if (cachedTokens) {\n        // Use non-expired cached tokens\n        tokenList = { ...cachedTokens };\n      } else {\n        // Fetch fresh token list\n        const tokensFromAPI = await safelyExecute(\n          () =>\n            fetchTokenListByChainId(\n              chainId,\n              this.abortController.signal,\n            ) as Promise<TokenListToken[]>,\n        );\n\n        if (!tokensFromAPI) {\n          // Fallback to expired cached tokens\n          tokenList = { ...(tokensChainsCache[chainId]?.data || {}) };\n          this.update(() => {\n            return {\n              ...this.state,\n              tokenList,\n              tokensChainsCache,\n            };\n          });\n          return;\n        }\n        for (const token of tokensFromAPI) {\n          const formattedToken: TokenListToken = {\n            ...token,\n            aggregators: formatAggregatorNames(token.aggregators),\n            iconUrl: formatIconUrlWithProxy({\n              chainId,\n              tokenAddress: token.address,\n            }),\n          };\n          tokenList[token.address] = formattedToken;\n        }\n      }\n      const updatedTokensChainsCache: TokensChainsCache = {\n        ...tokensChainsCache,\n        [chainId]: {\n          timestamp: Date.now(),\n          data: tokenList,\n        },\n      };\n      this.update(() => {\n        return {\n          ...this.state,\n          tokenList,\n          tokensChainsCache: updatedTokensChainsCache,\n        };\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Checks if the Cache timestamp is valid,\n   * if yes data in cache will be returned\n   * otherwise null will be returned.\n   * @param chainId - The chain ID of the network for which to fetch the cache.\n   * @returns The cached data, or `null` if the cache was expired.\n   */\n  async #fetchFromCache(chainId: Hex): Promise<TokenListMap | null> {\n    const { tokensChainsCache }: TokenListState = this.state;\n    const dataCache = tokensChainsCache[chainId];\n    const now = Date.now();\n    if (\n      dataCache?.data &&\n      now - dataCache?.timestamp < this.cacheRefreshThreshold\n    ) {\n      return dataCache.data;\n    }\n    return null;\n  }\n\n  /**\n   * Clearing tokenList and tokensChainsCache explicitly.\n   */\n  clearingTokenListData(): void {\n    this.update(() => {\n      return {\n        ...this.state,\n        tokenList: {},\n        tokensChainsCache: {},\n      };\n    });\n  }\n\n  /**\n   * Updates preventPollingOnNetworkRestart from extension.\n   *\n   * @param shouldPreventPolling - Determine whether to prevent polling on network change\n   */\n  updatePreventPollingOnNetworkRestart(shouldPreventPolling: boolean): void {\n    this.update(() => {\n      return {\n        ...this.state,\n        preventPollingOnNetworkRestart: shouldPreventPolling,\n      };\n    });\n  }\n}\n\nexport default TokenListController;\n"]}
\ No newline at end of file
diff --git a/dist/chunk-F2F3NGG3.js b/dist/chunk-F2F3NGG3.js
new file mode 100644
index 0000000000000000000000000000000000000000..7ea1144d9d9f1bf2f6923fdb1bf458154fc1c637
--- /dev/null
+++ b/dist/chunk-F2F3NGG3.js
@@ -0,0 +1,1202 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+
+var _chunkLS6R3HQLjs = require('./chunk-LS6R3HQL.js');
+
+// src/NftController.ts
+var _address = require('@ethersproject/address');
+var _basecontroller = require('@metamask/base-controller');
+
+
+
+
+
+
+
+
+
+
+
+var _controllerutils = require('@metamask/controller-utils');
+var _rpcerrors = require('@metamask/rpc-errors');
+var _utils = require('@metamask/utils');
+var _asyncmutex = require('async-mutex');
+var _bnjs = require('bn.js'); var _bnjs2 = _interopRequireDefault(_bnjs);
+var _events = require('events');
+var _uuid = require('uuid');
+var ALL_NFTS_STATE_KEY = "allNfts";
+var ALL_NFTS_CONTRACTS_STATE_KEY = "allNftContracts";
+var getDefaultNftState = () => {
+  return {
+    allNftContracts: {},
+    allNfts: {},
+    ignoredNfts: []
+  };
+};
+var NftController = class extends _basecontroller.BaseControllerV1 {
+  /**
+   * Creates an NftController instance.
+   *
+   * @param options - The controller options.
+   * @param options.chainId - The chain ID of the current network.
+   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
+   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
+   * @param options.getERC721AssetName - Gets the name of the asset at the given address.
+   * @param options.getERC721AssetSymbol - Gets the symbol of the asset at the given address.
+   * @param options.getERC721TokenURI - Gets the URI of the ERC721 token at the given address, with the given ID.
+   * @param options.getERC721OwnerOf - Get the owner of a ERC-721 NFT.
+   * @param options.getERC1155BalanceOf - Gets balance of a ERC-1155 NFT.
+   * @param options.getERC1155TokenURI - Gets the URI of the ERC1155 token at the given address, with the given ID.
+   * @param options.getNetworkClientById - Gets the network client for the given networkClientId.
+   * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data
+   * for tracking the NFT added event.
+   * @param options.messenger - The controller messenger.
+   * @param config - Initial options used to configure this controller.
+   * @param state - Initial state to set on this controller.
+   */
+  constructor({
+    chainId: initialChainId,
+    onPreferencesStateChange,
+    onNetworkStateChange,
+    getERC721AssetName,
+    getERC721AssetSymbol,
+    getERC721TokenURI,
+    getERC721OwnerOf,
+    getERC1155BalanceOf,
+    getERC1155TokenURI,
+    getNetworkClientById,
+    onNftAdded,
+    messenger
+  }, config, state) {
+    super(config, state);
+    this.mutex = new (0, _asyncmutex.Mutex)();
+    /**
+     * EventEmitter instance used to listen to specific EIP747 events
+     */
+    this.hub = new (0, _events.EventEmitter)();
+    /**
+     * Name of this controller used during composition
+     */
+    this.name = "NftController";
+    this.defaultConfig = {
+      selectedAddress: "",
+      chainId: initialChainId,
+      ipfsGateway: _controllerutils.IPFS_DEFAULT_GATEWAY_URL,
+      openSeaEnabled: false,
+      useIPFSSubdomains: true,
+      isIpfsGatewayEnabled: true
+    };
+    this.defaultState = getDefaultNftState();
+    this.initialize();
+    this.getERC721AssetName = getERC721AssetName;
+    this.getERC721AssetSymbol = getERC721AssetSymbol;
+    this.getERC721TokenURI = getERC721TokenURI;
+    this.getERC721OwnerOf = getERC721OwnerOf;
+    this.getERC1155BalanceOf = getERC1155BalanceOf;
+    this.getERC1155TokenURI = getERC1155TokenURI;
+    this.getNetworkClientById = getNetworkClientById;
+    this.onNftAdded = onNftAdded;
+    this.messagingSystem = messenger;
+    onPreferencesStateChange(
+      async ({
+        selectedAddress,
+        ipfsGateway,
+        openSeaEnabled,
+        isIpfsGatewayEnabled
+      }) => {
+        this.configure({
+          selectedAddress,
+          ipfsGateway,
+          openSeaEnabled,
+          isIpfsGatewayEnabled
+        });
+        const needsUpdateNftMetadata = isIpfsGatewayEnabled && ipfsGateway !== "" || openSeaEnabled;
+        if (needsUpdateNftMetadata) {
+          const { chainId } = this.config;
+          const nfts = this.state.allNfts[selectedAddress]?.[chainId] ?? [];
+          const nftsToUpdate = nfts.filter(
+            (singleNft) => !singleNft.name && !singleNft.description && !singleNft.image
+          );
+          if (nftsToUpdate.length !== 0) {
+            await this.updateNftMetadata({
+              nfts: nftsToUpdate,
+              userAddress: selectedAddress
+            });
+          }
+        }
+      }
+    );
+    onNetworkStateChange(({ providerConfig }) => {
+      const { chainId } = providerConfig;
+      this.configure({ chainId });
+    });
+  }
+  getNftApi() {
+    return `${_controllerutils.NFT_API_BASE_URL}/tokens`;
+  }
+  /**
+   * Helper method to update nested state for allNfts and allNftContracts.
+   *
+   * @param newCollection - the modified piece of state to update in the controller's store
+   * @param baseStateKey - The root key in the store to update.
+   * @param passedConfig - An object containing the selectedAddress and chainId that are passed through the auto-detection flow.
+   * @param passedConfig.userAddress - the address passed through the NFT detection flow to ensure assets are stored to the correct account
+   * @param passedConfig.chainId - the chainId passed through the NFT detection flow to ensure assets are stored to the correct account
+   */
+  updateNestedNftState(newCollection, baseStateKey, { userAddress, chainId }) {
+    const { [baseStateKey]: oldState } = this.state;
+    const addressState = oldState[userAddress];
+    const newAddressState = {
+      ...addressState,
+      ...{ [chainId]: newCollection }
+    };
+    const newState = {
+      ...oldState,
+      ...{ [userAddress]: newAddressState }
+    };
+    this.update({
+      [baseStateKey]: newState
+    });
+  }
+  /**
+   * Request individual NFT information from NFT API.
+   *
+   * @param contractAddress - Hex address of the NFT contract.
+   * @param tokenId - The NFT identifier.
+   * @returns Promise resolving to the current NFT name and image.
+   */
+  async getNftInformationFromApi(contractAddress, tokenId) {
+    const urlParams = new URLSearchParams({
+      chainIds: "1",
+      tokens: `${contractAddress}:${tokenId}`,
+      includeTopBid: "true",
+      includeAttributes: "true",
+      includeLastSale: "true"
+    }).toString();
+    const nftInformation = await _controllerutils.fetchWithErrorHandling.call(void 0, {
+      url: `${this.getNftApi()}?${urlParams}`,
+      options: {
+        headers: {
+          Version: "1"
+        }
+      }
+    });
+    if (!nftInformation?.tokens?.[0]?.token) {
+      return {
+        name: null,
+        description: null,
+        image: null,
+        standard: null
+      };
+    }
+    const {
+      image,
+      metadata: { imageOriginal } = {},
+      name,
+      description,
+      collection,
+      kind,
+      rarityRank,
+      rarity,
+      attributes,
+      lastSale,
+      imageSmall
+    } = nftInformation.tokens[0].token;
+    const nftMetadata = Object.assign(
+      {},
+      { name: name || null },
+      { description: description || null },
+      { image: image || null },
+      collection?.creator && { creator: collection.creator },
+      imageOriginal && { imageOriginal },
+      imageSmall && { imageThumbnail: imageSmall },
+      kind && { standard: kind.toUpperCase() },
+      lastSale && { lastSale },
+      attributes && { attributes },
+      nftInformation.tokens[0].market?.topBid && {
+        topBid: nftInformation.tokens[0].market?.topBid
+      },
+      rarityRank && { rarityRank },
+      rarity && { rarity },
+      collection && { collection }
+    );
+    return nftMetadata;
+  }
+  /**
+   * Request individual NFT information from contracts that follows Metadata Interface.
+   *
+   * @param contractAddress - Hex address of the NFT contract.
+   * @param tokenId - The NFT identifier.
+   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving to the current NFT name and image.
+   */
+  async getNftInformationFromTokenURI(contractAddress, tokenId, networkClientId) {
+    const { ipfsGateway, useIPFSSubdomains, isIpfsGatewayEnabled } = this.config;
+    const result = await this.getNftURIAndStandard(
+      contractAddress,
+      tokenId,
+      networkClientId
+    );
+    let tokenURI = result[0];
+    const standard = result[1];
+    const hasIpfsTokenURI = tokenURI.startsWith("ipfs://");
+    if (hasIpfsTokenURI && !isIpfsGatewayEnabled) {
+      return {
+        image: null,
+        name: null,
+        description: null,
+        standard: standard || null,
+        favorite: false,
+        tokenURI: tokenURI ?? null
+      };
+    }
+    const isDisplayNFTMediaToggleEnabled = this.config.openSeaEnabled;
+    if (!hasIpfsTokenURI && !isDisplayNFTMediaToggleEnabled) {
+      return {
+        image: null,
+        name: null,
+        description: null,
+        standard: standard || null,
+        favorite: false,
+        tokenURI: tokenURI ?? null
+      };
+    }
+    if (hasIpfsTokenURI) {
+      tokenURI = _chunkLS6R3HQLjs.getFormattedIpfsUrl.call(void 0, ipfsGateway, tokenURI, useIPFSSubdomains);
+    }
+    try {
+      const object = await _controllerutils.handleFetch.call(void 0, tokenURI);
+      const image = Object.prototype.hasOwnProperty.call(object, "image") ? "image" : (
+        /* istanbul ignore next */
+        "image_url"
+      );
+      return {
+        image: object[image],
+        name: object.name,
+        description: object.description,
+        standard,
+        favorite: false,
+        tokenURI: tokenURI ?? null
+      };
+    } catch {
+      return {
+        image: null,
+        name: null,
+        description: null,
+        standard: standard || null,
+        favorite: false,
+        tokenURI: tokenURI ?? null
+      };
+    }
+  }
+  /**
+   * Retrieve NFT uri with  metadata. TODO Update method to use IPFS.
+   *
+   * @param contractAddress - NFT contract address.
+   * @param tokenId - NFT token id.
+   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving NFT uri and token standard.
+   */
+  async getNftURIAndStandard(contractAddress, tokenId, networkClientId) {
+    try {
+      const uri = await this.getERC721TokenURI(
+        contractAddress,
+        tokenId,
+        networkClientId
+      );
+      return [uri, _controllerutils.ERC721];
+    } catch {
+    }
+    try {
+      const tokenURI = await this.getERC1155TokenURI(
+        contractAddress,
+        tokenId,
+        networkClientId
+      );
+      if (!tokenURI.includes("{id}")) {
+        return [tokenURI, _controllerutils.ERC1155];
+      }
+      const hexTokenId = _utils.remove0x.call(void 0, _controllerutils.BNToHex.call(void 0, new (0, _bnjs2.default)(tokenId))).padStart(64, "0").toLowerCase();
+      return [tokenURI.replace("{id}", hexTokenId), _controllerutils.ERC1155];
+    } catch {
+    }
+    return ["", ""];
+  }
+  /**
+   * Request individual NFT information (name, image url and description).
+   *
+   * @param contractAddress - Hex address of the NFT contract.
+   * @param tokenId - The NFT identifier.
+   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving to the current NFT name and image.
+   */
+  async getNftInformation(contractAddress, tokenId, networkClientId) {
+    const chainId = this.getCorrectChainId({
+      networkClientId
+    });
+    const [blockchainMetadata, nftApiMetadata] = await Promise.all([
+      _controllerutils.safelyExecute.call(void 0, 
+        () => this.getNftInformationFromTokenURI(
+          contractAddress,
+          tokenId,
+          networkClientId
+        )
+      ),
+      this.config.openSeaEnabled && chainId === "0x1" ? _controllerutils.safelyExecute.call(void 0, 
+        () => this.getNftInformationFromApi(contractAddress, tokenId)
+      ) : void 0
+    ]);
+    return {
+      ...nftApiMetadata,
+      name: blockchainMetadata?.name ?? nftApiMetadata?.name ?? null,
+      description: blockchainMetadata?.description ?? nftApiMetadata?.description ?? null,
+      image: blockchainMetadata?.image ?? nftApiMetadata?.image ?? null,
+      standard: blockchainMetadata?.standard ?? nftApiMetadata?.standard ?? null,
+      tokenURI: blockchainMetadata?.tokenURI ?? null
+    };
+  }
+  /**
+   * Request NFT contract information from the contract itself.
+   *
+   * @param contractAddress - Hex address of the NFT contract.
+   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving to the current NFT name and image.
+   */
+  async getNftContractInformationFromContract(contractAddress, networkClientId) {
+    const [name, symbol] = await Promise.all([
+      this.getERC721AssetName(contractAddress, networkClientId),
+      this.getERC721AssetSymbol(contractAddress, networkClientId)
+    ]);
+    return {
+      collection: { name },
+      symbol,
+      address: contractAddress
+    };
+  }
+  /**
+   * Request NFT contract information from Blockchain and aggregate with received data from NFTMetadata.
+   *
+   * @param contractAddress - Hex address of the NFT contract.
+   * @param nftMetadataFromApi - Received NFT information to be aggregated with blockchain contract information.
+   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving to the NFT contract name, image and description.
+   */
+  async getNftContractInformation(contractAddress, nftMetadataFromApi, networkClientId) {
+    const blockchainContractData = await _controllerutils.safelyExecute.call(void 0, 
+      () => this.getNftContractInformationFromContract(
+        contractAddress,
+        networkClientId
+      )
+    );
+    if (blockchainContractData || !Object.values(nftMetadataFromApi).every((value) => value === null)) {
+      return {
+        address: contractAddress,
+        ...blockchainContractData,
+        schema_name: nftMetadataFromApi?.standard ?? null,
+        collection: {
+          name: null,
+          image_url: nftMetadataFromApi?.collection?.image ?? nftMetadataFromApi?.collection?.imageUrl ?? null,
+          tokenCount: nftMetadataFromApi?.collection?.tokenCount ?? null,
+          ...nftMetadataFromApi?.collection,
+          ...blockchainContractData?.collection
+        }
+      };
+    }
+    return {
+      address: contractAddress,
+      asset_contract_type: null,
+      created_date: null,
+      schema_name: null,
+      symbol: null,
+      total_supply: null,
+      description: null,
+      external_link: null,
+      collection: { name: null, image_url: null }
+    };
+  }
+  /**
+   * Adds an individual NFT to the stored NFT list.
+   *
+   * @param tokenAddress - Hex address of the NFT contract.
+   * @param tokenId - The NFT identifier.
+   * @param nftMetadata - NFT optional information (name, image and description).
+   * @param nftContract - An object containing contract data of the NFT being added.
+   * @param chainId - The chainId of the network where the NFT is being added.
+   * @param userAddress - The address of the account where the NFT is being added.
+   * @param source - Whether the NFT was detected, added manually or suggested by a dapp.
+   * @returns Promise resolving to the current NFT list.
+   */
+  async addIndividualNft(tokenAddress, tokenId, nftMetadata, nftContract, chainId, userAddress, source) {
+    const releaseLock = await this.mutex.acquire();
+    try {
+      tokenAddress = _controllerutils.toChecksumHexAddress.call(void 0, tokenAddress);
+      const { allNfts } = this.state;
+      const nfts = allNfts[userAddress]?.[chainId] || [];
+      const existingEntry = nfts.find(
+        (nft) => nft.address.toLowerCase() === tokenAddress.toLowerCase() && nft.tokenId === tokenId
+      );
+      if (existingEntry) {
+        const differentMetadata = _chunkLS6R3HQLjs.compareNftMetadata.call(void 0, 
+          nftMetadata,
+          existingEntry
+        );
+        if (differentMetadata || !existingEntry.isCurrentlyOwned) {
+          const indexToRemove = nfts.findIndex(
+            (nft) => nft.address.toLowerCase() === tokenAddress.toLowerCase() && nft.tokenId === tokenId
+          );
+          if (indexToRemove !== -1) {
+            nfts.splice(indexToRemove, 1);
+          }
+        } else {
+          return nfts;
+        }
+      }
+      const newEntry = {
+        address: tokenAddress,
+        tokenId,
+        favorite: existingEntry?.favorite || false,
+        isCurrentlyOwned: true,
+        ...nftMetadata
+      };
+      const newNfts = [...nfts, newEntry];
+      this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+        chainId,
+        userAddress
+      });
+      if (this.onNftAdded) {
+        this.onNftAdded({
+          address: tokenAddress,
+          symbol: nftContract.symbol,
+          tokenId: tokenId.toString(),
+          standard: nftMetadata.standard,
+          source
+        });
+      }
+      return newNfts;
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Adds an NFT contract to the stored NFT contracts list.
+   *
+   * @param options - options.
+   * @param options.tokenAddress - Hex address of the NFT contract.
+   * @param options.userAddress - The address of the account where the NFT is being added.
+   * @param options.nftMetadata - The retrieved NFTMetadata from API.
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
+   * @returns Promise resolving to the current NFT contracts list.
+   */
+  async addNftContract({
+    tokenAddress,
+    userAddress,
+    networkClientId,
+    source,
+    nftMetadata
+  }) {
+    const releaseLock = await this.mutex.acquire();
+    try {
+      tokenAddress = _controllerutils.toChecksumHexAddress.call(void 0, tokenAddress);
+      const { allNftContracts } = this.state;
+      const chainId = this.getCorrectChainId({
+        networkClientId
+      });
+      const nftContracts = allNftContracts[userAddress]?.[chainId] || [];
+      const existingEntry = nftContracts.find(
+        (nftContract) => nftContract.address.toLowerCase() === tokenAddress.toLowerCase()
+      );
+      if (existingEntry) {
+        return nftContracts;
+      }
+      const contractInformation = await this.getNftContractInformation(
+        tokenAddress,
+        nftMetadata,
+        networkClientId
+      );
+      const {
+        asset_contract_type,
+        created_date,
+        symbol,
+        description,
+        external_link,
+        schema_name,
+        collection: { name, image_url, tokenCount }
+      } = contractInformation;
+      if (source === "detected" /* Detected */ && "address" in contractInformation && typeof contractInformation.address === "string" && "collection" in contractInformation && contractInformation.collection.name === null && "image_url" in contractInformation.collection && contractInformation.collection.image_url === null && Object.entries(contractInformation).every(([key, value]) => {
+        return key === "address" || key === "collection" || !value;
+      })) {
+        return nftContracts;
+      }
+      const newEntry = Object.assign(
+        {},
+        { address: tokenAddress },
+        description && { description },
+        name && { name },
+        image_url && { logo: image_url },
+        symbol && { symbol },
+        tokenCount !== null && typeof tokenCount !== "undefined" && { totalSupply: tokenCount },
+        asset_contract_type && { assetContractType: asset_contract_type },
+        created_date && { createdDate: created_date },
+        schema_name && { schemaName: schema_name },
+        external_link && { externalLink: external_link }
+      );
+      const newNftContracts = [...nftContracts, newEntry];
+      this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {
+        chainId,
+        userAddress
+      });
+      return newNftContracts;
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Removes an individual NFT from the stored token list and saves it in ignored NFTs list.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - Token identifier of the NFT.
+   * @param options - options.
+   * @param options.chainId - The chainId of the network where the NFT is being removed.
+   * @param options.userAddress - The address of the account where the NFT is being removed.
+   */
+  removeAndIgnoreIndividualNft(address, tokenId, {
+    chainId,
+    userAddress
+  }) {
+    address = _controllerutils.toChecksumHexAddress.call(void 0, address);
+    const { allNfts, ignoredNfts } = this.state;
+    const newIgnoredNfts = [...ignoredNfts];
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const newNfts = nfts.filter((nft) => {
+      if (nft.address.toLowerCase() === address.toLowerCase() && nft.tokenId === tokenId) {
+        const alreadyIgnored = newIgnoredNfts.find(
+          (c) => c.address === address && c.tokenId === tokenId
+        );
+        !alreadyIgnored && newIgnoredNfts.push(nft);
+        return false;
+      }
+      return true;
+    });
+    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+      userAddress,
+      chainId
+    });
+    this.update({
+      ignoredNfts: newIgnoredNfts
+    });
+  }
+  /**
+   * Removes an individual NFT from the stored token list.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - Token identifier of the NFT.
+   * @param options - options.
+   * @param options.chainId - The chainId of the network where the NFT is being removed.
+   * @param options.userAddress - The address of the account where the NFT is being removed.
+   */
+  removeIndividualNft(address, tokenId, { chainId, userAddress }) {
+    address = _controllerutils.toChecksumHexAddress.call(void 0, address);
+    const { allNfts } = this.state;
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const newNfts = nfts.filter(
+      (nft) => !(nft.address.toLowerCase() === address.toLowerCase() && nft.tokenId === tokenId)
+    );
+    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+      userAddress,
+      chainId
+    });
+  }
+  /**
+   * Removes an NFT contract to the stored NFT contracts list.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param options - options.
+   * @param options.chainId - The chainId of the network where the NFT is being removed.
+   * @param options.userAddress - The address of the account where the NFT is being removed.
+   * @returns Promise resolving to the current NFT contracts list.
+   */
+  removeNftContract(address, { chainId, userAddress }) {
+    address = _controllerutils.toChecksumHexAddress.call(void 0, address);
+    const { allNftContracts } = this.state;
+    const nftContracts = allNftContracts[userAddress]?.[chainId] || [];
+    const newNftContracts = nftContracts.filter(
+      (nftContract) => !(nftContract.address.toLowerCase() === address.toLowerCase())
+    );
+    this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {
+      chainId,
+      userAddress
+    });
+    return newNftContracts;
+  }
+  async validateWatchNft(asset, type, userAddress, { networkClientId } = {}) {
+    const { address: contractAddress, tokenId } = asset;
+    if (!type) {
+      throw _rpcerrors.rpcErrors.invalidParams("Asset type is required");
+    }
+    if (type !== _controllerutils.ERC721 && type !== _controllerutils.ERC1155) {
+      throw _rpcerrors.rpcErrors.invalidParams(
+        `Non NFT asset type ${type} not supported by watchNft`
+      );
+    }
+    if (!contractAddress || !tokenId) {
+      throw _rpcerrors.rpcErrors.invalidParams("Both address and tokenId are required");
+    }
+    if (!_address.isAddress.call(void 0, contractAddress)) {
+      throw _rpcerrors.rpcErrors.invalidParams("Invalid address");
+    }
+    if (!/^\d+$/u.test(tokenId)) {
+      throw _rpcerrors.rpcErrors.invalidParams("Invalid tokenId");
+    }
+    try {
+      const isOwner = await this.isNftOwner(
+        userAddress,
+        contractAddress,
+        tokenId,
+        { networkClientId }
+      );
+      if (!isOwner) {
+        throw _rpcerrors.rpcErrors.invalidInput(
+          "Suggested NFT is not owned by the selected account"
+        );
+      }
+    } catch (error) {
+      if (error instanceof Error) {
+        throw _rpcerrors.rpcErrors.resourceUnavailable(error.message);
+      }
+      throw error;
+    }
+  }
+  // temporary method to get the correct chainId until we remove chainId from the config & the chainId arg from the detection logic
+  // Just a helper method to prefer the networkClient chainId first then the chainId argument and then finally the config chainId
+  getCorrectChainId({
+    networkClientId
+  }) {
+    if (networkClientId) {
+      return this.getNetworkClientById(networkClientId).configuration.chainId;
+    }
+    return this.config.chainId;
+  }
+  /**
+   * Adds a new suggestedAsset to state. Parameters will be validated according to
+   * asset type being watched. A `<suggestedNftMeta.id>:pending` hub event will be emitted once added.
+   *
+   * @param asset - The asset to be watched. For now ERC721 and ERC1155 tokens are accepted.
+   * @param asset.address - The address of the asset contract.
+   * @param asset.tokenId - The ID of the asset.
+   * @param type - The asset type.
+   * @param origin - Domain origin to register the asset from.
+   * @param options - Options bag.
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.userAddress - The address of the account where the NFT is being added.
+   * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.
+   */
+  async watchNft(asset, type, origin, {
+    networkClientId,
+    userAddress = this.config.selectedAddress
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    await this.validateWatchNft(asset, type, userAddress);
+    const nftMetadata = await this.getNftInformation(
+      asset.address,
+      asset.tokenId,
+      networkClientId
+    );
+    if (nftMetadata.standard && nftMetadata.standard !== type) {
+      throw _rpcerrors.rpcErrors.invalidInput(
+        `Suggested NFT of type ${nftMetadata.standard} does not match received type ${type}`
+      );
+    }
+    const suggestedNftMeta = {
+      asset: { ...asset, ...nftMetadata },
+      type,
+      id: _uuid.v4.call(void 0, ),
+      time: Date.now(),
+      interactingAddress: userAddress,
+      origin
+    };
+    await this._requestApproval(suggestedNftMeta);
+    const { address, tokenId } = asset;
+    const { name, standard, description, image } = nftMetadata;
+    await this.addNft(address, tokenId, {
+      nftMetadata: {
+        name: name ?? null,
+        description: description ?? null,
+        image: image ?? null,
+        standard: standard ?? null
+      },
+      userAddress,
+      source: "dapp" /* Dapp */,
+      networkClientId
+    });
+  }
+  /**
+   * Sets an OpenSea API key to retrieve NFT information.
+   *
+   * @param openSeaApiKey - OpenSea API key.
+   */
+  setApiKey(openSeaApiKey) {
+    this.openSeaApiKey = openSeaApiKey;
+  }
+  /**
+   * Checks the ownership of a ERC-721 or ERC-1155 NFT for a given address.
+   *
+   * @param ownerAddress - User public address.
+   * @param nftAddress - NFT contract address.
+   * @param tokenId - NFT token ID.
+   * @param options - Options bag.
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving the NFT ownership.
+   */
+  async isNftOwner(ownerAddress, nftAddress, tokenId, {
+    networkClientId
+  } = {}) {
+    try {
+      const owner = await this.getERC721OwnerOf(
+        nftAddress,
+        tokenId,
+        networkClientId
+      );
+      return ownerAddress.toLowerCase() === owner.toLowerCase();
+    } catch {
+    }
+    try {
+      const balance = await this.getERC1155BalanceOf(
+        ownerAddress,
+        nftAddress,
+        tokenId,
+        networkClientId
+      );
+      return !balance.isZero();
+    } catch {
+    }
+    throw new Error(
+      `Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.`
+    );
+  }
+  /**
+   * Verifies currently selected address owns entered NFT address/tokenId combo and
+   * adds the NFT and respective NFT contract to the stored NFT and NFT contracts lists.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - The NFT identifier.
+   * @param options - an object of arguments
+   * @param options.userAddress - The address of the current user.
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
+   */
+  async addNftVerifyOwnership(address, tokenId, {
+    userAddress = this.config.selectedAddress,
+    networkClientId,
+    source
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    if (!await this.isNftOwner(userAddress, address, tokenId, {
+      networkClientId
+    })) {
+      throw new Error("This NFT is not owned by the user");
+    }
+    await this.addNft(address, tokenId, {
+      networkClientId,
+      userAddress,
+      source
+    });
+  }
+  /**
+   * Adds an NFT and respective NFT contract to the stored NFT and NFT contracts lists.
+   *
+   * @param tokenAddress - Hex address of the NFT contract.
+   * @param tokenId - The NFT identifier.
+   * @param options - an object of arguments
+   * @param options.nftMetadata - NFT optional metadata.
+   * @param options.userAddress - The address of the current user.
+   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving to the current NFT list.
+   */
+  async addNft(tokenAddress, tokenId, {
+    nftMetadata,
+    userAddress = this.config.selectedAddress,
+    source = "custom" /* Custom */,
+    networkClientId
+  } = { userAddress: this.config.selectedAddress }) {
+    tokenAddress = _controllerutils.toChecksumHexAddress.call(void 0, tokenAddress);
+    const chainId = this.getCorrectChainId({ networkClientId });
+    nftMetadata = nftMetadata || await this.getNftInformation(tokenAddress, tokenId, networkClientId);
+    const newNftContracts = await this.addNftContract({
+      tokenAddress,
+      userAddress,
+      networkClientId,
+      source,
+      nftMetadata
+    });
+    const nftContract = newNftContracts.find(
+      (contract) => contract.address.toLowerCase() === tokenAddress.toLowerCase()
+    );
+    if (nftContract) {
+      await this.addIndividualNft(
+        tokenAddress,
+        tokenId,
+        nftMetadata,
+        nftContract,
+        chainId,
+        userAddress,
+        source
+      );
+    }
+  }
+  /**
+   * Refetches NFT metadata and updates the state
+   *
+   * @param options - Options for refetching NFT metadata
+   * @param options.nfts - nfts to update metadata for.
+   * @param options.userAddress - The current user address
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   */
+  async updateNftMetadata({
+    nfts,
+    userAddress = this.config.selectedAddress,
+    networkClientId
+  }) {
+    const chainId = this.getCorrectChainId({ networkClientId });
+    const nftsWithChecksumAdr = nfts.map((nft) => {
+      return {
+        ...nft,
+        address: _controllerutils.toChecksumHexAddress.call(void 0, nft.address)
+      };
+    });
+    const nftMetadataResults = await Promise.allSettled(
+      nftsWithChecksumAdr.map(async (nft) => {
+        const resMetadata = await this.getNftInformation(
+          nft.address,
+          nft.tokenId,
+          networkClientId
+        );
+        return {
+          nft,
+          newMetadata: resMetadata
+        };
+      })
+    );
+    const successfulNewFetchedNfts = nftMetadataResults.filter(
+      (result) => result.status === "fulfilled"
+    );
+    const nftsWithDifferentMetadata = [];
+    const { allNfts } = this.state;
+    const stateNfts = allNfts[userAddress]?.[chainId] || [];
+    successfulNewFetchedNfts.forEach((singleNft) => {
+      const existingEntry = stateNfts.find(
+        (nft) => nft.address.toLowerCase() === singleNft.value.nft.address.toLowerCase() && nft.tokenId === singleNft.value.nft.tokenId
+      );
+      if (existingEntry) {
+        const differentMetadata = _chunkLS6R3HQLjs.compareNftMetadata.call(void 0, 
+          singleNft.value.newMetadata,
+          existingEntry
+        );
+        if (differentMetadata) {
+          nftsWithDifferentMetadata.push(singleNft);
+        }
+      }
+    });
+    if (nftsWithDifferentMetadata.length !== 0) {
+      nftsWithDifferentMetadata.forEach(
+        (elm) => this.updateNft(
+          elm.value.nft,
+          elm.value.newMetadata,
+          userAddress,
+          chainId
+        )
+      );
+    }
+  }
+  /**
+   * Removes an NFT from the stored token list.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - Token identifier of the NFT.
+   * @param options - an object of arguments
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.userAddress - The address of the account where the NFT is being removed.
+   */
+  removeNft(address, tokenId, {
+    networkClientId,
+    userAddress = this.config.selectedAddress
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    const chainId = this.getCorrectChainId({ networkClientId });
+    address = _controllerutils.toChecksumHexAddress.call(void 0, address);
+    this.removeIndividualNft(address, tokenId, { chainId, userAddress });
+    const { allNfts } = this.state;
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const remainingNft = nfts.find(
+      (nft) => nft.address.toLowerCase() === address.toLowerCase()
+    );
+    if (!remainingNft) {
+      this.removeNftContract(address, { chainId, userAddress });
+    }
+  }
+  /**
+   * Removes an NFT from the stored token list and saves it in ignored NFTs list.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - Token identifier of the NFT.
+   * @param options - an object of arguments
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.userAddress - The address of the account where the NFT is being removed.
+   */
+  removeAndIgnoreNft(address, tokenId, {
+    networkClientId,
+    userAddress = this.config.selectedAddress
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    const chainId = this.getCorrectChainId({ networkClientId });
+    address = _controllerutils.toChecksumHexAddress.call(void 0, address);
+    this.removeAndIgnoreIndividualNft(address, tokenId, {
+      chainId,
+      userAddress
+    });
+    const { allNfts } = this.state;
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const remainingNft = nfts.find(
+      (nft) => nft.address.toLowerCase() === address.toLowerCase()
+    );
+    if (!remainingNft) {
+      this.removeNftContract(address, { chainId, userAddress });
+    }
+  }
+  /**
+   * Removes all NFTs from the ignored list.
+   */
+  clearIgnoredNfts() {
+    this.update({ ignoredNfts: [] });
+  }
+  /**
+   * Checks whether input NFT is still owned by the user
+   * And updates the isCurrentlyOwned value on the NFT object accordingly.
+   *
+   * @param nft - The NFT object to check and update.
+   * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.
+   * @param accountParams - The userAddress and chainId to check ownership against
+   * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure assets are stored to the correct account
+   * @param accountParams.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns the NFT with the updated isCurrentlyOwned value
+   */
+  async checkAndUpdateSingleNftOwnershipStatus(nft, batch, {
+    userAddress = this.config.selectedAddress,
+    networkClientId
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    const chainId = this.getCorrectChainId({ networkClientId });
+    const { address, tokenId } = nft;
+    let isOwned = nft.isCurrentlyOwned;
+    try {
+      isOwned = await this.isNftOwner(userAddress, address, tokenId, {
+        networkClientId
+      });
+    } catch {
+    }
+    nft.isCurrentlyOwned = isOwned;
+    if (batch) {
+      return nft;
+    }
+    const { allNfts } = this.state;
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const nftToUpdate = nfts.find(
+      (item) => item.tokenId === tokenId && item.address.toLowerCase() === address.toLowerCase()
+    );
+    if (nftToUpdate) {
+      nftToUpdate.isCurrentlyOwned = isOwned;
+      this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {
+        userAddress,
+        chainId
+      });
+    }
+    return nft;
+  }
+  /**
+   * Checks whether NFTs associated with current selectedAddress/chainId combination are still owned by the user
+   * And updates the isCurrentlyOwned value on each accordingly.
+   * @param options - an object of arguments
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.userAddress - The address of the account where the NFT ownership status is checked/updated.
+   */
+  async checkAndUpdateAllNftsOwnershipStatus({
+    networkClientId,
+    userAddress = this.config.selectedAddress
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    const chainId = this.getCorrectChainId({ networkClientId });
+    const { allNfts } = this.state;
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const updatedNfts = await Promise.all(
+      nfts.map(async (nft) => {
+        return await this.checkAndUpdateSingleNftOwnershipStatus(nft, true, {
+          networkClientId,
+          userAddress
+        }) ?? nft;
+      })
+    );
+    this.updateNestedNftState(updatedNfts, ALL_NFTS_STATE_KEY, {
+      userAddress,
+      chainId
+    });
+  }
+  /**
+   * Update NFT favorite status.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - Hex address of the NFT contract.
+   * @param favorite - NFT new favorite status.
+   * @param options - an object of arguments
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.userAddress - The address of the account where the NFT is being removed.
+   */
+  updateNftFavoriteStatus(address, tokenId, favorite, {
+    networkClientId,
+    userAddress = this.config.selectedAddress
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    const chainId = this.getCorrectChainId({ networkClientId });
+    const { allNfts } = this.state;
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const index = nfts.findIndex(
+      (nft) => nft.address === address && nft.tokenId === tokenId
+    );
+    if (index === -1) {
+      return;
+    }
+    const updatedNft = {
+      ...nfts[index],
+      favorite
+    };
+    nfts[index] = updatedNft;
+    this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {
+      chainId,
+      userAddress
+    });
+  }
+  /**
+   * Returns an NFT by the address and token id.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - Number that represents the id of the token.
+   * @param selectedAddress - Hex address of the user account.
+   * @param chainId - Id of the current network.
+   * @returns Object containing the NFT and its position in the array
+   */
+  findNftByAddressAndTokenId(address, tokenId, selectedAddress, chainId) {
+    const { allNfts } = this.state;
+    const nfts = allNfts[selectedAddress]?.[chainId] || [];
+    const index = nfts.findIndex(
+      (nft) => nft.address.toLowerCase() === address.toLowerCase() && nft.tokenId === tokenId
+    );
+    if (index === -1) {
+      return null;
+    }
+    return { nft: nfts[index], index };
+  }
+  /**
+   * Update NFT data.
+   *
+   * @param nft - NFT object to find the right NFT to updates.
+   * @param updates - NFT partial object to update properties of the NFT.
+   * @param selectedAddress - Hex address of the user account.
+   * @param chainId - Id of the current network.
+   */
+  updateNft(nft, updates, selectedAddress, chainId) {
+    const { allNfts } = this.state;
+    const nfts = allNfts[selectedAddress]?.[chainId] || [];
+    const nftInfo = this.findNftByAddressAndTokenId(
+      nft.address,
+      nft.tokenId,
+      selectedAddress,
+      chainId
+    );
+    if (!nftInfo) {
+      return;
+    }
+    const updatedNft = {
+      ...nft,
+      ...updates
+    };
+    const newNfts = [
+      ...nfts.slice(0, nftInfo.index),
+      updatedNft,
+      ...nfts.slice(nftInfo.index + 1)
+    ];
+    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+      chainId,
+      userAddress: selectedAddress
+    });
+  }
+  /**
+   * Resets the transaction status of an NFT.
+   *
+   * @param transactionId - NFT transaction id.
+   * @param selectedAddress - Hex address of the user account.
+   * @param chainId - Id of the current network.
+   * @returns a boolean indicating if the reset was well succeeded or not
+   */
+  resetNftTransactionStatusByTransactionId(transactionId, selectedAddress, chainId) {
+    const { allNfts } = this.state;
+    const nfts = allNfts[selectedAddress]?.[chainId] || [];
+    const index = nfts.findIndex(
+      (nft) => nft.transactionId === transactionId
+    );
+    if (index === -1) {
+      return false;
+    }
+    const updatedNft = {
+      ...nfts[index],
+      transactionId: void 0
+    };
+    const newNfts = [
+      ...nfts.slice(0, index),
+      updatedNft,
+      ...nfts.slice(index + 1)
+    ];
+    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+      chainId,
+      userAddress: selectedAddress
+    });
+    return true;
+  }
+  async _requestApproval(suggestedNftMeta) {
+    return this.messagingSystem.call(
+      "ApprovalController:addRequest",
+      {
+        id: suggestedNftMeta.id,
+        origin: suggestedNftMeta.origin,
+        type: _controllerutils.ApprovalType.WatchAsset,
+        requestData: {
+          id: suggestedNftMeta.id,
+          interactingAddress: suggestedNftMeta.interactingAddress,
+          asset: {
+            address: suggestedNftMeta.asset.address,
+            tokenId: suggestedNftMeta.asset.tokenId,
+            name: suggestedNftMeta.asset.name,
+            description: suggestedNftMeta.asset.description,
+            image: suggestedNftMeta.asset.image,
+            standard: suggestedNftMeta.asset.standard
+          }
+        }
+      },
+      true
+    );
+  }
+};
+var NftController_default = NftController;
+
+
+
+
+
+exports.getDefaultNftState = getDefaultNftState; exports.NftController = NftController; exports.NftController_default = NftController_default;
+//# sourceMappingURL=chunk-F2F3NGG3.js.map
\ No newline at end of file
diff --git a/dist/chunk-F2F3NGG3.js.map b/dist/chunk-F2F3NGG3.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..f23a4c481d0540bb90d6c8da311a3e12888bb6e5
--- /dev/null
+++ b/dist/chunk-F2F3NGG3.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/NftController.ts"],"names":[],"mappings":"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","sourcesContent":["import { isAddress } from '@ethersproject/address';\nimport type { AddApprovalRequest } from '@metamask/approval-controller';\nimport type {\n  BaseConfig,\n  BaseState,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseControllerV1 } from '@metamask/base-controller';\nimport {\n  safelyExecute,\n  handleFetch,\n  toChecksumHexAddress,\n  BNToHex,\n  fetchWithErrorHandling,\n  IPFS_DEFAULT_GATEWAY_URL,\n  ERC721,\n  ERC1155,\n  ApprovalType,\n  NFT_API_BASE_URL,\n} from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkState,\n} from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { Hex } from '@metamask/utils';\nimport { remove0x } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport BN from 'bn.js';\nimport { EventEmitter } from 'events';\nimport { v4 as random } from 'uuid';\n\nimport type { AssetsContractController } from './AssetsContractController';\nimport { compareNftMetadata, getFormattedIpfsUrl } from './assetsUtil';\nimport { Source } from './constants';\nimport type {\n  ApiNftContract,\n  ReservoirResponse,\n  Collection,\n  Attributes,\n  LastSale,\n} from './NftDetectionController';\n\ntype NFTStandardType = 'ERC721' | 'ERC1155';\n\ntype SuggestedNftMeta = {\n  asset: { address: string; tokenId: string } & NftMetadata;\n  id: string;\n  time: number;\n  type: NFTStandardType;\n  interactingAddress: string;\n  origin: string;\n};\n\n/**\n * @type Nft\n *\n * NFT representation\n * @property address - Hex address of a ERC721 contract\n * @property description - The NFT description\n * @property image - URI of custom NFT image associated with this tokenId\n * @property name - Name associated with this tokenId and contract address\n * @property tokenId - The NFT identifier\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property isCurrentlyOwned - Boolean indicating whether the address/chainId combination where it's currently stored currently owns this NFT\n * @property transactionId - Transaction Id associated with the NFT\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface Nft extends NftMetadata {\n  tokenId: string;\n  address: string;\n  isCurrentlyOwned?: boolean;\n}\n\ntype NftUpdate = {\n  nft: Nft;\n  newMetadata: NftMetadata;\n};\n\n/**\n * @type NftContract\n *\n * NFT contract information representation\n * @property name - Contract name\n * @property logo - Contract logo\n * @property address - Contract address\n * @property symbol - Contract symbol\n * @property description - Contract description\n * @property totalSupply - Total supply of NFTs\n * @property assetContractType - The NFT type, it could be `semi-fungible` or `non-fungible`\n * @property createdDate - Creation date\n * @property schemaName - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property externalLink - External link containing additional information\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftContract {\n  name?: string;\n  logo?: string;\n  address: string;\n  symbol?: string;\n  description?: string;\n  totalSupply?: string;\n  assetContractType?: string;\n  createdDate?: string;\n  schemaName?: string;\n  externalLink?: string;\n}\n\n/**\n * @type NftMetadata\n *\n * NFT custom information\n * @property name - NFT custom name\n * @property description - The NFT description\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property image - Image custom image URI\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property standard - NFT standard name for the NFT, e.g., ERC-721 or ERC-1155\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftMetadata {\n  name: string | null;\n  description: string | null;\n  image: string | null;\n  standard: string | null;\n  favorite?: boolean;\n  numberOfSales?: number;\n  backgroundColor?: string;\n  imagePreview?: string;\n  imageThumbnail?: string;\n  imageOriginal?: string;\n  animation?: string;\n  animationOriginal?: string;\n  externalLink?: string;\n  creator?: string;\n  transactionId?: string;\n  tokenURI?: string | null;\n  collection?: Collection;\n  address?: string;\n  attributes?: Attributes;\n  lastSale?: LastSale;\n  rarityRank?: string;\n}\n\n/**\n * @type NftConfig\n *\n * NFT controller configuration\n * @property selectedAddress - Vault selected address\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftConfig extends BaseConfig {\n  selectedAddress: string;\n  chainId: Hex;\n  ipfsGateway: string;\n  openSeaEnabled: boolean;\n  useIPFSSubdomains: boolean;\n  isIpfsGatewayEnabled: boolean;\n}\n\n/**\n * @type NftState\n *\n * NFT controller state\n * @property allNftContracts - Object containing NFT contract information\n * @property allNfts - Object containing NFTs per account and network\n * @property ignoredNfts - List of NFTs that should be ignored\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftState extends BaseState {\n  allNftContracts: {\n    [key: string]: { [chainId: Hex]: NftContract[] };\n  };\n  allNfts: { [key: string]: { [chainId: Hex]: Nft[] } };\n  ignoredNfts: Nft[];\n}\n\nconst ALL_NFTS_STATE_KEY = 'allNfts';\nconst ALL_NFTS_CONTRACTS_STATE_KEY = 'allNftContracts';\n\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\ninterface NftAsset {\n  address: string;\n  tokenId: string;\n}\n\n/**\n * The name of the {@link NftController}.\n */\nconst controllerName = 'NftController';\n\n/**\n * The external actions available to the {@link NftController}.\n */\ntype AllowedActions = AddApprovalRequest;\n\n/**\n * The messenger of the {@link NftController}.\n */\nexport type NftControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  AllowedActions,\n  never,\n  AllowedActions['type'],\n  never\n>;\n\nexport const getDefaultNftState = (): NftState => {\n  return {\n    allNftContracts: {},\n    allNfts: {},\n    ignoredNfts: [],\n  };\n};\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class NftController extends BaseControllerV1<NftConfig, NftState> {\n  private readonly mutex = new Mutex();\n\n  private readonly messagingSystem: NftControllerMessenger;\n\n  getNftApi() {\n    return `${NFT_API_BASE_URL}/tokens`;\n  }\n\n  /**\n   * Helper method to update nested state for allNfts and allNftContracts.\n   *\n   * @param newCollection - the modified piece of state to update in the controller's store\n   * @param baseStateKey - The root key in the store to update.\n   * @param passedConfig - An object containing the selectedAddress and chainId that are passed through the auto-detection flow.\n   * @param passedConfig.userAddress - the address passed through the NFT detection flow to ensure assets are stored to the correct account\n   * @param passedConfig.chainId - the chainId passed through the NFT detection flow to ensure assets are stored to the correct account\n   */\n  private updateNestedNftState(\n    newCollection: Nft[] | NftContract[],\n    baseStateKey: 'allNfts' | 'allNftContracts',\n    { userAddress, chainId }: { userAddress: string; chainId: Hex },\n  ) {\n    const { [baseStateKey]: oldState } = this.state;\n\n    const addressState = oldState[userAddress];\n    const newAddressState = {\n      ...addressState,\n      ...{ [chainId]: newCollection },\n    };\n    const newState = {\n      ...oldState,\n      ...{ [userAddress]: newAddressState },\n    };\n    this.update({\n      [baseStateKey]: newState,\n    });\n  }\n\n  /**\n   * Request individual NFT information from NFT API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromApi(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<NftMetadata> {\n    // TODO Parameterize this by chainId for non-mainnet token detection\n    // Attempt to fetch the data with the nft-api\n    const urlParams = new URLSearchParams({\n      chainIds: '1',\n      tokens: `${contractAddress}:${tokenId}`,\n      includeTopBid: 'true',\n      includeAttributes: 'true',\n      includeLastSale: 'true',\n    }).toString();\n    const nftInformation: ReservoirResponse | undefined =\n      await fetchWithErrorHandling({\n        url: `${this.getNftApi()}?${urlParams}`,\n        options: {\n          headers: {\n            Version: '1',\n          },\n        },\n      });\n    // if we were still unable to fetch the data we return out the default/null of `NftMetadata`\n    if (!nftInformation?.tokens?.[0]?.token) {\n      return {\n        name: null,\n        description: null,\n        image: null,\n        standard: null,\n      };\n    }\n\n    // if we've reached this point, we have successfully fetched some data for nftInformation\n    // now we reconfigure the data to conform to the `NftMetadata` type for storage.\n\n    const {\n      image,\n      metadata: { imageOriginal } = {},\n      name,\n      description,\n      collection,\n      kind,\n      rarityRank,\n      rarity,\n      attributes,\n      lastSale,\n      imageSmall,\n    } = nftInformation.tokens[0].token;\n\n    /* istanbul ignore next */\n    const nftMetadata: NftMetadata = Object.assign(\n      {},\n      { name: name || null },\n      { description: description || null },\n      { image: image || null },\n      collection?.creator && { creator: collection.creator },\n      imageOriginal && { imageOriginal },\n      imageSmall && { imageThumbnail: imageSmall },\n      kind && { standard: kind.toUpperCase() },\n      lastSale && { lastSale },\n      attributes && { attributes },\n      nftInformation.tokens[0].market?.topBid && {\n        topBid: nftInformation.tokens[0].market?.topBid,\n      },\n      rarityRank && { rarityRank },\n      rarity && { rarity },\n      collection && { collection },\n    );\n\n    return nftMetadata;\n  }\n\n  /**\n   * Request individual NFT information from contracts that follows Metadata Interface.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromTokenURI(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<NftMetadata> {\n    const { ipfsGateway, useIPFSSubdomains, isIpfsGatewayEnabled } =\n      this.config;\n    const result = await this.getNftURIAndStandard(\n      contractAddress,\n      tokenId,\n      networkClientId,\n    );\n    let tokenURI = result[0];\n    const standard = result[1];\n\n    const hasIpfsTokenURI = tokenURI.startsWith('ipfs://');\n\n    if (hasIpfsTokenURI && !isIpfsGatewayEnabled) {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n\n    const isDisplayNFTMediaToggleEnabled = this.config.openSeaEnabled;\n    if (!hasIpfsTokenURI && !isDisplayNFTMediaToggleEnabled) {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n\n    if (hasIpfsTokenURI) {\n      tokenURI = getFormattedIpfsUrl(ipfsGateway, tokenURI, useIPFSSubdomains);\n    }\n\n    try {\n      const object = await handleFetch(tokenURI);\n      // TODO: Check image_url existence. This is not part of EIP721 nor EIP1155\n      const image = Object.prototype.hasOwnProperty.call(object, 'image')\n        ? 'image'\n        : /* istanbul ignore next */ 'image_url';\n\n      return {\n        image: object[image],\n        name: object.name,\n        description: object.description,\n        standard,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    } catch {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n  }\n\n  /**\n   * Retrieve NFT uri with  metadata. TODO Update method to use IPFS.\n   *\n   * @param contractAddress - NFT contract address.\n   * @param tokenId - NFT token id.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving NFT uri and token standard.\n   */\n  private async getNftURIAndStandard(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<[string, string]> {\n    // try ERC721 uri\n    try {\n      const uri = await this.getERC721TokenURI(\n        contractAddress,\n        tokenId,\n        networkClientId,\n      );\n      return [uri, ERC721];\n    } catch {\n      // Ignore error\n    }\n\n    // try ERC1155 uri\n    try {\n      const tokenURI = await this.getERC1155TokenURI(\n        contractAddress,\n        tokenId,\n        networkClientId,\n      );\n\n      /**\n       * According to EIP1155 the URI value allows for ID substitution\n       * in case the string `{id}` exists.\n       * https://eips.ethereum.org/EIPS/eip-1155#metadata\n       */\n\n      if (!tokenURI.includes('{id}')) {\n        return [tokenURI, ERC1155];\n      }\n\n      const hexTokenId = remove0x(BNToHex(new BN(tokenId)))\n        .padStart(64, '0')\n        .toLowerCase();\n      return [tokenURI.replace('{id}', hexTokenId), ERC1155];\n    } catch {\n      // Ignore error\n    }\n\n    return ['', ''];\n  }\n\n  /**\n   * Request individual NFT information (name, image url and description).\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformation(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<NftMetadata> {\n    const chainId = this.getCorrectChainId({\n      networkClientId,\n    });\n    const [blockchainMetadata, nftApiMetadata] = await Promise.all([\n      safelyExecute(() =>\n        this.getNftInformationFromTokenURI(\n          contractAddress,\n          tokenId,\n          networkClientId,\n        ),\n      ),\n      this.config.openSeaEnabled && chainId === '0x1'\n        ? safelyExecute(() =>\n            this.getNftInformationFromApi(contractAddress, tokenId),\n          )\n        : undefined,\n    ]);\n    return {\n      ...nftApiMetadata,\n      name: blockchainMetadata?.name ?? nftApiMetadata?.name ?? null,\n      description:\n        blockchainMetadata?.description ?? nftApiMetadata?.description ?? null,\n      image: blockchainMetadata?.image ?? nftApiMetadata?.image ?? null,\n      standard:\n        blockchainMetadata?.standard ?? nftApiMetadata?.standard ?? null,\n      tokenURI: blockchainMetadata?.tokenURI ?? null,\n    };\n  }\n\n  /**\n   * Request NFT contract information from the contract itself.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftContractInformationFromContract(\n    contractAddress: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const [name, symbol] = await Promise.all([\n      this.getERC721AssetName(contractAddress, networkClientId),\n      this.getERC721AssetSymbol(contractAddress, networkClientId),\n    ]);\n\n    return {\n      collection: { name },\n      symbol,\n      address: contractAddress,\n    };\n  }\n\n  /**\n   * Request NFT contract information from Blockchain and aggregate with received data from NFTMetadata.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param nftMetadataFromApi - Received NFT information to be aggregated with blockchain contract information.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the NFT contract name, image and description.\n   */\n  private async getNftContractInformation(\n    contractAddress: string,\n    nftMetadataFromApi: NftMetadata,\n    networkClientId?: NetworkClientId,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const blockchainContractData = await safelyExecute(() =>\n      this.getNftContractInformationFromContract(\n        contractAddress,\n        networkClientId,\n      ),\n    );\n\n    if (\n      blockchainContractData ||\n      !Object.values(nftMetadataFromApi).every((value) => value === null)\n    ) {\n      return {\n        address: contractAddress,\n        ...blockchainContractData,\n        schema_name: nftMetadataFromApi?.standard ?? null,\n        collection: {\n          name: null,\n          image_url:\n            nftMetadataFromApi?.collection?.image ??\n            nftMetadataFromApi?.collection?.imageUrl ??\n            null,\n          tokenCount: nftMetadataFromApi?.collection?.tokenCount ?? null,\n          ...nftMetadataFromApi?.collection,\n          ...blockchainContractData?.collection,\n        },\n      };\n    }\n\n    /* istanbul ignore next */\n    return {\n      address: contractAddress,\n      asset_contract_type: null,\n      created_date: null,\n      schema_name: null,\n      symbol: null,\n      total_supply: null,\n      description: null,\n      external_link: null,\n      collection: { name: null, image_url: null },\n    };\n  }\n\n  /**\n   * Adds an individual NFT to the stored NFT list.\n   *\n   * @param tokenAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param nftMetadata - NFT optional information (name, image and description).\n   * @param nftContract - An object containing contract data of the NFT being added.\n   * @param chainId - The chainId of the network where the NFT is being added.\n   * @param userAddress - The address of the account where the NFT is being added.\n   * @param source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @returns Promise resolving to the current NFT list.\n   */\n  private async addIndividualNft(\n    tokenAddress: string,\n    tokenId: string,\n    nftMetadata: NftMetadata,\n    nftContract: NftContract,\n    chainId: Hex,\n    userAddress: string,\n    source: Source,\n  ): Promise<Nft[]> {\n    // TODO: Remove unused return\n    const releaseLock = await this.mutex.acquire();\n    try {\n      tokenAddress = toChecksumHexAddress(tokenAddress);\n      const { allNfts } = this.state;\n\n      const nfts = allNfts[userAddress]?.[chainId] || [];\n\n      const existingEntry: Nft | undefined = nfts.find(\n        (nft) =>\n          nft.address.toLowerCase() === tokenAddress.toLowerCase() &&\n          nft.tokenId === tokenId,\n      );\n\n      if (existingEntry) {\n        const differentMetadata = compareNftMetadata(\n          nftMetadata,\n          existingEntry,\n        );\n        if (differentMetadata || !existingEntry.isCurrentlyOwned) {\n          // TODO: Switch to indexToUpdate\n          const indexToRemove = nfts.findIndex(\n            (nft) =>\n              nft.address.toLowerCase() === tokenAddress.toLowerCase() &&\n              nft.tokenId === tokenId,\n          );\n          /* istanbul ignore next */\n          if (indexToRemove !== -1) {\n            nfts.splice(indexToRemove, 1);\n          }\n        } else {\n          return nfts;\n        }\n      }\n\n      const newEntry: Nft = {\n        address: tokenAddress,\n        tokenId,\n        favorite: existingEntry?.favorite || false,\n        isCurrentlyOwned: true,\n        ...nftMetadata,\n      };\n\n      const newNfts = [...nfts, newEntry];\n      this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n        chainId,\n        userAddress,\n      });\n\n      if (this.onNftAdded) {\n        this.onNftAdded({\n          address: tokenAddress,\n          symbol: nftContract.symbol,\n          tokenId: tokenId.toString(),\n          standard: nftMetadata.standard,\n          source,\n        });\n      }\n      return newNfts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds an NFT contract to the stored NFT contracts list.\n   *\n   * @param options - options.\n   * @param options.tokenAddress - Hex address of the NFT contract.\n   * @param options.userAddress - The address of the account where the NFT is being added.\n   * @param options.nftMetadata - The retrieved NFTMetadata from API.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private async addNftContract({\n    tokenAddress,\n    userAddress,\n    networkClientId,\n    source,\n    nftMetadata,\n  }: {\n    tokenAddress: string;\n    userAddress: string;\n    nftMetadata: NftMetadata;\n    networkClientId?: NetworkClientId;\n    source?: Source;\n  }): Promise<NftContract[]> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      tokenAddress = toChecksumHexAddress(tokenAddress);\n      const { allNftContracts } = this.state;\n      const chainId = this.getCorrectChainId({\n        networkClientId,\n      });\n\n      const nftContracts = allNftContracts[userAddress]?.[chainId] || [];\n\n      const existingEntry = nftContracts.find(\n        (nftContract) =>\n          nftContract.address.toLowerCase() === tokenAddress.toLowerCase(),\n      );\n      if (existingEntry) {\n        return nftContracts;\n      }\n\n      // this doesn't work currently for detection if the user switches networks while the detection is processing\n      // will be fixed once detection uses networkClientIds\n      // get name and symbol if ERC721 then put together the metadata\n      const contractInformation = await this.getNftContractInformation(\n        tokenAddress,\n        nftMetadata,\n        networkClientId,\n      );\n      const {\n        asset_contract_type,\n        created_date,\n        symbol,\n        description,\n        external_link,\n        schema_name,\n        collection: { name, image_url, tokenCount },\n      } = contractInformation;\n\n      // If the nft is auto-detected we want some valid metadata to be present\n      if (\n        source === Source.Detected &&\n        'address' in contractInformation &&\n        typeof contractInformation.address === 'string' &&\n        'collection' in contractInformation &&\n        contractInformation.collection.name === null &&\n        'image_url' in contractInformation.collection &&\n        contractInformation.collection.image_url === null &&\n        Object.entries(contractInformation).every(([key, value]) => {\n          return key === 'address' || key === 'collection' || !value;\n        })\n      ) {\n        return nftContracts;\n      }\n\n      /* istanbul ignore next */\n      const newEntry: NftContract = Object.assign(\n        {},\n        { address: tokenAddress },\n        description && { description },\n        name && { name },\n        image_url && { logo: image_url },\n        symbol && { symbol },\n        tokenCount !== null &&\n          typeof tokenCount !== 'undefined' && { totalSupply: tokenCount },\n        asset_contract_type && { assetContractType: asset_contract_type },\n        created_date && { createdDate: created_date },\n        schema_name && { schemaName: schema_name },\n        external_link && { externalLink: external_link },\n      );\n      const newNftContracts = [...nftContracts, newEntry];\n      this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {\n        chainId,\n        userAddress,\n      });\n\n      return newNftContracts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - options.\n   * @param options.chainId - The chainId of the network where the NFT is being removed.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  private removeAndIgnoreIndividualNft(\n    address: string,\n    tokenId: string,\n    {\n      chainId,\n      userAddress,\n    }: {\n      chainId: Hex;\n      userAddress: string;\n    },\n  ) {\n    address = toChecksumHexAddress(address);\n    const { allNfts, ignoredNfts } = this.state;\n    const newIgnoredNfts = [...ignoredNfts];\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const newNfts = nfts.filter((nft) => {\n      if (\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId\n      ) {\n        const alreadyIgnored = newIgnoredNfts.find(\n          (c) => c.address === address && c.tokenId === tokenId,\n        );\n        !alreadyIgnored && newIgnoredNfts.push(nft);\n        return false;\n      }\n      return true;\n    });\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      userAddress,\n      chainId,\n    });\n\n    this.update({\n      ignoredNfts: newIgnoredNfts,\n    });\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - options.\n   * @param options.chainId - The chainId of the network where the NFT is being removed.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  private removeIndividualNft(\n    address: string,\n    tokenId: string,\n    { chainId, userAddress }: { chainId: Hex; userAddress: string },\n  ) {\n    address = toChecksumHexAddress(address);\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const newNfts = nfts.filter(\n      (nft) =>\n        !(\n          nft.address.toLowerCase() === address.toLowerCase() &&\n          nft.tokenId === tokenId\n        ),\n    );\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      userAddress,\n      chainId,\n    });\n  }\n\n  /**\n   * Removes an NFT contract to the stored NFT contracts list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param options - options.\n   * @param options.chainId - The chainId of the network where the NFT is being removed.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private removeNftContract(\n    address: string,\n    { chainId, userAddress }: { chainId: Hex; userAddress: string },\n  ): NftContract[] {\n    address = toChecksumHexAddress(address);\n    const { allNftContracts } = this.state;\n    const nftContracts = allNftContracts[userAddress]?.[chainId] || [];\n\n    const newNftContracts = nftContracts.filter(\n      (nftContract) =>\n        !(nftContract.address.toLowerCase() === address.toLowerCase()),\n    );\n    this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {\n      chainId,\n      userAddress,\n    });\n\n    return newNftContracts;\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Optional API key to use with opensea\n   */\n  openSeaApiKey?: string;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'NftController';\n\n  private readonly getERC721AssetName: AssetsContractController['getERC721AssetName'];\n\n  private readonly getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n\n  private readonly getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n\n  private readonly getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n\n  private readonly getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n\n  private readonly getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  private readonly onNftAdded?: (data: {\n    address: string;\n    symbol: string | undefined;\n    tokenId: string;\n    standard: string | null;\n    source: Source;\n  }) => void;\n\n  /**\n   * Creates an NftController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getERC721AssetName - Gets the name of the asset at the given address.\n   * @param options.getERC721AssetSymbol - Gets the symbol of the asset at the given address.\n   * @param options.getERC721TokenURI - Gets the URI of the ERC721 token at the given address, with the given ID.\n   * @param options.getERC721OwnerOf - Get the owner of a ERC-721 NFT.\n   * @param options.getERC1155BalanceOf - Gets balance of a ERC-1155 NFT.\n   * @param options.getERC1155TokenURI - Gets the URI of the ERC1155 token at the given address, with the given ID.\n   * @param options.getNetworkClientById - Gets the network client for the given networkClientId.\n   * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data\n   * for tracking the NFT added event.\n   * @param options.messenger - The controller messenger.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      chainId: initialChainId,\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getERC721AssetName,\n      getERC721AssetSymbol,\n      getERC721TokenURI,\n      getERC721OwnerOf,\n      getERC1155BalanceOf,\n      getERC1155TokenURI,\n      getNetworkClientById,\n      onNftAdded,\n      messenger,\n    }: {\n      chainId: Hex;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getERC721AssetName: AssetsContractController['getERC721AssetName'];\n      getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n      getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n      getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n      getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n      getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n      onNftAdded?: (data: {\n        address: string;\n        symbol: string | undefined;\n        tokenId: string;\n        standard: string | null;\n        source: string;\n      }) => void;\n      messenger: NftControllerMessenger;\n    },\n    config?: Partial<BaseConfig>,\n    state?: Partial<NftState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      selectedAddress: '',\n      chainId: initialChainId,\n      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,\n      openSeaEnabled: false,\n      useIPFSSubdomains: true,\n      isIpfsGatewayEnabled: true,\n    };\n\n    this.defaultState = getDefaultNftState();\n    this.initialize();\n    this.getERC721AssetName = getERC721AssetName;\n    this.getERC721AssetSymbol = getERC721AssetSymbol;\n    this.getERC721TokenURI = getERC721TokenURI;\n    this.getERC721OwnerOf = getERC721OwnerOf;\n    this.getERC1155BalanceOf = getERC1155BalanceOf;\n    this.getERC1155TokenURI = getERC1155TokenURI;\n    this.getNetworkClientById = getNetworkClientById;\n    this.onNftAdded = onNftAdded;\n    this.messagingSystem = messenger;\n\n    onPreferencesStateChange(\n      async ({\n        selectedAddress,\n        ipfsGateway,\n        openSeaEnabled,\n        isIpfsGatewayEnabled,\n      }) => {\n        this.configure({\n          selectedAddress,\n          ipfsGateway,\n          openSeaEnabled,\n          isIpfsGatewayEnabled,\n        });\n\n        const needsUpdateNftMetadata =\n          (isIpfsGatewayEnabled && ipfsGateway !== '') || openSeaEnabled;\n\n        if (needsUpdateNftMetadata) {\n          const { chainId } = this.config;\n          const nfts: Nft[] =\n            this.state.allNfts[selectedAddress]?.[chainId] ?? [];\n          // filter only nfts\n          const nftsToUpdate = nfts.filter(\n            (singleNft) =>\n              !singleNft.name && !singleNft.description && !singleNft.image,\n          );\n          if (nftsToUpdate.length !== 0) {\n            await this.updateNftMetadata({\n              nfts: nftsToUpdate,\n              userAddress: selectedAddress,\n            });\n          }\n        }\n      },\n    );\n\n    onNetworkStateChange(({ providerConfig }) => {\n      const { chainId } = providerConfig;\n      this.configure({ chainId });\n    });\n  }\n\n  private async validateWatchNft(\n    asset: NftAsset,\n    type: NFTStandardType,\n    userAddress: string,\n    { networkClientId }: { networkClientId?: NetworkClientId } = {},\n  ) {\n    const { address: contractAddress, tokenId } = asset;\n\n    // Validate parameters\n    if (!type) {\n      throw rpcErrors.invalidParams('Asset type is required');\n    }\n\n    if (type !== ERC721 && type !== ERC1155) {\n      throw rpcErrors.invalidParams(\n        `Non NFT asset type ${type} not supported by watchNft`,\n      );\n    }\n\n    if (!contractAddress || !tokenId) {\n      throw rpcErrors.invalidParams('Both address and tokenId are required');\n    }\n\n    if (!isAddress(contractAddress)) {\n      throw rpcErrors.invalidParams('Invalid address');\n    }\n\n    if (!/^\\d+$/u.test(tokenId)) {\n      throw rpcErrors.invalidParams('Invalid tokenId');\n    }\n\n    // Check if the user owns the suggested NFT\n    try {\n      const isOwner = await this.isNftOwner(\n        userAddress,\n        contractAddress,\n        tokenId,\n        { networkClientId },\n      );\n      if (!isOwner) {\n        throw rpcErrors.invalidInput(\n          'Suggested NFT is not owned by the selected account',\n        );\n      }\n    } catch (error) {\n      // error thrown here: \"Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.\"\n      if (error instanceof Error) {\n        throw rpcErrors.resourceUnavailable(error.message);\n      }\n      throw error;\n    }\n  }\n\n  // temporary method to get the correct chainId until we remove chainId from the config & the chainId arg from the detection logic\n  // Just a helper method to prefer the networkClient chainId first then the chainId argument and then finally the config chainId\n  private getCorrectChainId({\n    networkClientId,\n  }: {\n    networkClientId?: NetworkClientId;\n  }) {\n    if (networkClientId) {\n      return this.getNetworkClientById(networkClientId).configuration.chainId;\n    }\n    return this.config.chainId;\n  }\n\n  /**\n   * Adds a new suggestedAsset to state. Parameters will be validated according to\n   * asset type being watched. A `<suggestedNftMeta.id>:pending` hub event will be emitted once added.\n   *\n   * @param asset - The asset to be watched. For now ERC721 and ERC1155 tokens are accepted.\n   * @param asset.address - The address of the asset contract.\n   * @param asset.tokenId - The ID of the asset.\n   * @param type - The asset type.\n   * @param origin - Domain origin to register the asset from.\n   * @param options - Options bag.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being added.\n   * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.\n   */\n  async watchNft(\n    asset: NftAsset,\n    type: NFTStandardType,\n    origin: string,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: {\n      networkClientId?: NetworkClientId;\n      userAddress?: string;\n    } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    await this.validateWatchNft(asset, type, userAddress);\n\n    const nftMetadata = await this.getNftInformation(\n      asset.address,\n      asset.tokenId,\n      networkClientId,\n    );\n\n    if (nftMetadata.standard && nftMetadata.standard !== type) {\n      throw rpcErrors.invalidInput(\n        `Suggested NFT of type ${nftMetadata.standard} does not match received type ${type}`,\n      );\n    }\n\n    const suggestedNftMeta: SuggestedNftMeta = {\n      asset: { ...asset, ...nftMetadata },\n      type,\n      id: random(),\n      time: Date.now(),\n      interactingAddress: userAddress,\n      origin,\n    };\n    await this._requestApproval(suggestedNftMeta);\n    const { address, tokenId } = asset;\n    const { name, standard, description, image } = nftMetadata;\n\n    await this.addNft(address, tokenId, {\n      nftMetadata: {\n        name: name ?? null,\n        description: description ?? null,\n        image: image ?? null,\n        standard: standard ?? null,\n      },\n      userAddress,\n      source: Source.Dapp,\n      networkClientId,\n    });\n  }\n\n  /**\n   * Sets an OpenSea API key to retrieve NFT information.\n   *\n   * @param openSeaApiKey - OpenSea API key.\n   */\n  setApiKey(openSeaApiKey: string) {\n    this.openSeaApiKey = openSeaApiKey;\n  }\n\n  /**\n   * Checks the ownership of a ERC-721 or ERC-1155 NFT for a given address.\n   *\n   * @param ownerAddress - User public address.\n   * @param nftAddress - NFT contract address.\n   * @param tokenId - NFT token ID.\n   * @param options - Options bag.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving the NFT ownership.\n   */\n  async isNftOwner(\n    ownerAddress: string,\n    nftAddress: string,\n    tokenId: string,\n    {\n      networkClientId,\n    }: {\n      networkClientId?: NetworkClientId;\n    } = {},\n  ): Promise<boolean> {\n    // Checks the ownership for ERC-721.\n    try {\n      const owner = await this.getERC721OwnerOf(\n        nftAddress,\n        tokenId,\n        networkClientId,\n      );\n      return ownerAddress.toLowerCase() === owner.toLowerCase();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-721 contract error\n    }\n\n    // Checks the ownership for ERC-1155.\n    try {\n      const balance = await this.getERC1155BalanceOf(\n        ownerAddress,\n        nftAddress,\n        tokenId,\n        networkClientId,\n      );\n      return !balance.isZero();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-1155 contract error\n    }\n\n    throw new Error(\n      `Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.`,\n    );\n  }\n\n  /**\n   * Verifies currently selected address owns entered NFT address/tokenId combo and\n   * adds the NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param options - an object of arguments\n   * @param options.userAddress - The address of the current user.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   */\n  async addNftVerifyOwnership(\n    address: string,\n    tokenId: string,\n    {\n      userAddress = this.config.selectedAddress,\n      networkClientId,\n      source,\n    }: {\n      userAddress?: string;\n      networkClientId?: NetworkClientId;\n      source?: Source;\n    } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    if (\n      !(await this.isNftOwner(userAddress, address, tokenId, {\n        networkClientId,\n      }))\n    ) {\n      throw new Error('This NFT is not owned by the user');\n    }\n    await this.addNft(address, tokenId, {\n      networkClientId,\n      userAddress,\n      source,\n    });\n  }\n\n  /**\n   * Adds an NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param tokenAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param options - an object of arguments\n   * @param options.nftMetadata - NFT optional metadata.\n   * @param options.userAddress - The address of the current user.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT list.\n   */\n  async addNft(\n    tokenAddress: string,\n    tokenId: string,\n    {\n      nftMetadata,\n      userAddress = this.config.selectedAddress,\n      source = Source.Custom,\n      networkClientId,\n    }: {\n      nftMetadata?: NftMetadata;\n      userAddress?: string;\n      source?: Source;\n      networkClientId?: NetworkClientId;\n    } = { userAddress: this.config.selectedAddress },\n  ) {\n    tokenAddress = toChecksumHexAddress(tokenAddress);\n\n    const chainId = this.getCorrectChainId({ networkClientId });\n\n    nftMetadata =\n      nftMetadata ||\n      (await this.getNftInformation(tokenAddress, tokenId, networkClientId));\n\n    const newNftContracts = await this.addNftContract({\n      tokenAddress,\n      userAddress,\n      networkClientId,\n      source,\n      nftMetadata,\n    });\n\n    // If NFT contract was not added, do not add individual NFT\n    const nftContract = newNftContracts.find(\n      (contract) =>\n        contract.address.toLowerCase() === tokenAddress.toLowerCase(),\n    );\n\n    // If NFT contract information, add individual NFT\n    if (nftContract) {\n      await this.addIndividualNft(\n        tokenAddress,\n        tokenId,\n        nftMetadata,\n        nftContract,\n        chainId,\n        userAddress,\n        source,\n      );\n    }\n  }\n\n  /**\n   * Refetches NFT metadata and updates the state\n   *\n   * @param options - Options for refetching NFT metadata\n   * @param options.nfts - nfts to update metadata for.\n   * @param options.userAddress - The current user address\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   */\n  async updateNftMetadata({\n    nfts,\n    userAddress = this.config.selectedAddress,\n    networkClientId,\n  }: {\n    nfts: Nft[];\n    userAddress?: string;\n    networkClientId?: NetworkClientId;\n  }) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n\n    const nftsWithChecksumAdr = nfts.map((nft) => {\n      return {\n        ...nft,\n        address: toChecksumHexAddress(nft.address),\n      };\n    });\n    const nftMetadataResults = await Promise.allSettled(\n      nftsWithChecksumAdr.map(async (nft) => {\n        const resMetadata = await this.getNftInformation(\n          nft.address,\n          nft.tokenId,\n          networkClientId,\n        );\n        return {\n          nft,\n          newMetadata: resMetadata,\n        };\n      }),\n    );\n    const successfulNewFetchedNfts = nftMetadataResults.filter(\n      (result): result is PromiseFulfilledResult<NftUpdate> =>\n        result.status === 'fulfilled',\n    );\n    // We want to avoid updating the state if the state and fetched nft info are the same\n    const nftsWithDifferentMetadata: PromiseFulfilledResult<NftUpdate>[] = [];\n    const { allNfts } = this.state;\n    const stateNfts = allNfts[userAddress]?.[chainId] || [];\n\n    successfulNewFetchedNfts.forEach((singleNft) => {\n      const existingEntry: Nft | undefined = stateNfts.find(\n        (nft) =>\n          nft.address.toLowerCase() ===\n            singleNft.value.nft.address.toLowerCase() &&\n          nft.tokenId === singleNft.value.nft.tokenId,\n      );\n\n      if (existingEntry) {\n        const differentMetadata = compareNftMetadata(\n          singleNft.value.newMetadata,\n          existingEntry,\n        );\n\n        if (differentMetadata) {\n          nftsWithDifferentMetadata.push(singleNft);\n        }\n      }\n    });\n\n    if (nftsWithDifferentMetadata.length !== 0) {\n      nftsWithDifferentMetadata.forEach((elm) =>\n        this.updateNft(\n          elm.value.nft,\n          elm.value.newMetadata,\n          userAddress,\n          chainId,\n        ),\n      );\n    }\n  }\n\n  /**\n   * Removes an NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  removeNft(\n    address: string,\n    tokenId: string,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    address = toChecksumHexAddress(address);\n    this.removeIndividualNft(address, tokenId, { chainId, userAddress });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n\n    if (!remainingNft) {\n      this.removeNftContract(address, { chainId, userAddress });\n    }\n  }\n\n  /**\n   * Removes an NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  removeAndIgnoreNft(\n    address: string,\n    tokenId: string,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    address = toChecksumHexAddress(address);\n    this.removeAndIgnoreIndividualNft(address, tokenId, {\n      chainId,\n      userAddress,\n    });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (!remainingNft) {\n      this.removeNftContract(address, { chainId, userAddress });\n    }\n  }\n\n  /**\n   * Removes all NFTs from the ignored list.\n   */\n  clearIgnoredNfts() {\n    this.update({ ignoredNfts: [] });\n  }\n\n  /**\n   * Checks whether input NFT is still owned by the user\n   * And updates the isCurrentlyOwned value on the NFT object accordingly.\n   *\n   * @param nft - The NFT object to check and update.\n   * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.\n   * @param accountParams - The userAddress and chainId to check ownership against\n   * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure assets are stored to the correct account\n   * @param accountParams.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns the NFT with the updated isCurrentlyOwned value\n   */\n  async checkAndUpdateSingleNftOwnershipStatus(\n    nft: Nft,\n    batch: boolean,\n    {\n      userAddress = this.config.selectedAddress,\n      networkClientId,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const { address, tokenId } = nft;\n    let isOwned = nft.isCurrentlyOwned;\n    try {\n      isOwned = await this.isNftOwner(userAddress, address, tokenId, {\n        networkClientId,\n      });\n    } catch {\n      // ignore error\n      // this will only throw an error 'Unable to verify ownership' in which case\n      // we want to keep the current value of isCurrentlyOwned for this flow.\n    }\n\n    nft.isCurrentlyOwned = isOwned;\n\n    if (batch) {\n      return nft;\n    }\n\n    // if this is not part of a batched update we update this one NFT in state\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const nftToUpdate = nfts.find(\n      (item) =>\n        item.tokenId === tokenId &&\n        item.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (nftToUpdate) {\n      nftToUpdate.isCurrentlyOwned = isOwned;\n      this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {\n        userAddress,\n        chainId,\n      });\n    }\n    return nft;\n  }\n\n  /**\n   * Checks whether NFTs associated with current selectedAddress/chainId combination are still owned by the user\n   * And updates the isCurrentlyOwned value on each accordingly.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT ownership status is checked/updated.\n   */\n  async checkAndUpdateAllNftsOwnershipStatus(\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const updatedNfts = await Promise.all(\n      nfts.map(async (nft) => {\n        return (\n          (await this.checkAndUpdateSingleNftOwnershipStatus(nft, true, {\n            networkClientId,\n            userAddress,\n          })) ?? nft\n        );\n      }),\n    );\n\n    this.updateNestedNftState(updatedNfts, ALL_NFTS_STATE_KEY, {\n      userAddress,\n      chainId,\n    });\n  }\n\n  /**\n   * Update NFT favorite status.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Hex address of the NFT contract.\n   * @param favorite - NFT new favorite status.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  updateNftFavoriteStatus(\n    address: string,\n    tokenId: string,\n    favorite: boolean,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: {\n      networkClientId?: NetworkClientId;\n      userAddress?: string;\n    } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.address === address && nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nfts[index],\n      favorite,\n    };\n\n    // Update Nfts array\n    nfts[index] = updatedNft;\n\n    this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {\n      chainId,\n      userAddress,\n    });\n  }\n\n  /**\n   * Returns an NFT by the address and token id.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Number that represents the id of the token.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns Object containing the NFT and its position in the array\n   */\n  findNftByAddressAndTokenId(\n    address: string,\n    tokenId: string,\n    selectedAddress: string,\n    chainId: Hex,\n  ): { nft: Nft; index: number } | null {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) =>\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return null;\n    }\n\n    return { nft: nfts[index], index };\n  }\n\n  /**\n   * Update NFT data.\n   *\n   * @param nft - NFT object to find the right NFT to updates.\n   * @param updates - NFT partial object to update properties of the NFT.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   */\n  updateNft(\n    nft: Nft,\n    updates: Partial<Nft>,\n    selectedAddress: string,\n    chainId: Hex,\n  ) {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const nftInfo = this.findNftByAddressAndTokenId(\n      nft.address,\n      nft.tokenId,\n      selectedAddress,\n      chainId,\n    );\n\n    if (!nftInfo) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nft,\n      ...updates,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, nftInfo.index),\n      updatedNft,\n      ...nfts.slice(nftInfo.index + 1),\n    ];\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      chainId,\n      userAddress: selectedAddress,\n    });\n  }\n\n  /**\n   * Resets the transaction status of an NFT.\n   *\n   * @param transactionId - NFT transaction id.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns a boolean indicating if the reset was well succeeded or not\n   */\n  resetNftTransactionStatusByTransactionId(\n    transactionId: string,\n    selectedAddress: string,\n    chainId: Hex,\n  ): boolean {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.transactionId === transactionId,\n    );\n\n    if (index === -1) {\n      return false;\n    }\n    const updatedNft: Nft = {\n      ...nfts[index],\n      transactionId: undefined,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, index),\n      updatedNft,\n      ...nfts.slice(index + 1),\n    ];\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      chainId,\n      userAddress: selectedAddress,\n    });\n\n    return true;\n  }\n\n  async _requestApproval(suggestedNftMeta: SuggestedNftMeta) {\n    return this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        id: suggestedNftMeta.id,\n        origin: suggestedNftMeta.origin,\n        type: ApprovalType.WatchAsset,\n        requestData: {\n          id: suggestedNftMeta.id,\n          interactingAddress: suggestedNftMeta.interactingAddress,\n          asset: {\n            address: suggestedNftMeta.asset.address,\n            tokenId: suggestedNftMeta.asset.tokenId,\n            name: suggestedNftMeta.asset.name,\n            description: suggestedNftMeta.asset.description,\n            image: suggestedNftMeta.asset.image,\n            standard: suggestedNftMeta.asset.standard,\n          },\n        },\n      },\n      true,\n    );\n  }\n}\n\nexport default NftController;\n"]}
\ No newline at end of file
diff --git a/dist/chunk-IOQX3VTD.js b/dist/chunk-IOQX3VTD.js
deleted file mode 100644
index 9d3d9c3d9a1efa6768990d2540fda6fb1aabf679..0000000000000000000000000000000000000000
--- a/dist/chunk-IOQX3VTD.js
+++ /dev/null
@@ -1,418 +0,0 @@
-"use strict";Object.defineProperty(exports, "__esModule", {value: true});
-
-var _chunkDYH5P3VYjs = require('./chunk-DYH5P3VY.js');
-
-
-
-var _chunkLS6R3HQLjs = require('./chunk-LS6R3HQL.js');
-
-
-
-
-
-var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
-
-// src/TokenRatesController.ts
-
-
-
-
-
-var _controllerutils = require('@metamask/controller-utils');
-var _pollingcontroller = require('@metamask/polling-controller');
-var _utils = require('@metamask/utils');
-var _lodash = require('lodash');
-async function getCurrencyConversionRate({
-  from,
-  to
-}) {
-  const includeUSDRate = false;
-  try {
-    const result = await _chunkDYH5P3VYjs.fetchExchangeRate.call(void 0, 
-      to,
-      from,
-      includeUSDRate
-    );
-    return result.conversionRate;
-  } catch (error) {
-    if (error instanceof Error && error.message.includes("market does not exist for this coin pair")) {
-      return null;
-    }
-    throw error;
-  }
-}
-var _pollState, _tokenPricesService, _inProcessExchangeRateUpdates, _getTokenAddresses, getTokenAddresses_fn, _stopPoll, stopPoll_fn, _poll, poll_fn, _fetchAndMapExchangeRates, fetchAndMapExchangeRates_fn, _fetchAndMapExchangeRatesForSupportedNativeCurrency, fetchAndMapExchangeRatesForSupportedNativeCurrency_fn, _fetchAndMapExchangeRatesForUnsupportedNativeCurrency, fetchAndMapExchangeRatesForUnsupportedNativeCurrency_fn;
-var TokenRatesController = class extends _pollingcontroller.StaticIntervalPollingControllerV1 {
-  /**
-   * Creates a TokenRatesController instance.
-   *
-   * @param options - The controller options.
-   * @param options.interval - The polling interval in ms
-   * @param options.threshold - The duration in ms before metadata fetched from CoinGecko is considered stale
-   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.
-   * @param options.chainId - The chain ID of the current network.
-   * @param options.ticker - The ticker for the current network.
-   * @param options.selectedAddress - The current selected address.
-   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
-   * @param options.onTokensStateChange - Allows subscribing to token controller state changes.
-   * @param options.onNetworkStateChange - Allows subscribing to network state changes.
-   * @param options.tokenPricesService - An object in charge of retrieving token prices.
-   * @param config - Initial options used to configure this controller.
-   * @param state - Initial state to set on this controller.
-   */
-  constructor({
-    interval = 3 * 60 * 1e3,
-    threshold = 6 * 60 * 60 * 1e3,
-    getNetworkClientById,
-    chainId: initialChainId,
-    ticker: initialTicker,
-    selectedAddress: initialSelectedAddress,
-    onPreferencesStateChange,
-    onTokensStateChange,
-    onNetworkStateChange,
-    tokenPricesService
-  }, config, state) {
-    super(config, state);
-    /**
-     * Get the user's tokens for the given chain.
-     *
-     * @param chainId - The chain ID.
-     * @returns The list of tokens addresses for the current chain
-     */
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getTokenAddresses);
-    /**
-     * Clear the active polling timer, if present.
-     */
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _stopPoll);
-    /**
-     * Poll for exchange rate updates.
-     */
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _poll);
-    /**
-     * Uses the token prices service to retrieve exchange rates for tokens in a
-     * particular currency.
-     *
-     * If the price API does not support the given chain ID, returns an empty
-     * object.
-     *
-     * If the price API does not support the given currency, retrieves exchange
-     * rates in a known currency instead, then converts those rates using the
-     * exchange rate between the known currency and desired currency.
-     *
-     * @param args - The arguments to this function.
-     * @param args.tokenAddresses - Addresses for tokens.
-     * @param args.chainId - The EIP-155 ID of the chain where the tokens live.
-     * @param args.nativeCurrency - The native currency in which to request
-     * exchange rates.
-     * @returns A map from token address to its exchange rate in the native
-     * currency, or an empty map if no exchange rates can be obtained for the
-     * chain ID.
-     */
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _fetchAndMapExchangeRates);
-    /**
-     * Retrieves prices in the given currency for the given tokens on the given
-     * chain. Ensures that token addresses are checksum addresses.
-     *
-     * @param args - The arguments to this function.
-     * @param args.tokenAddresses - Addresses for tokens.
-     * @param args.chainId - The EIP-155 ID of the chain where the tokens live.
-     * @param args.nativeCurrency - The native currency in which to request
-     * prices.
-     * @returns A map of the token addresses (as checksums) to their prices in the
-     * native currency.
-     */
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _fetchAndMapExchangeRatesForSupportedNativeCurrency);
-    /**
-     * If the price API does not support a given native currency, then we need to
-     * convert it to a fallback currency and feed that currency into the price
-     * API, then convert the prices to our desired native currency.
-     *
-     * @param args - The arguments to this function.
-     * @param args.tokenAddresses - Addresses for tokens.
-     * @param args.nativeCurrency - The native currency in which to request
-     * prices.
-     * @returns A map of the token addresses (as checksums) to their prices in the
-     * native currency.
-     */
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _fetchAndMapExchangeRatesForUnsupportedNativeCurrency);
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _pollState, "Inactive" /* Inactive */);
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _tokenPricesService, void 0);
-    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _inProcessExchangeRateUpdates, {});
-    /**
-     * Name of this controller used during composition
-     */
-    this.name = "TokenRatesController";
-    this.defaultConfig = {
-      interval,
-      threshold,
-      disabled: false,
-      nativeCurrency: initialTicker,
-      chainId: initialChainId,
-      selectedAddress: initialSelectedAddress,
-      allTokens: {},
-      // TODO: initialize these correctly, maybe as part of BaseControllerV2 migration
-      allDetectedTokens: {}
-    };
-    this.defaultState = {
-      contractExchangeRates: {},
-      contractExchangeRatesByChainId: {}
-    };
-    this.initialize();
-    this.setIntervalLength(interval);
-    this.getNetworkClientById = getNetworkClientById;
-    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _tokenPricesService, tokenPricesService);
-    if (config?.disabled) {
-      this.configure({ disabled: true }, false, false);
-    }
-    onPreferencesStateChange(async ({ selectedAddress }) => {
-      if (this.config.selectedAddress !== selectedAddress) {
-        this.configure({ selectedAddress });
-        if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _pollState) === "Active" /* Active */) {
-          await this.updateExchangeRates();
-        }
-      }
-    });
-    onTokensStateChange(async ({ allTokens, allDetectedTokens }) => {
-      const previousTokenAddresses = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getTokenAddresses, getTokenAddresses_fn).call(this, this.config.chainId);
-      this.configure({ allTokens, allDetectedTokens });
-      const newTokenAddresses = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getTokenAddresses, getTokenAddresses_fn).call(this, this.config.chainId);
-      if (!_lodash.isEqual.call(void 0, previousTokenAddresses, newTokenAddresses) && _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _pollState) === "Active" /* Active */) {
-        await this.updateExchangeRates();
-      }
-    });
-    onNetworkStateChange(async ({ providerConfig }) => {
-      const { chainId, ticker } = providerConfig;
-      if (this.config.chainId !== chainId || this.config.nativeCurrency !== ticker) {
-        this.update({ contractExchangeRates: {} });
-        this.configure({ chainId, nativeCurrency: ticker });
-        if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _pollState) === "Active" /* Active */) {
-          await this.updateExchangeRates();
-        }
-      }
-    });
-  }
-  /**
-   * Start (or restart) polling.
-   */
-  async start() {
-    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _stopPoll, stopPoll_fn).call(this);
-    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _pollState, "Active" /* Active */);
-    await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _poll, poll_fn).call(this);
-  }
-  /**
-   * Stop polling.
-   */
-  stop() {
-    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _stopPoll, stopPoll_fn).call(this);
-    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _pollState, "Inactive" /* Inactive */);
-  }
-  /**
-   * Updates exchange rates for all tokens.
-   */
-  async updateExchangeRates() {
-    const { chainId, nativeCurrency } = this.config;
-    await this.updateExchangeRatesByChainId({
-      chainId,
-      nativeCurrency
-    });
-  }
-  /**
-   * Updates exchange rates for all tokens.
-   *
-   * @param options - The options to fetch exchange rates.
-   * @param options.chainId - The chain ID.
-   * @param options.nativeCurrency - The ticker for the chain.
-   */
-  async updateExchangeRatesByChainId({
-    chainId,
-    nativeCurrency
-  }) {
-    if (this.disabled) {
-      return;
-    }
-    const tokenAddresses = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getTokenAddresses, getTokenAddresses_fn).call(this, chainId);
-    if (tokenAddresses.length === 0) {
-      return;
-    }
-    const updateKey = `${chainId}:${nativeCurrency}`;
-    if (updateKey in _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _inProcessExchangeRateUpdates)) {
-      await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _inProcessExchangeRateUpdates)[updateKey];
-      return;
-    }
-    const {
-      promise: inProgressUpdate,
-      resolve: updateSucceeded,
-      reject: updateFailed
-    } = _utils.createDeferredPromise.call(void 0, { suppressUnhandledRejection: true });
-    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _inProcessExchangeRateUpdates)[updateKey] = inProgressUpdate;
-    try {
-      const newContractExchangeRates = await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _fetchAndMapExchangeRates, fetchAndMapExchangeRates_fn).call(this, {
-        tokenAddresses,
-        chainId,
-        nativeCurrency
-      });
-      const existingContractExchangeRates = this.state.contractExchangeRates;
-      const updatedContractExchangeRates = chainId === this.config.chainId && nativeCurrency === this.config.nativeCurrency ? newContractExchangeRates : existingContractExchangeRates;
-      const existingContractExchangeRatesForChainId = this.state.contractExchangeRatesByChainId[chainId] ?? {};
-      const updatedContractExchangeRatesForChainId = {
-        ...this.state.contractExchangeRatesByChainId,
-        [chainId]: {
-          ...existingContractExchangeRatesForChainId,
-          [nativeCurrency]: {
-            ...existingContractExchangeRatesForChainId[nativeCurrency],
-            ...newContractExchangeRates
-          }
-        }
-      };
-      this.update({
-        contractExchangeRates: updatedContractExchangeRates,
-        contractExchangeRatesByChainId: updatedContractExchangeRatesForChainId
-      });
-      updateSucceeded();
-    } catch (error) {
-      updateFailed(error);
-      throw error;
-    } finally {
-      delete _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _inProcessExchangeRateUpdates)[updateKey];
-    }
-  }
-  /**
-   * Updates token rates for the given networkClientId
-   *
-   * @param networkClientId - The network client ID used to get a ticker value.
-   * @returns The controller state.
-   */
-  async _executePoll(networkClientId) {
-    const networkClient = this.getNetworkClientById(networkClientId);
-    await this.updateExchangeRatesByChainId({
-      chainId: networkClient.configuration.chainId,
-      nativeCurrency: networkClient.configuration.ticker
-    });
-  }
-};
-_pollState = new WeakMap();
-_tokenPricesService = new WeakMap();
-_inProcessExchangeRateUpdates = new WeakMap();
-_getTokenAddresses = new WeakSet();
-getTokenAddresses_fn = function(chainId) {
-  const { allTokens, allDetectedTokens } = this.config;
-  const tokens = allTokens[chainId]?.[this.config.selectedAddress] || [];
-  const detectedTokens = allDetectedTokens[chainId]?.[this.config.selectedAddress] || [];
-  return [
-    ...new Set(
-      [...tokens, ...detectedTokens].map(
-        (token) => _controllerutils.toHex.call(void 0, _controllerutils.toChecksumHexAddress.call(void 0, token.address))
-      )
-    )
-  ].sort();
-};
-_stopPoll = new WeakSet();
-stopPoll_fn = function() {
-  if (this.handle) {
-    clearTimeout(this.handle);
-  }
-};
-_poll = new WeakSet();
-poll_fn = async function() {
-  await _controllerutils.safelyExecute.call(void 0, () => this.updateExchangeRates());
-  this.handle = setTimeout(() => {
-    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _poll, poll_fn).call(this);
-  }, this.config.interval);
-};
-_fetchAndMapExchangeRates = new WeakSet();
-fetchAndMapExchangeRates_fn = async function({
-  tokenAddresses,
-  chainId,
-  nativeCurrency
-}) {
-  if (!_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _tokenPricesService).validateChainIdSupported(chainId)) {
-    return tokenAddresses.reduce((obj, tokenAddress) => {
-      return {
-        ...obj,
-        [tokenAddress]: void 0
-      };
-    }, {});
-  }
-  if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _tokenPricesService).validateCurrencySupported(nativeCurrency)) {
-    return await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _fetchAndMapExchangeRatesForSupportedNativeCurrency, fetchAndMapExchangeRatesForSupportedNativeCurrency_fn).call(this, {
-      tokenAddresses,
-      chainId,
-      nativeCurrency
-    });
-  }
-  return await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _fetchAndMapExchangeRatesForUnsupportedNativeCurrency, fetchAndMapExchangeRatesForUnsupportedNativeCurrency_fn).call(this, {
-    tokenAddresses,
-    nativeCurrency
-  });
-};
-_fetchAndMapExchangeRatesForSupportedNativeCurrency = new WeakSet();
-fetchAndMapExchangeRatesForSupportedNativeCurrency_fn = async function({
-  tokenAddresses,
-  chainId,
-  nativeCurrency
-}) {
-  const tokenPricesByTokenAddress = await _chunkLS6R3HQLjs.reduceInBatchesSerially.call(void 0, {
-    values: [...tokenAddresses].sort(),
-    batchSize: _chunkLS6R3HQLjs.TOKEN_PRICES_BATCH_SIZE,
-    eachBatch: async (allTokenPricesByTokenAddress, batch) => {
-      const tokenPricesByTokenAddressForBatch = await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _tokenPricesService).fetchTokenPrices({
-        tokenAddresses: batch,
-        chainId,
-        currency: nativeCurrency
-      });
-      return {
-        ...allTokenPricesByTokenAddress,
-        ...tokenPricesByTokenAddressForBatch
-      };
-    },
-    initialResult: {}
-  });
-  return Object.entries(tokenPricesByTokenAddress).reduce(
-    (obj, [tokenAddress, tokenPrice]) => {
-      return {
-        ...obj,
-        [tokenAddress]: tokenPrice?.value
-      };
-    },
-    {}
-  );
-};
-_fetchAndMapExchangeRatesForUnsupportedNativeCurrency = new WeakSet();
-fetchAndMapExchangeRatesForUnsupportedNativeCurrency_fn = async function({
-  tokenAddresses,
-  nativeCurrency
-}) {
-  const [
-    contractExchangeRates,
-    fallbackCurrencyToNativeCurrencyConversionRate
-  ] = await Promise.all([
-    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _fetchAndMapExchangeRatesForSupportedNativeCurrency, fetchAndMapExchangeRatesForSupportedNativeCurrency_fn).call(this, {
-      tokenAddresses,
-      chainId: this.config.chainId,
-      nativeCurrency: _controllerutils.FALL_BACK_VS_CURRENCY
-    }),
-    getCurrencyConversionRate({
-      from: _controllerutils.FALL_BACK_VS_CURRENCY,
-      to: nativeCurrency
-    })
-  ]);
-  if (fallbackCurrencyToNativeCurrencyConversionRate === null) {
-    return {};
-  }
-  return Object.entries(contractExchangeRates).reduce(
-    (obj, [tokenAddress, tokenValue]) => {
-      return {
-        ...obj,
-        [tokenAddress]: tokenValue ? tokenValue * fallbackCurrencyToNativeCurrencyConversionRate : void 0
-      };
-    },
-    {}
-  );
-};
-var TokenRatesController_default = TokenRatesController;
-
-
-
-
-exports.TokenRatesController = TokenRatesController; exports.TokenRatesController_default = TokenRatesController_default;
-//# sourceMappingURL=chunk-IOQX3VTD.js.map
\ No newline at end of file
diff --git a/dist/chunk-IOQX3VTD.js.map b/dist/chunk-IOQX3VTD.js.map
deleted file mode 100644
index 230b7f492849a06fd51289027e41d2a5a447ccd7..0000000000000000000000000000000000000000
--- a/dist/chunk-IOQX3VTD.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["../src/TokenRatesController.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;AACA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAMP,SAAS,yCAAyC;AAElD,SAAS,6BAAuC;AAChD,SAAS,eAAe;AA8FxB,eAAe,0BAA0B;AAAA,EACvC;AAAA,EACA;AACF,GAGG;AACD,QAAM,iBAAiB;AACvB,MAAI;AACF,UAAM,SAAS,MAAM;AAAA,MACnB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,WAAO,OAAO;AAAA,EAChB,SAAS,OAAO;AACd,QACE,iBAAiB,SACjB,MAAM,QAAQ,SAAS,0CAA0C,GACjE;AACA,aAAO;AAAA,IACT;AACA,UAAM;AAAA,EACR;AACF;AArIA;AA2IO,IAAM,uBAAN,cAAmC,kCAGxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiCA,YACE;AAAA,IACE,WAAW,IAAI,KAAK;AAAA,IACpB,YAAY,IAAI,KAAK,KAAK;AAAA,IAC1B;AAAA,IACA,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,iBAAiB;AAAA,IACjB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAkBA,QACA,OACA;AACA,UAAM,QAAQ,KAAK;AAqErB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmCA;AAAA;AAAA;AAAA;AASA;AAAA;AAAA;AAAA,uBAAM;AAwHN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AA0DN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AAsDN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AAxZN,mCAAa;AAEb;AAEA,sDAA2E,CAAC;AAK5E;AAAA;AAAA;AAAA,SAAS,OAAO;AAuDd,SAAK,gBAAgB;AAAA,MACnB;AAAA,MACA;AAAA,MACA,UAAU;AAAA,MACV,gBAAgB;AAAA,MAChB,SAAS;AAAA,MACT,iBAAiB;AAAA,MACjB,WAAW,CAAC;AAAA;AAAA,MACZ,mBAAmB,CAAC;AAAA,IACtB;AAEA,SAAK,eAAe;AAAA,MAClB,uBAAuB,CAAC;AAAA,MACxB,gCAAgC,CAAC;AAAA,IACnC;AACA,SAAK,WAAW;AAChB,SAAK,kBAAkB,QAAQ;AAC/B,SAAK,uBAAuB;AAC5B,uBAAK,qBAAsB;AAE3B,QAAI,QAAQ,UAAU;AACpB,WAAK,UAAU,EAAE,UAAU,KAAK,GAAG,OAAO,KAAK;AAAA,IACjD;AAEA,6BAAyB,OAAO,EAAE,gBAAgB,MAAM;AACtD,UAAI,KAAK,OAAO,oBAAoB,iBAAiB;AACnD,aAAK,UAAU,EAAE,gBAAgB,CAAC;AAClC,YAAI,mBAAK,gBAAe,uBAAkB;AACxC,gBAAM,KAAK,oBAAoB;AAAA,QACjC;AAAA,MACF;AAAA,IACF,CAAC;AAED,wBAAoB,OAAO,EAAE,WAAW,kBAAkB,MAAM;AAC9D,YAAM,yBAAyB,sBAAK,0CAAL,WAC7B,KAAK,OAAO;AAEd,WAAK,UAAU,EAAE,WAAW,kBAAkB,CAAC;AAC/C,YAAM,oBAAoB,sBAAK,0CAAL,WAAwB,KAAK,OAAO;AAC9D,UACE,CAAC,QAAQ,wBAAwB,iBAAiB,KAClD,mBAAK,gBAAe,uBACpB;AACA,cAAM,KAAK,oBAAoB;AAAA,MACjC;AAAA,IACF,CAAC;AAED,yBAAqB,OAAO,EAAE,eAAe,MAAM;AACjD,YAAM,EAAE,SAAS,OAAO,IAAI;AAC5B,UACE,KAAK,OAAO,YAAY,WACxB,KAAK,OAAO,mBAAmB,QAC/B;AACA,aAAK,OAAO,EAAE,uBAAuB,CAAC,EAAE,CAAC;AACzC,aAAK,UAAU,EAAE,SAAS,gBAAgB,OAAO,CAAC;AAClD,YAAI,mBAAK,gBAAe,uBAAkB;AACxC,gBAAM,KAAK,oBAAoB;AAAA,QACjC;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EA0BA,MAAM,QAAQ;AACZ,0BAAK,wBAAL;AACA,uBAAK,YAAa;AAClB,UAAM,sBAAK,gBAAL;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO;AACL,0BAAK,wBAAL;AACA,uBAAK,YAAa;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA,EA2BA,MAAM,sBAAsB;AAC1B,UAAM,EAAE,SAAS,eAAe,IAAI,KAAK;AACzC,UAAM,KAAK,6BAA6B;AAAA,MACtC;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,6BAA6B;AAAA,IACjC;AAAA,IACA;AAAA,EACF,GAGG;AACD,QAAI,KAAK,UAAU;AACjB;AAAA,IACF;AAEA,UAAM,iBAAiB,sBAAK,0CAAL,WAAwB;AAC/C,QAAI,eAAe,WAAW,GAAG;AAC/B;AAAA,IACF;AAEA,UAAM,YAAgC,GAAG,OAAO,IAAI,cAAc;AAClE,QAAI,aAAa,mBAAK,gCAA+B;AAInD,YAAM,mBAAK,+BAA8B,SAAS;AAClD;AAAA,IACF;AAEA,UAAM;AAAA,MACJ,SAAS;AAAA,MACT,SAAS;AAAA,MACT,QAAQ;AAAA,IACV,IAAI,sBAAsB,EAAE,4BAA4B,KAAK,CAAC;AAC9D,uBAAK,+BAA8B,SAAS,IAAI;AAEhD,QAAI;AACF,YAAM,2BAA2B,MAAM,sBAAK,wDAAL,WAA+B;AAAA,QACpE;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAEA,YAAM,gCAAgC,KAAK,MAAM;AACjD,YAAM,+BACJ,YAAY,KAAK,OAAO,WACxB,mBAAmB,KAAK,OAAO,iBAC3B,2BACA;AAEN,YAAM,0CACJ,KAAK,MAAM,+BAA+B,OAAO,KAAK,CAAC;AACzD,YAAM,yCAAyC;AAAA,QAC7C,GAAG,KAAK,MAAM;AAAA,QACd,CAAC,OAAO,GAAG;AAAA,UACT,GAAG;AAAA,UACH,CAAC,cAAc,GAAG;AAAA,YAChB,GAAG,wCAAwC,cAAc;AAAA,YACzD,GAAG;AAAA,UACL;AAAA,QACF;AAAA,MACF;AAEA,WAAK,OAAO;AAAA,QACV,uBAAuB;AAAA,QACvB,gCAAgC;AAAA,MAClC,CAAC;AACD,sBAAgB;AAAA,IAClB,SAAS,OAAgB;AACvB,mBAAa,KAAK;AAClB,YAAM;AAAA,IACR,UAAE;AACA,aAAO,mBAAK,+BAA8B,SAAS;AAAA,IACrD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA4DA,MAAM,aAAa,iBAAiD;AAClE,UAAM,gBAAgB,KAAK,qBAAqB,eAAe;AAC/D,UAAM,KAAK,6BAA6B;AAAA,MACtC,SAAS,cAAc,cAAc;AAAA,MACrC,gBAAgB,cAAc,cAAc;AAAA,IAC9C,CAAC;AAAA,EACH;AA0GF;AA9bE;AAEA;AAEA;AAgIA;AAAA,uBAAkB,SAAC,SAAqB;AACtC,QAAM,EAAE,WAAW,kBAAkB,IAAI,KAAK;AAC9C,QAAM,SAAS,UAAU,OAAO,IAAI,KAAK,OAAO,eAAe,KAAK,CAAC;AACrE,QAAM,iBACJ,kBAAkB,OAAO,IAAI,KAAK,OAAO,eAAe,KAAK,CAAC;AAEhE,SAAO;AAAA,IACL,GAAG,IAAI;AAAA,MACL,CAAC,GAAG,QAAQ,GAAG,cAAc,EAAE;AAAA,QAAI,CAAC,UAClC,MAAM,qBAAqB,MAAM,OAAO,CAAC;AAAA,MAC3C;AAAA,IACF;AAAA,EACF,EAAE,KAAK;AACT;AAsBA;AAAA,cAAS,WAAG;AACV,MAAI,KAAK,QAAQ;AACf,iBAAa,KAAK,MAAM;AAAA,EAC1B;AACF;AAKM;AAAA,UAAK,iBAAG;AACZ,QAAM,cAAc,MAAM,KAAK,oBAAoB,CAAC;AAIpD,OAAK,SAAS,WAAW,MAAM;AAC7B,0BAAK,gBAAL;AAAA,EACF,GAAG,KAAK,OAAO,QAAQ;AACzB;AAgHM;AAAA,8BAAyB,eAAC;AAAA,EAC9B;AAAA,EACA;AAAA,EACA;AACF,GAImC;AACjC,MAAI,CAAC,mBAAK,qBAAoB,yBAAyB,OAAO,GAAG;AAC/D,WAAO,eAAe,OAAO,CAAC,KAAK,iBAAiB;AAClD,aAAO;AAAA,QACL,GAAG;AAAA,QACH,CAAC,YAAY,GAAG;AAAA,MAClB;AAAA,IACF,GAAG,CAAC,CAAC;AAAA,EACP;AAEA,MAAI,mBAAK,qBAAoB,0BAA0B,cAAc,GAAG;AACtE,WAAO,MAAM,sBAAK,4GAAL,WAAyD;AAAA,MACpE;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAEA,SAAO,MAAM,sBAAK,gHAAL,WAA2D;AAAA,IACtE;AAAA,IACA;AAAA,EACF;AACF;AA4BM;AAAA,wDAAmD,eAAC;AAAA,EACxD;AAAA,EACA;AAAA,EACA;AACF,GAImC;AACjC,QAAM,4BAA4B,MAAM,wBAGtC;AAAA,IACA,QAAQ,CAAC,GAAG,cAAc,EAAE,KAAK;AAAA,IACjC,WAAW;AAAA,IACX,WAAW,OAAO,8BAA8B,UAAU;AACxD,YAAM,oCACJ,MAAM,mBAAK,qBAAoB,iBAAiB;AAAA,QAC9C,gBAAgB;AAAA,QAChB;AAAA,QACA,UAAU;AAAA,MACZ,CAAC;AAEH,aAAO;AAAA,QACL,GAAG;AAAA,QACH,GAAG;AAAA,MACL;AAAA,IACF;AAAA,IACA,eAAe,CAAC;AAAA,EAClB,CAAC;AAED,SAAO,OAAO,QAAQ,yBAAyB,EAAE;AAAA,IAC/C,CAAC,KAAK,CAAC,cAAc,UAAU,MAAM;AACnC,aAAO;AAAA,QACL,GAAG;AAAA,QACH,CAAC,YAAY,GAAG,YAAY;AAAA,MAC9B;AAAA,IACF;AAAA,IACA,CAAC;AAAA,EACH;AACF;AAcM;AAAA,0DAAqD,eAAC;AAAA,EAC1D;AAAA,EACA;AACF,GAGmC;AACjC,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,EACF,IAAI,MAAM,QAAQ,IAAI;AAAA,IACpB,sBAAK,4GAAL,WAAyD;AAAA,MACvD;AAAA,MACA,SAAS,KAAK,OAAO;AAAA,MACrB,gBAAgB;AAAA,IAClB;AAAA,IACA,0BAA0B;AAAA,MACxB,MAAM;AAAA,MACN,IAAI;AAAA,IACN,CAAC;AAAA,EACH,CAAC;AAED,MAAI,mDAAmD,MAAM;AAC3D,WAAO,CAAC;AAAA,EACV;AAEA,SAAO,OAAO,QAAQ,qBAAqB,EAAE;AAAA,IAC3C,CAAC,KAAK,CAAC,cAAc,UAAU,MAAM;AACnC,aAAO;AAAA,QACL,GAAG;AAAA,QACH,CAAC,YAAY,GAAG,aACZ,aAAa,iDACb;AAAA,MACN;AAAA,IACF;AAAA,IACA,CAAC;AAAA,EACH;AACF;AAGF,IAAO,+BAAQ","sourcesContent":["import type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport {\n  safelyExecute,\n  toChecksumHexAddress,\n  FALL_BACK_VS_CURRENCY,\n  toHex,\n} from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkState,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingControllerV1 } from '@metamask/polling-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { createDeferredPromise, type Hex } from '@metamask/utils';\nimport { isEqual } from 'lodash';\n\nimport { reduceInBatchesSerially, TOKEN_PRICES_BATCH_SIZE } from './assetsUtil';\nimport { fetchExchangeRate as fetchNativeCurrencyExchangeRate } from './crypto-compare';\nimport type { AbstractTokenPricesService } from './token-prices-service/abstract-token-prices-service';\nimport type { TokensState } from './TokensController';\n\n/**\n * @type Token\n *\n * Token representation\n * @property address - Hex address of the token contract\n * @property decimals - Number of decimals the token uses\n * @property symbol - Symbol of the token\n * @property image - Image of the token, url or bit32 image\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface Token {\n  address: string;\n  decimals: number;\n  symbol: string;\n  aggregators?: string[];\n  image?: string;\n  balanceError?: unknown;\n  isERC721?: boolean;\n  name?: string;\n}\n\n/**\n * @type TokenRatesConfig\n *\n * Token rates controller configuration\n * @property interval - Polling interval used to fetch new token rates\n * @property nativeCurrency - Current native currency selected to use base of rates\n * @property chainId - Current network chainId\n * @property tokens - List of tokens to track exchange rates for\n * @property threshold - Threshold to invalidate the supportedChains\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface TokenRatesConfig extends BaseConfig {\n  interval: number;\n  nativeCurrency: string;\n  chainId: Hex;\n  selectedAddress: string;\n  allTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  allDetectedTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  threshold: number;\n}\n\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface ContractExchangeRates {\n  [address: string]: number | undefined;\n}\n\nenum PollState {\n  Active = 'Active',\n  Inactive = 'Inactive',\n}\n\n/**\n * @type TokenRatesState\n *\n * Token rates controller state\n * @property contractExchangeRates - Hash of token contract addresses to exchange rates (single globally selected chain, will be deprecated soon)\n * @property contractExchangeRatesByChainId - Hash of token contract addresses to exchange rates keyed by chain ID and native currency (ticker)\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface TokenRatesState extends BaseState {\n  contractExchangeRates: ContractExchangeRates;\n  contractExchangeRatesByChainId: Record<\n    Hex,\n    Record<string, ContractExchangeRates>\n  >;\n}\n\n/**\n * Uses the CryptoCompare API to fetch the exchange rate between one currency\n * and another, i.e., the multiplier to apply the amount of one currency in\n * order to convert it to another.\n *\n * @param args - The arguments to this function.\n * @param args.from - The currency to convert from.\n * @param args.to - The currency to convert to.\n * @returns The exchange rate between `fromCurrency` to `toCurrency` if one\n * exists, or null if one does not.\n */\nasync function getCurrencyConversionRate({\n  from,\n  to,\n}: {\n  from: string;\n  to: string;\n}) {\n  const includeUSDRate = false;\n  try {\n    const result = await fetchNativeCurrencyExchangeRate(\n      to,\n      from,\n      includeUSDRate,\n    );\n    return result.conversionRate;\n  } catch (error) {\n    if (\n      error instanceof Error &&\n      error.message.includes('market does not exist for this coin pair')\n    ) {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n * Controller that passively polls on a set interval for token-to-fiat exchange rates\n * for tokens stored in the TokensController\n */\nexport class TokenRatesController extends StaticIntervalPollingControllerV1<\n  TokenRatesConfig,\n  TokenRatesState\n> {\n  private handle?: ReturnType<typeof setTimeout>;\n\n  #pollState = PollState.Inactive;\n\n  #tokenPricesService: AbstractTokenPricesService;\n\n  #inProcessExchangeRateUpdates: Record<`${Hex}:${string}`, Promise<void>> = {};\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokenRatesController';\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  /**\n   * Creates a TokenRatesController instance.\n   *\n   * @param options - The controller options.\n   * @param options.interval - The polling interval in ms\n   * @param options.threshold - The duration in ms before metadata fetched from CoinGecko is considered stale\n   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.ticker - The ticker for the current network.\n   * @param options.selectedAddress - The current selected address.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onTokensStateChange - Allows subscribing to token controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network state changes.\n   * @param options.tokenPricesService - An object in charge of retrieving token prices.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      interval = 3 * 60 * 1000,\n      threshold = 6 * 60 * 60 * 1000,\n      getNetworkClientById,\n      chainId: initialChainId,\n      ticker: initialTicker,\n      selectedAddress: initialSelectedAddress,\n      onPreferencesStateChange,\n      onTokensStateChange,\n      onNetworkStateChange,\n      tokenPricesService,\n    }: {\n      interval?: number;\n      threshold?: number;\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n      chainId: Hex;\n      ticker: string;\n      selectedAddress: string;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onTokensStateChange: (\n        listener: (tokensState: TokensState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      tokenPricesService: AbstractTokenPricesService;\n    },\n    config?: Partial<TokenRatesConfig>,\n    state?: Partial<TokenRatesState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval,\n      threshold,\n      disabled: false,\n      nativeCurrency: initialTicker,\n      chainId: initialChainId,\n      selectedAddress: initialSelectedAddress,\n      allTokens: {}, // TODO: initialize these correctly, maybe as part of BaseControllerV2 migration\n      allDetectedTokens: {},\n    };\n\n    this.defaultState = {\n      contractExchangeRates: {},\n      contractExchangeRatesByChainId: {},\n    };\n    this.initialize();\n    this.setIntervalLength(interval);\n    this.getNetworkClientById = getNetworkClientById;\n    this.#tokenPricesService = tokenPricesService;\n\n    if (config?.disabled) {\n      this.configure({ disabled: true }, false, false);\n    }\n\n    onPreferencesStateChange(async ({ selectedAddress }) => {\n      if (this.config.selectedAddress !== selectedAddress) {\n        this.configure({ selectedAddress });\n        if (this.#pollState === PollState.Active) {\n          await this.updateExchangeRates();\n        }\n      }\n    });\n\n    onTokensStateChange(async ({ allTokens, allDetectedTokens }) => {\n      const previousTokenAddresses = this.#getTokenAddresses(\n        this.config.chainId,\n      );\n      this.configure({ allTokens, allDetectedTokens });\n      const newTokenAddresses = this.#getTokenAddresses(this.config.chainId);\n      if (\n        !isEqual(previousTokenAddresses, newTokenAddresses) &&\n        this.#pollState === PollState.Active\n      ) {\n        await this.updateExchangeRates();\n      }\n    });\n\n    onNetworkStateChange(async ({ providerConfig }) => {\n      const { chainId, ticker } = providerConfig;\n      if (\n        this.config.chainId !== chainId ||\n        this.config.nativeCurrency !== ticker\n      ) {\n        this.update({ contractExchangeRates: {} });\n        this.configure({ chainId, nativeCurrency: ticker });\n        if (this.#pollState === PollState.Active) {\n          await this.updateExchangeRates();\n        }\n      }\n    });\n  }\n\n  /**\n   * Get the user's tokens for the given chain.\n   *\n   * @param chainId - The chain ID.\n   * @returns The list of tokens addresses for the current chain\n   */\n  #getTokenAddresses(chainId: Hex): Hex[] {\n    const { allTokens, allDetectedTokens } = this.config;\n    const tokens = allTokens[chainId]?.[this.config.selectedAddress] || [];\n    const detectedTokens =\n      allDetectedTokens[chainId]?.[this.config.selectedAddress] || [];\n\n    return [\n      ...new Set(\n        [...tokens, ...detectedTokens].map((token) =>\n          toHex(toChecksumHexAddress(token.address)),\n        ),\n      ),\n    ].sort();\n  }\n\n  /**\n   * Start (or restart) polling.\n   */\n  async start() {\n    this.#stopPoll();\n    this.#pollState = PollState.Active;\n    await this.#poll();\n  }\n\n  /**\n   * Stop polling.\n   */\n  stop() {\n    this.#stopPoll();\n    this.#pollState = PollState.Inactive;\n  }\n\n  /**\n   * Clear the active polling timer, if present.\n   */\n  #stopPoll() {\n    if (this.handle) {\n      clearTimeout(this.handle);\n    }\n  }\n\n  /**\n   * Poll for exchange rate updates.\n   */\n  async #poll() {\n    await safelyExecute(() => this.updateExchangeRates());\n\n    // Poll using recursive `setTimeout` instead of `setInterval` so that\n    // requests don't stack if they take longer than the polling interval\n    this.handle = setTimeout(() => {\n      this.#poll();\n    }, this.config.interval);\n  }\n\n  /**\n   * Updates exchange rates for all tokens.\n   */\n  async updateExchangeRates() {\n    const { chainId, nativeCurrency } = this.config;\n    await this.updateExchangeRatesByChainId({\n      chainId,\n      nativeCurrency,\n    });\n  }\n\n  /**\n   * Updates exchange rates for all tokens.\n   *\n   * @param options - The options to fetch exchange rates.\n   * @param options.chainId - The chain ID.\n   * @param options.nativeCurrency - The ticker for the chain.\n   */\n  async updateExchangeRatesByChainId({\n    chainId,\n    nativeCurrency,\n  }: {\n    chainId: Hex;\n    nativeCurrency: string;\n  }) {\n    if (this.disabled) {\n      return;\n    }\n\n    const tokenAddresses = this.#getTokenAddresses(chainId);\n    if (tokenAddresses.length === 0) {\n      return;\n    }\n\n    const updateKey: `${Hex}:${string}` = `${chainId}:${nativeCurrency}`;\n    if (updateKey in this.#inProcessExchangeRateUpdates) {\n      // This prevents redundant updates\n      // This promise is resolved after the in-progress update has finished,\n      // and state has been updated.\n      await this.#inProcessExchangeRateUpdates[updateKey];\n      return;\n    }\n\n    const {\n      promise: inProgressUpdate,\n      resolve: updateSucceeded,\n      reject: updateFailed,\n    } = createDeferredPromise({ suppressUnhandledRejection: true });\n    this.#inProcessExchangeRateUpdates[updateKey] = inProgressUpdate;\n\n    try {\n      const newContractExchangeRates = await this.#fetchAndMapExchangeRates({\n        tokenAddresses,\n        chainId,\n        nativeCurrency,\n      });\n\n      const existingContractExchangeRates = this.state.contractExchangeRates;\n      const updatedContractExchangeRates =\n        chainId === this.config.chainId &&\n        nativeCurrency === this.config.nativeCurrency\n          ? newContractExchangeRates\n          : existingContractExchangeRates;\n\n      const existingContractExchangeRatesForChainId =\n        this.state.contractExchangeRatesByChainId[chainId] ?? {};\n      const updatedContractExchangeRatesForChainId = {\n        ...this.state.contractExchangeRatesByChainId,\n        [chainId]: {\n          ...existingContractExchangeRatesForChainId,\n          [nativeCurrency]: {\n            ...existingContractExchangeRatesForChainId[nativeCurrency],\n            ...newContractExchangeRates,\n          },\n        },\n      };\n\n      this.update({\n        contractExchangeRates: updatedContractExchangeRates,\n        contractExchangeRatesByChainId: updatedContractExchangeRatesForChainId,\n      });\n      updateSucceeded();\n    } catch (error: unknown) {\n      updateFailed(error);\n      throw error;\n    } finally {\n      delete this.#inProcessExchangeRateUpdates[updateKey];\n    }\n  }\n\n  /**\n   * Uses the token prices service to retrieve exchange rates for tokens in a\n   * particular currency.\n   *\n   * If the price API does not support the given chain ID, returns an empty\n   * object.\n   *\n   * If the price API does not support the given currency, retrieves exchange\n   * rates in a known currency instead, then converts those rates using the\n   * exchange rate between the known currency and desired currency.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.chainId - The EIP-155 ID of the chain where the tokens live.\n   * @param args.nativeCurrency - The native currency in which to request\n   * exchange rates.\n   * @returns A map from token address to its exchange rate in the native\n   * currency, or an empty map if no exchange rates can be obtained for the\n   * chain ID.\n   */\n  async #fetchAndMapExchangeRates({\n    tokenAddresses,\n    chainId,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    chainId: Hex;\n    nativeCurrency: string;\n  }): Promise<ContractExchangeRates> {\n    if (!this.#tokenPricesService.validateChainIdSupported(chainId)) {\n      return tokenAddresses.reduce((obj, tokenAddress) => {\n        return {\n          ...obj,\n          [tokenAddress]: undefined,\n        };\n      }, {});\n    }\n\n    if (this.#tokenPricesService.validateCurrencySupported(nativeCurrency)) {\n      return await this.#fetchAndMapExchangeRatesForSupportedNativeCurrency({\n        tokenAddresses,\n        chainId,\n        nativeCurrency,\n      });\n    }\n\n    return await this.#fetchAndMapExchangeRatesForUnsupportedNativeCurrency({\n      tokenAddresses,\n      nativeCurrency,\n    });\n  }\n\n  /**\n   * Updates token rates for the given networkClientId\n   *\n   * @param networkClientId - The network client ID used to get a ticker value.\n   * @returns The controller state.\n   */\n  async _executePoll(networkClientId: NetworkClientId): Promise<void> {\n    const networkClient = this.getNetworkClientById(networkClientId);\n    await this.updateExchangeRatesByChainId({\n      chainId: networkClient.configuration.chainId,\n      nativeCurrency: networkClient.configuration.ticker,\n    });\n  }\n\n  /**\n   * Retrieves prices in the given currency for the given tokens on the given\n   * chain. Ensures that token addresses are checksum addresses.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.chainId - The EIP-155 ID of the chain where the tokens live.\n   * @param args.nativeCurrency - The native currency in which to request\n   * prices.\n   * @returns A map of the token addresses (as checksums) to their prices in the\n   * native currency.\n   */\n  async #fetchAndMapExchangeRatesForSupportedNativeCurrency({\n    tokenAddresses,\n    chainId,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    chainId: Hex;\n    nativeCurrency: string;\n  }): Promise<ContractExchangeRates> {\n    const tokenPricesByTokenAddress = await reduceInBatchesSerially<\n      Hex,\n      Awaited<ReturnType<AbstractTokenPricesService['fetchTokenPrices']>>\n    >({\n      values: [...tokenAddresses].sort(),\n      batchSize: TOKEN_PRICES_BATCH_SIZE,\n      eachBatch: async (allTokenPricesByTokenAddress, batch) => {\n        const tokenPricesByTokenAddressForBatch =\n          await this.#tokenPricesService.fetchTokenPrices({\n            tokenAddresses: batch,\n            chainId,\n            currency: nativeCurrency,\n          });\n\n        return {\n          ...allTokenPricesByTokenAddress,\n          ...tokenPricesByTokenAddressForBatch,\n        };\n      },\n      initialResult: {},\n    });\n\n    return Object.entries(tokenPricesByTokenAddress).reduce(\n      (obj, [tokenAddress, tokenPrice]) => {\n        return {\n          ...obj,\n          [tokenAddress]: tokenPrice?.value,\n        };\n      },\n      {},\n    );\n  }\n\n  /**\n   * If the price API does not support a given native currency, then we need to\n   * convert it to a fallback currency and feed that currency into the price\n   * API, then convert the prices to our desired native currency.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.nativeCurrency - The native currency in which to request\n   * prices.\n   * @returns A map of the token addresses (as checksums) to their prices in the\n   * native currency.\n   */\n  async #fetchAndMapExchangeRatesForUnsupportedNativeCurrency({\n    tokenAddresses,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    nativeCurrency: string;\n  }): Promise<ContractExchangeRates> {\n    const [\n      contractExchangeRates,\n      fallbackCurrencyToNativeCurrencyConversionRate,\n    ] = await Promise.all([\n      this.#fetchAndMapExchangeRatesForSupportedNativeCurrency({\n        tokenAddresses,\n        chainId: this.config.chainId,\n        nativeCurrency: FALL_BACK_VS_CURRENCY,\n      }),\n      getCurrencyConversionRate({\n        from: FALL_BACK_VS_CURRENCY,\n        to: nativeCurrency,\n      }),\n    ]);\n\n    if (fallbackCurrencyToNativeCurrencyConversionRate === null) {\n      return {};\n    }\n\n    return Object.entries(contractExchangeRates).reduce(\n      (obj, [tokenAddress, tokenValue]) => {\n        return {\n          ...obj,\n          [tokenAddress]: tokenValue\n            ? tokenValue * fallbackCurrencyToNativeCurrencyConversionRate\n            : undefined,\n        };\n      },\n      {},\n    );\n  }\n}\n\nexport default TokenRatesController;\n"]}
\ No newline at end of file
diff --git a/dist/chunk-KM3J4DO6.js b/dist/chunk-KM3J4DO6.js
deleted file mode 100644
index fdf5435ad1e6d0b32c20b516534be60fd8e201b4..0000000000000000000000000000000000000000
--- a/dist/chunk-KM3J4DO6.js
+++ /dev/null
@@ -1,1182 +0,0 @@
-"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
-
-
-var _chunkLS6R3HQLjs = require('./chunk-LS6R3HQL.js');
-
-// src/NftController.ts
-var _address = require('@ethersproject/address');
-var _basecontroller = require('@metamask/base-controller');
-
-
-
-
-
-
-
-
-
-
-
-var _controllerutils = require('@metamask/controller-utils');
-var _rpcerrors = require('@metamask/rpc-errors');
-var _utils = require('@metamask/utils');
-var _asyncmutex = require('async-mutex');
-var _bnjs = require('bn.js'); var _bnjs2 = _interopRequireDefault(_bnjs);
-var _events = require('events');
-var _uuid = require('uuid');
-var ALL_NFTS_STATE_KEY = "allNfts";
-var ALL_NFTS_CONTRACTS_STATE_KEY = "allNftContracts";
-var getDefaultNftState = () => {
-  return {
-    allNftContracts: {},
-    allNfts: {},
-    ignoredNfts: []
-  };
-};
-var NftController = class extends _basecontroller.BaseControllerV1 {
-  /**
-   * Creates an NftController instance.
-   *
-   * @param options - The controller options.
-   * @param options.chainId - The chain ID of the current network.
-   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
-   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
-   * @param options.getERC721AssetName - Gets the name of the asset at the given address.
-   * @param options.getERC721AssetSymbol - Gets the symbol of the asset at the given address.
-   * @param options.getERC721TokenURI - Gets the URI of the ERC721 token at the given address, with the given ID.
-   * @param options.getERC721OwnerOf - Get the owner of a ERC-721 NFT.
-   * @param options.getERC1155BalanceOf - Gets balance of a ERC-1155 NFT.
-   * @param options.getERC1155TokenURI - Gets the URI of the ERC1155 token at the given address, with the given ID.
-   * @param options.getNetworkClientById - Gets the network client for the given networkClientId.
-   * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data
-   * for tracking the NFT added event.
-   * @param options.messenger - The controller messenger.
-   * @param config - Initial options used to configure this controller.
-   * @param state - Initial state to set on this controller.
-   */
-  constructor({
-    chainId: initialChainId,
-    onPreferencesStateChange,
-    onNetworkStateChange,
-    getERC721AssetName,
-    getERC721AssetSymbol,
-    getERC721TokenURI,
-    getERC721OwnerOf,
-    getERC1155BalanceOf,
-    getERC1155TokenURI,
-    getNetworkClientById,
-    onNftAdded,
-    messenger
-  }, config, state) {
-    super(config, state);
-    this.mutex = new (0, _asyncmutex.Mutex)();
-    /**
-     * EventEmitter instance used to listen to specific EIP747 events
-     */
-    this.hub = new (0, _events.EventEmitter)();
-    /**
-     * Name of this controller used during composition
-     */
-    this.name = "NftController";
-    this.defaultConfig = {
-      selectedAddress: "",
-      chainId: initialChainId,
-      ipfsGateway: _controllerutils.IPFS_DEFAULT_GATEWAY_URL,
-      openSeaEnabled: false,
-      useIPFSSubdomains: true,
-      isIpfsGatewayEnabled: true
-    };
-    this.defaultState = getDefaultNftState();
-    this.initialize();
-    this.getERC721AssetName = getERC721AssetName;
-    this.getERC721AssetSymbol = getERC721AssetSymbol;
-    this.getERC721TokenURI = getERC721TokenURI;
-    this.getERC721OwnerOf = getERC721OwnerOf;
-    this.getERC1155BalanceOf = getERC1155BalanceOf;
-    this.getERC1155TokenURI = getERC1155TokenURI;
-    this.getNetworkClientById = getNetworkClientById;
-    this.onNftAdded = onNftAdded;
-    this.messagingSystem = messenger;
-    onPreferencesStateChange(
-      async ({
-        selectedAddress,
-        ipfsGateway,
-        openSeaEnabled,
-        isIpfsGatewayEnabled
-      }) => {
-        this.configure({
-          selectedAddress,
-          ipfsGateway,
-          openSeaEnabled,
-          isIpfsGatewayEnabled
-        });
-        const needsUpdateNftMetadata = isIpfsGatewayEnabled && ipfsGateway !== "" || openSeaEnabled;
-        if (needsUpdateNftMetadata) {
-          const { chainId } = this.config;
-          const nfts = this.state.allNfts[selectedAddress]?.[chainId] ?? [];
-          const nftsToUpdate = nfts.filter(
-            (singleNft) => !singleNft.name && !singleNft.description && !singleNft.image
-          );
-          if (nftsToUpdate.length !== 0) {
-            await this.updateNftMetadata({
-              nfts: nftsToUpdate,
-              userAddress: selectedAddress
-            });
-          }
-        }
-      }
-    );
-    onNetworkStateChange(({ providerConfig }) => {
-      const { chainId } = providerConfig;
-      this.configure({ chainId });
-    });
-  }
-  getNftApi() {
-    return `${_controllerutils.NFT_API_BASE_URL}/tokens`;
-  }
-  /**
-   * Helper method to update nested state for allNfts and allNftContracts.
-   *
-   * @param newCollection - the modified piece of state to update in the controller's store
-   * @param baseStateKey - The root key in the store to update.
-   * @param passedConfig - An object containing the selectedAddress and chainId that are passed through the auto-detection flow.
-   * @param passedConfig.userAddress - the address passed through the NFT detection flow to ensure assets are stored to the correct account
-   * @param passedConfig.chainId - the chainId passed through the NFT detection flow to ensure assets are stored to the correct account
-   */
-  updateNestedNftState(newCollection, baseStateKey, { userAddress, chainId }) {
-    const { [baseStateKey]: oldState } = this.state;
-    const addressState = oldState[userAddress];
-    const newAddressState = {
-      ...addressState,
-      ...{ [chainId]: newCollection }
-    };
-    const newState = {
-      ...oldState,
-      ...{ [userAddress]: newAddressState }
-    };
-    this.update({
-      [baseStateKey]: newState
-    });
-  }
-  /**
-   * Request individual NFT information from NFT API.
-   *
-   * @param contractAddress - Hex address of the NFT contract.
-   * @param tokenId - The NFT identifier.
-   * @returns Promise resolving to the current NFT name and image.
-   */
-  async getNftInformationFromApi(contractAddress, tokenId) {
-    const urlParams = new URLSearchParams({
-      chainIds: "1",
-      tokens: `${contractAddress}:${tokenId}`,
-      includeTopBid: "true",
-      includeAttributes: "true",
-      includeLastSale: "true"
-    }).toString();
-    const nftInformation = await _controllerutils.fetchWithErrorHandling.call(void 0, {
-      url: `${this.getNftApi()}?${urlParams}`,
-      options: {
-        headers: {
-          Version: "1"
-        }
-      }
-    });
-    if (!nftInformation?.tokens?.[0]?.token) {
-      return {
-        name: null,
-        description: null,
-        image: null,
-        standard: null
-      };
-    }
-    const {
-      image,
-      metadata: { imageOriginal } = {},
-      name,
-      description,
-      collection,
-      kind,
-      rarityRank,
-      rarity,
-      attributes,
-      lastSale,
-      imageSmall
-    } = nftInformation.tokens[0].token;
-    const nftMetadata = Object.assign(
-      {},
-      { name: name || null },
-      { description: description || null },
-      { image: image || null },
-      collection?.creator && { creator: collection.creator },
-      imageOriginal && { imageOriginal },
-      imageSmall && { imageThumbnail: imageSmall },
-      kind && { standard: kind.toUpperCase() },
-      lastSale && { lastSale },
-      attributes && { attributes },
-      nftInformation.tokens[0].market?.topBid && {
-        topBid: nftInformation.tokens[0].market?.topBid
-      },
-      rarityRank && { rarityRank },
-      rarity && { rarity },
-      collection && { collection }
-    );
-    return nftMetadata;
-  }
-  /**
-   * Request individual NFT information from contracts that follows Metadata Interface.
-   *
-   * @param contractAddress - Hex address of the NFT contract.
-   * @param tokenId - The NFT identifier.
-   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @returns Promise resolving to the current NFT name and image.
-   */
-  async getNftInformationFromTokenURI(contractAddress, tokenId, networkClientId) {
-    const { ipfsGateway, useIPFSSubdomains, isIpfsGatewayEnabled } = this.config;
-    const result = await this.getNftURIAndStandard(
-      contractAddress,
-      tokenId,
-      networkClientId
-    );
-    let tokenURI = result[0];
-    const standard = result[1];
-    const hasIpfsTokenURI = tokenURI.startsWith("ipfs://");
-    if (hasIpfsTokenURI && !isIpfsGatewayEnabled) {
-      return {
-        image: null,
-        name: null,
-        description: null,
-        standard: standard || null,
-        favorite: false,
-        tokenURI: tokenURI ?? null
-      };
-    }
-    const isDisplayNFTMediaToggleEnabled = this.config.openSeaEnabled;
-    if (!hasIpfsTokenURI && !isDisplayNFTMediaToggleEnabled) {
-      return {
-        image: null,
-        name: null,
-        description: null,
-        standard: standard || null,
-        favorite: false,
-        tokenURI: tokenURI ?? null
-      };
-    }
-    if (hasIpfsTokenURI) {
-      tokenURI = _chunkLS6R3HQLjs.getFormattedIpfsUrl.call(void 0, ipfsGateway, tokenURI, useIPFSSubdomains);
-    }
-    try {
-      const object = await _controllerutils.handleFetch.call(void 0, tokenURI);
-      const image = Object.prototype.hasOwnProperty.call(object, "image") ? "image" : (
-        /* istanbul ignore next */
-        "image_url"
-      );
-      return {
-        image: object[image],
-        name: object.name,
-        description: object.description,
-        standard,
-        favorite: false,
-        tokenURI: tokenURI ?? null
-      };
-    } catch {
-      return {
-        image: null,
-        name: null,
-        description: null,
-        standard: standard || null,
-        favorite: false,
-        tokenURI: tokenURI ?? null
-      };
-    }
-  }
-  /**
-   * Retrieve NFT uri with  metadata. TODO Update method to use IPFS.
-   *
-   * @param contractAddress - NFT contract address.
-   * @param tokenId - NFT token id.
-   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @returns Promise resolving NFT uri and token standard.
-   */
-  async getNftURIAndStandard(contractAddress, tokenId, networkClientId) {
-    try {
-      const uri = await this.getERC721TokenURI(
-        contractAddress,
-        tokenId,
-        networkClientId
-      );
-      return [uri, _controllerutils.ERC721];
-    } catch {
-    }
-    try {
-      const tokenURI = await this.getERC1155TokenURI(
-        contractAddress,
-        tokenId,
-        networkClientId
-      );
-      if (!tokenURI.includes("{id}")) {
-        return [tokenURI, _controllerutils.ERC1155];
-      }
-      const hexTokenId = _utils.remove0x.call(void 0, _controllerutils.BNToHex.call(void 0, new (0, _bnjs2.default)(tokenId))).padStart(64, "0").toLowerCase();
-      return [tokenURI.replace("{id}", hexTokenId), _controllerutils.ERC1155];
-    } catch {
-    }
-    return ["", ""];
-  }
-  /**
-   * Request individual NFT information (name, image url and description).
-   *
-   * @param contractAddress - Hex address of the NFT contract.
-   * @param tokenId - The NFT identifier.
-   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @returns Promise resolving to the current NFT name and image.
-   */
-  async getNftInformation(contractAddress, tokenId, networkClientId) {
-    const chainId = this.getCorrectChainId({
-      networkClientId
-    });
-    const [blockchainMetadata, nftApiMetadata] = await Promise.all([
-      _controllerutils.safelyExecute.call(void 0, 
-        () => this.getNftInformationFromTokenURI(
-          contractAddress,
-          tokenId,
-          networkClientId
-        )
-      ),
-      this.config.openSeaEnabled && chainId === "0x1" ? _controllerutils.safelyExecute.call(void 0, 
-        () => this.getNftInformationFromApi(contractAddress, tokenId)
-      ) : void 0
-    ]);
-    return {
-      ...nftApiMetadata,
-      name: blockchainMetadata?.name ?? nftApiMetadata?.name ?? null,
-      description: blockchainMetadata?.description ?? nftApiMetadata?.description ?? null,
-      image: blockchainMetadata?.image ?? nftApiMetadata?.image ?? null,
-      standard: blockchainMetadata?.standard ?? nftApiMetadata?.standard ?? null,
-      tokenURI: blockchainMetadata?.tokenURI ?? null
-    };
-  }
-  /**
-   * Request NFT contract information from the contract itself.
-   *
-   * @param contractAddress - Hex address of the NFT contract.
-   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @returns Promise resolving to the current NFT name and image.
-   */
-  async getNftContractInformationFromContract(contractAddress, networkClientId) {
-    const [name, symbol] = await Promise.all([
-      this.getERC721AssetName(contractAddress, networkClientId),
-      this.getERC721AssetSymbol(contractAddress, networkClientId)
-    ]);
-    return {
-      collection: { name },
-      symbol,
-      address: contractAddress
-    };
-  }
-  /**
-   * Request NFT contract information from Blockchain and aggregate with received data from NFTMetadata.
-   *
-   * @param contractAddress - Hex address of the NFT contract.
-   * @param nftMetadataFromApi - Received NFT information to be aggregated with blockchain contract information.
-   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @returns Promise resolving to the NFT contract name, image and description.
-   */
-  async getNftContractInformation(contractAddress, nftMetadataFromApi, networkClientId) {
-    const blockchainContractData = await _controllerutils.safelyExecute.call(void 0, 
-      () => this.getNftContractInformationFromContract(
-        contractAddress,
-        networkClientId
-      )
-    );
-    if (blockchainContractData || !Object.values(nftMetadataFromApi).every((value) => value === null)) {
-      return {
-        address: contractAddress,
-        ...blockchainContractData,
-        schema_name: nftMetadataFromApi?.standard ?? null,
-        collection: {
-          name: null,
-          image_url: nftMetadataFromApi?.collection?.image ?? nftMetadataFromApi?.collection?.imageUrl ?? null,
-          tokenCount: nftMetadataFromApi?.collection?.tokenCount ?? null,
-          ...nftMetadataFromApi?.collection,
-          ...blockchainContractData?.collection
-        }
-      };
-    }
-    return {
-      address: contractAddress,
-      asset_contract_type: null,
-      created_date: null,
-      schema_name: null,
-      symbol: null,
-      total_supply: null,
-      description: null,
-      external_link: null,
-      collection: { name: null, image_url: null }
-    };
-  }
-  /**
-   * Adds an individual NFT to the stored NFT list.
-   *
-   * @param tokenAddress - Hex address of the NFT contract.
-   * @param tokenId - The NFT identifier.
-   * @param nftMetadata - NFT optional information (name, image and description).
-   * @param nftContract - An object containing contract data of the NFT being added.
-   * @param chainId - The chainId of the network where the NFT is being added.
-   * @param userAddress - The address of the account where the NFT is being added.
-   * @param source - Whether the NFT was detected, added manually or suggested by a dapp.
-   * @returns Promise resolving to the current NFT list.
-   */
-  async addIndividualNft(tokenAddress, tokenId, nftMetadata, nftContract, chainId, userAddress, source) {
-    const releaseLock = await this.mutex.acquire();
-    try {
-      tokenAddress = _controllerutils.toChecksumHexAddress.call(void 0, tokenAddress);
-      const { allNfts } = this.state;
-      const nfts = allNfts[userAddress]?.[chainId] || [];
-      const existingEntry = nfts.find(
-        (nft) => nft.address.toLowerCase() === tokenAddress.toLowerCase() && nft.tokenId === tokenId
-      );
-      if (existingEntry) {
-        const differentMetadata = _chunkLS6R3HQLjs.compareNftMetadata.call(void 0, 
-          nftMetadata,
-          existingEntry
-        );
-        if (differentMetadata || !existingEntry.isCurrentlyOwned) {
-          const indexToRemove = nfts.findIndex(
-            (nft) => nft.address.toLowerCase() === tokenAddress.toLowerCase() && nft.tokenId === tokenId
-          );
-          if (indexToRemove !== -1) {
-            nfts.splice(indexToRemove, 1);
-          }
-        } else {
-          return nfts;
-        }
-      }
-      const newEntry = {
-        address: tokenAddress,
-        tokenId,
-        favorite: existingEntry?.favorite || false,
-        isCurrentlyOwned: true,
-        ...nftMetadata
-      };
-      const newNfts = [...nfts, newEntry];
-      this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
-        chainId,
-        userAddress
-      });
-      if (this.onNftAdded) {
-        this.onNftAdded({
-          address: tokenAddress,
-          symbol: nftContract.symbol,
-          tokenId: tokenId.toString(),
-          standard: nftMetadata.standard,
-          source
-        });
-      }
-      return newNfts;
-    } finally {
-      releaseLock();
-    }
-  }
-  /**
-   * Adds an NFT contract to the stored NFT contracts list.
-   *
-   * @param options - options.
-   * @param options.tokenAddress - Hex address of the NFT contract.
-   * @param options.userAddress - The address of the account where the NFT is being added.
-   * @param options.nftMetadata - The retrieved NFTMetadata from API.
-   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
-   * @returns Promise resolving to the current NFT contracts list.
-   */
-  async addNftContract({
-    tokenAddress,
-    userAddress,
-    networkClientId,
-    source,
-    nftMetadata
-  }) {
-    const releaseLock = await this.mutex.acquire();
-    try {
-      tokenAddress = _controllerutils.toChecksumHexAddress.call(void 0, tokenAddress);
-      const { allNftContracts } = this.state;
-      const chainId = this.getCorrectChainId({
-        networkClientId
-      });
-      const nftContracts = allNftContracts[userAddress]?.[chainId] || [];
-      const existingEntry = nftContracts.find(
-        (nftContract) => nftContract.address.toLowerCase() === tokenAddress.toLowerCase()
-      );
-      if (existingEntry) {
-        return nftContracts;
-      }
-      const contractInformation = await this.getNftContractInformation(
-        tokenAddress,
-        nftMetadata,
-        networkClientId
-      );
-      const {
-        asset_contract_type,
-        created_date,
-        symbol,
-        description,
-        external_link,
-        schema_name,
-        collection: { name, image_url, tokenCount }
-      } = contractInformation;
-      if (source === "detected" /* Detected */ && "address" in contractInformation && typeof contractInformation.address === "string" && "collection" in contractInformation && contractInformation.collection.name === null && "image_url" in contractInformation.collection && contractInformation.collection.image_url === null && Object.entries(contractInformation).every(([key, value]) => {
-        return key === "address" || key === "collection" || !value;
-      })) {
-        return nftContracts;
-      }
-      const newEntry = Object.assign(
-        {},
-        { address: tokenAddress },
-        description && { description },
-        name && { name },
-        image_url && { logo: image_url },
-        symbol && { symbol },
-        tokenCount !== null && typeof tokenCount !== "undefined" && { totalSupply: tokenCount },
-        asset_contract_type && { assetContractType: asset_contract_type },
-        created_date && { createdDate: created_date },
-        schema_name && { schemaName: schema_name },
-        external_link && { externalLink: external_link }
-      );
-      const newNftContracts = [...nftContracts, newEntry];
-      this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {
-        chainId,
-        userAddress
-      });
-      return newNftContracts;
-    } finally {
-      releaseLock();
-    }
-  }
-  /**
-   * Removes an individual NFT from the stored token list and saves it in ignored NFTs list.
-   *
-   * @param address - Hex address of the NFT contract.
-   * @param tokenId - Token identifier of the NFT.
-   * @param options - options.
-   * @param options.chainId - The chainId of the network where the NFT is being removed.
-   * @param options.userAddress - The address of the account where the NFT is being removed.
-   */
-  removeAndIgnoreIndividualNft(address, tokenId, {
-    chainId,
-    userAddress
-  }) {
-    address = _controllerutils.toChecksumHexAddress.call(void 0, address);
-    const { allNfts, ignoredNfts } = this.state;
-    const newIgnoredNfts = [...ignoredNfts];
-    const nfts = allNfts[userAddress]?.[chainId] || [];
-    const newNfts = nfts.filter((nft) => {
-      if (nft.address.toLowerCase() === address.toLowerCase() && nft.tokenId === tokenId) {
-        const alreadyIgnored = newIgnoredNfts.find(
-          (c) => c.address === address && c.tokenId === tokenId
-        );
-        !alreadyIgnored && newIgnoredNfts.push(nft);
-        return false;
-      }
-      return true;
-    });
-    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
-      userAddress,
-      chainId
-    });
-    this.update({
-      ignoredNfts: newIgnoredNfts
-    });
-  }
-  /**
-   * Removes an individual NFT from the stored token list.
-   *
-   * @param address - Hex address of the NFT contract.
-   * @param tokenId - Token identifier of the NFT.
-   * @param options - options.
-   * @param options.chainId - The chainId of the network where the NFT is being removed.
-   * @param options.userAddress - The address of the account where the NFT is being removed.
-   */
-  removeIndividualNft(address, tokenId, { chainId, userAddress }) {
-    address = _controllerutils.toChecksumHexAddress.call(void 0, address);
-    const { allNfts } = this.state;
-    const nfts = allNfts[userAddress]?.[chainId] || [];
-    const newNfts = nfts.filter(
-      (nft) => !(nft.address.toLowerCase() === address.toLowerCase() && nft.tokenId === tokenId)
-    );
-    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
-      userAddress,
-      chainId
-    });
-  }
-  /**
-   * Removes an NFT contract to the stored NFT contracts list.
-   *
-   * @param address - Hex address of the NFT contract.
-   * @param options - options.
-   * @param options.chainId - The chainId of the network where the NFT is being removed.
-   * @param options.userAddress - The address of the account where the NFT is being removed.
-   * @returns Promise resolving to the current NFT contracts list.
-   */
-  removeNftContract(address, { chainId, userAddress }) {
-    address = _controllerutils.toChecksumHexAddress.call(void 0, address);
-    const { allNftContracts } = this.state;
-    const nftContracts = allNftContracts[userAddress]?.[chainId] || [];
-    const newNftContracts = nftContracts.filter(
-      (nftContract) => !(nftContract.address.toLowerCase() === address.toLowerCase())
-    );
-    this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {
-      chainId,
-      userAddress
-    });
-    return newNftContracts;
-  }
-  async validateWatchNft(asset, type, userAddress, { networkClientId } = {}) {
-    const { address: contractAddress, tokenId } = asset;
-    if (!type) {
-      throw _rpcerrors.rpcErrors.invalidParams("Asset type is required");
-    }
-    if (type !== _controllerutils.ERC721 && type !== _controllerutils.ERC1155) {
-      throw _rpcerrors.rpcErrors.invalidParams(
-        `Non NFT asset type ${type} not supported by watchNft`
-      );
-    }
-    if (!contractAddress || !tokenId) {
-      throw _rpcerrors.rpcErrors.invalidParams("Both address and tokenId are required");
-    }
-    if (!_address.isAddress.call(void 0, contractAddress)) {
-      throw _rpcerrors.rpcErrors.invalidParams("Invalid address");
-    }
-    if (!/^\d+$/u.test(tokenId)) {
-      throw _rpcerrors.rpcErrors.invalidParams("Invalid tokenId");
-    }
-    try {
-      const isOwner = await this.isNftOwner(
-        userAddress,
-        contractAddress,
-        tokenId,
-        { networkClientId }
-      );
-      if (!isOwner) {
-        throw _rpcerrors.rpcErrors.invalidInput(
-          "Suggested NFT is not owned by the selected account"
-        );
-      }
-    } catch (error) {
-      if (error instanceof Error) {
-        throw _rpcerrors.rpcErrors.resourceUnavailable(error.message);
-      }
-      throw error;
-    }
-  }
-  // temporary method to get the correct chainId until we remove chainId from the config & the chainId arg from the detection logic
-  // Just a helper method to prefer the networkClient chainId first then the chainId argument and then finally the config chainId
-  getCorrectChainId({
-    networkClientId
-  }) {
-    if (networkClientId) {
-      return this.getNetworkClientById(networkClientId).configuration.chainId;
-    }
-    return this.config.chainId;
-  }
-  /**
-   * Adds a new suggestedAsset to state. Parameters will be validated according to
-   * asset type being watched. A `<suggestedNftMeta.id>:pending` hub event will be emitted once added.
-   *
-   * @param asset - The asset to be watched. For now ERC721 and ERC1155 tokens are accepted.
-   * @param asset.address - The address of the asset contract.
-   * @param asset.tokenId - The ID of the asset.
-   * @param type - The asset type.
-   * @param origin - Domain origin to register the asset from.
-   * @param options - Options bag.
-   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @param options.userAddress - The address of the account where the NFT is being added.
-   * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.
-   */
-  async watchNft(asset, type, origin, {
-    networkClientId,
-    userAddress = this.config.selectedAddress
-  } = {
-    userAddress: this.config.selectedAddress
-  }) {
-    await this.validateWatchNft(asset, type, userAddress);
-    const nftMetadata = await this.getNftInformation(
-      asset.address,
-      asset.tokenId,
-      networkClientId
-    );
-    if (nftMetadata.standard && nftMetadata.standard !== type) {
-      throw _rpcerrors.rpcErrors.invalidInput(
-        `Suggested NFT of type ${nftMetadata.standard} does not match received type ${type}`
-      );
-    }
-    const suggestedNftMeta = {
-      asset: { ...asset, ...nftMetadata },
-      type,
-      id: _uuid.v4.call(void 0, ),
-      time: Date.now(),
-      interactingAddress: userAddress,
-      origin
-    };
-    await this._requestApproval(suggestedNftMeta);
-    const { address, tokenId } = asset;
-    const { name, standard, description, image } = nftMetadata;
-    await this.addNft(address, tokenId, {
-      nftMetadata: {
-        name: name ?? null,
-        description: description ?? null,
-        image: image ?? null,
-        standard: standard ?? null
-      },
-      userAddress,
-      source: "dapp" /* Dapp */,
-      networkClientId
-    });
-  }
-  /**
-   * Sets an OpenSea API key to retrieve NFT information.
-   *
-   * @param openSeaApiKey - OpenSea API key.
-   */
-  setApiKey(openSeaApiKey) {
-    this.openSeaApiKey = openSeaApiKey;
-  }
-  /**
-   * Checks the ownership of a ERC-721 or ERC-1155 NFT for a given address.
-   *
-   * @param ownerAddress - User public address.
-   * @param nftAddress - NFT contract address.
-   * @param tokenId - NFT token ID.
-   * @param options - Options bag.
-   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @returns Promise resolving the NFT ownership.
-   */
-  async isNftOwner(ownerAddress, nftAddress, tokenId, {
-    networkClientId
-  } = {}) {
-    try {
-      const owner = await this.getERC721OwnerOf(
-        nftAddress,
-        tokenId,
-        networkClientId
-      );
-      return ownerAddress.toLowerCase() === owner.toLowerCase();
-    } catch {
-    }
-    try {
-      const balance = await this.getERC1155BalanceOf(
-        ownerAddress,
-        nftAddress,
-        tokenId,
-        networkClientId
-      );
-      return !balance.isZero();
-    } catch {
-    }
-    throw new Error(
-      `Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.`
-    );
-  }
-  /**
-   * Verifies currently selected address owns entered NFT address/tokenId combo and
-   * adds the NFT and respective NFT contract to the stored NFT and NFT contracts lists.
-   *
-   * @param address - Hex address of the NFT contract.
-   * @param tokenId - The NFT identifier.
-   * @param options - an object of arguments
-   * @param options.userAddress - The address of the current user.
-   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
-   */
-  async addNftVerifyOwnership(address, tokenId, {
-    userAddress = this.config.selectedAddress,
-    networkClientId,
-    source
-  } = {
-    userAddress: this.config.selectedAddress
-  }) {
-    if (!await this.isNftOwner(userAddress, address, tokenId, {
-      networkClientId
-    })) {
-      throw new Error("This NFT is not owned by the user");
-    }
-    await this.addNft(address, tokenId, {
-      networkClientId,
-      userAddress,
-      source
-    });
-  }
-  /**
-   * Adds an NFT and respective NFT contract to the stored NFT and NFT contracts lists.
-   *
-   * @param tokenAddress - Hex address of the NFT contract.
-   * @param tokenId - The NFT identifier.
-   * @param options - an object of arguments
-   * @param options.nftMetadata - NFT optional metadata.
-   * @param options.userAddress - The address of the current user.
-   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
-   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @returns Promise resolving to the current NFT list.
-   */
-  async addNft(tokenAddress, tokenId, {
-    nftMetadata,
-    userAddress = this.config.selectedAddress,
-    source = "custom" /* Custom */,
-    networkClientId
-  } = { userAddress: this.config.selectedAddress }) {
-    tokenAddress = _controllerutils.toChecksumHexAddress.call(void 0, tokenAddress);
-    const chainId = this.getCorrectChainId({ networkClientId });
-    nftMetadata = nftMetadata || await this.getNftInformation(tokenAddress, tokenId, networkClientId);
-    const newNftContracts = await this.addNftContract({
-      tokenAddress,
-      userAddress,
-      networkClientId,
-      source,
-      nftMetadata
-    });
-    const nftContract = newNftContracts.find(
-      (contract) => contract.address.toLowerCase() === tokenAddress.toLowerCase()
-    );
-    if (nftContract) {
-      await this.addIndividualNft(
-        tokenAddress,
-        tokenId,
-        nftMetadata,
-        nftContract,
-        chainId,
-        userAddress,
-        source
-      );
-    }
-  }
-  /**
-   * Refetches NFT metadata and updates the state
-   *
-   * @param options - Options for refetching NFT metadata
-   * @param options.nfts - nfts to update metadata for.
-   * @param options.userAddress - The current user address
-   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   */
-  async updateNftMetadata({
-    nfts,
-    userAddress = this.config.selectedAddress,
-    networkClientId
-  }) {
-    const chainId = this.getCorrectChainId({ networkClientId });
-    const nftsWithChecksumAdr = nfts.map((nft) => {
-      return {
-        ...nft,
-        address: _controllerutils.toChecksumHexAddress.call(void 0, nft.address)
-      };
-    });
-    const nftMetadataResults = await Promise.allSettled(
-      nftsWithChecksumAdr.map(async (nft) => {
-        const resMetadata = await this.getNftInformation(
-          nft.address,
-          nft.tokenId,
-          networkClientId
-        );
-        return {
-          nft,
-          newMetadata: resMetadata
-        };
-      })
-    );
-    nftMetadataResults.filter(
-      (result) => result.status === "fulfilled"
-    ).forEach(
-      (elm) => this.updateNft(
-        elm.value.nft,
-        elm.value.newMetadata,
-        userAddress,
-        chainId
-      )
-    );
-  }
-  /**
-   * Removes an NFT from the stored token list.
-   *
-   * @param address - Hex address of the NFT contract.
-   * @param tokenId - Token identifier of the NFT.
-   * @param options - an object of arguments
-   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @param options.userAddress - The address of the account where the NFT is being removed.
-   */
-  removeNft(address, tokenId, {
-    networkClientId,
-    userAddress = this.config.selectedAddress
-  } = {
-    userAddress: this.config.selectedAddress
-  }) {
-    const chainId = this.getCorrectChainId({ networkClientId });
-    address = _controllerutils.toChecksumHexAddress.call(void 0, address);
-    this.removeIndividualNft(address, tokenId, { chainId, userAddress });
-    const { allNfts } = this.state;
-    const nfts = allNfts[userAddress]?.[chainId] || [];
-    const remainingNft = nfts.find(
-      (nft) => nft.address.toLowerCase() === address.toLowerCase()
-    );
-    if (!remainingNft) {
-      this.removeNftContract(address, { chainId, userAddress });
-    }
-  }
-  /**
-   * Removes an NFT from the stored token list and saves it in ignored NFTs list.
-   *
-   * @param address - Hex address of the NFT contract.
-   * @param tokenId - Token identifier of the NFT.
-   * @param options - an object of arguments
-   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @param options.userAddress - The address of the account where the NFT is being removed.
-   */
-  removeAndIgnoreNft(address, tokenId, {
-    networkClientId,
-    userAddress = this.config.selectedAddress
-  } = {
-    userAddress: this.config.selectedAddress
-  }) {
-    const chainId = this.getCorrectChainId({ networkClientId });
-    address = _controllerutils.toChecksumHexAddress.call(void 0, address);
-    this.removeAndIgnoreIndividualNft(address, tokenId, {
-      chainId,
-      userAddress
-    });
-    const { allNfts } = this.state;
-    const nfts = allNfts[userAddress]?.[chainId] || [];
-    const remainingNft = nfts.find(
-      (nft) => nft.address.toLowerCase() === address.toLowerCase()
-    );
-    if (!remainingNft) {
-      this.removeNftContract(address, { chainId, userAddress });
-    }
-  }
-  /**
-   * Removes all NFTs from the ignored list.
-   */
-  clearIgnoredNfts() {
-    this.update({ ignoredNfts: [] });
-  }
-  /**
-   * Checks whether input NFT is still owned by the user
-   * And updates the isCurrentlyOwned value on the NFT object accordingly.
-   *
-   * @param nft - The NFT object to check and update.
-   * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.
-   * @param accountParams - The userAddress and chainId to check ownership against
-   * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure assets are stored to the correct account
-   * @param accountParams.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @returns the NFT with the updated isCurrentlyOwned value
-   */
-  async checkAndUpdateSingleNftOwnershipStatus(nft, batch, {
-    userAddress = this.config.selectedAddress,
-    networkClientId
-  } = {
-    userAddress: this.config.selectedAddress
-  }) {
-    const chainId = this.getCorrectChainId({ networkClientId });
-    const { address, tokenId } = nft;
-    let isOwned = nft.isCurrentlyOwned;
-    try {
-      isOwned = await this.isNftOwner(userAddress, address, tokenId, {
-        networkClientId
-      });
-    } catch {
-    }
-    nft.isCurrentlyOwned = isOwned;
-    if (batch) {
-      return nft;
-    }
-    const { allNfts } = this.state;
-    const nfts = allNfts[userAddress]?.[chainId] || [];
-    const nftToUpdate = nfts.find(
-      (item) => item.tokenId === tokenId && item.address.toLowerCase() === address.toLowerCase()
-    );
-    if (nftToUpdate) {
-      nftToUpdate.isCurrentlyOwned = isOwned;
-      this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {
-        userAddress,
-        chainId
-      });
-    }
-    return nft;
-  }
-  /**
-   * Checks whether NFTs associated with current selectedAddress/chainId combination are still owned by the user
-   * And updates the isCurrentlyOwned value on each accordingly.
-   * @param options - an object of arguments
-   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @param options.userAddress - The address of the account where the NFT ownership status is checked/updated.
-   */
-  async checkAndUpdateAllNftsOwnershipStatus({
-    networkClientId,
-    userAddress = this.config.selectedAddress
-  } = {
-    userAddress: this.config.selectedAddress
-  }) {
-    const chainId = this.getCorrectChainId({ networkClientId });
-    const { allNfts } = this.state;
-    const nfts = allNfts[userAddress]?.[chainId] || [];
-    const updatedNfts = await Promise.all(
-      nfts.map(async (nft) => {
-        return await this.checkAndUpdateSingleNftOwnershipStatus(nft, true, {
-          networkClientId,
-          userAddress
-        }) ?? nft;
-      })
-    );
-    this.updateNestedNftState(updatedNfts, ALL_NFTS_STATE_KEY, {
-      userAddress,
-      chainId
-    });
-  }
-  /**
-   * Update NFT favorite status.
-   *
-   * @param address - Hex address of the NFT contract.
-   * @param tokenId - Hex address of the NFT contract.
-   * @param favorite - NFT new favorite status.
-   * @param options - an object of arguments
-   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @param options.userAddress - The address of the account where the NFT is being removed.
-   */
-  updateNftFavoriteStatus(address, tokenId, favorite, {
-    networkClientId,
-    userAddress = this.config.selectedAddress
-  } = {
-    userAddress: this.config.selectedAddress
-  }) {
-    const chainId = this.getCorrectChainId({ networkClientId });
-    const { allNfts } = this.state;
-    const nfts = allNfts[userAddress]?.[chainId] || [];
-    const index = nfts.findIndex(
-      (nft) => nft.address === address && nft.tokenId === tokenId
-    );
-    if (index === -1) {
-      return;
-    }
-    const updatedNft = {
-      ...nfts[index],
-      favorite
-    };
-    nfts[index] = updatedNft;
-    this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {
-      chainId,
-      userAddress
-    });
-  }
-  /**
-   * Returns an NFT by the address and token id.
-   *
-   * @param address - Hex address of the NFT contract.
-   * @param tokenId - Number that represents the id of the token.
-   * @param selectedAddress - Hex address of the user account.
-   * @param chainId - Id of the current network.
-   * @returns Object containing the NFT and its position in the array
-   */
-  findNftByAddressAndTokenId(address, tokenId, selectedAddress, chainId) {
-    const { allNfts } = this.state;
-    const nfts = allNfts[selectedAddress]?.[chainId] || [];
-    const index = nfts.findIndex(
-      (nft) => nft.address.toLowerCase() === address.toLowerCase() && nft.tokenId === tokenId
-    );
-    if (index === -1) {
-      return null;
-    }
-    return { nft: nfts[index], index };
-  }
-  /**
-   * Update NFT data.
-   *
-   * @param nft - NFT object to find the right NFT to updates.
-   * @param updates - NFT partial object to update properties of the NFT.
-   * @param selectedAddress - Hex address of the user account.
-   * @param chainId - Id of the current network.
-   */
-  updateNft(nft, updates, selectedAddress, chainId) {
-    const { allNfts } = this.state;
-    const nfts = allNfts[selectedAddress]?.[chainId] || [];
-    const nftInfo = this.findNftByAddressAndTokenId(
-      nft.address,
-      nft.tokenId,
-      selectedAddress,
-      chainId
-    );
-    if (!nftInfo) {
-      return;
-    }
-    const updatedNft = {
-      ...nft,
-      ...updates
-    };
-    const newNfts = [
-      ...nfts.slice(0, nftInfo.index),
-      updatedNft,
-      ...nfts.slice(nftInfo.index + 1)
-    ];
-    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
-      chainId,
-      userAddress: selectedAddress
-    });
-  }
-  /**
-   * Resets the transaction status of an NFT.
-   *
-   * @param transactionId - NFT transaction id.
-   * @param selectedAddress - Hex address of the user account.
-   * @param chainId - Id of the current network.
-   * @returns a boolean indicating if the reset was well succeeded or not
-   */
-  resetNftTransactionStatusByTransactionId(transactionId, selectedAddress, chainId) {
-    const { allNfts } = this.state;
-    const nfts = allNfts[selectedAddress]?.[chainId] || [];
-    const index = nfts.findIndex(
-      (nft) => nft.transactionId === transactionId
-    );
-    if (index === -1) {
-      return false;
-    }
-    const updatedNft = {
-      ...nfts[index],
-      transactionId: void 0
-    };
-    const newNfts = [
-      ...nfts.slice(0, index),
-      updatedNft,
-      ...nfts.slice(index + 1)
-    ];
-    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
-      chainId,
-      userAddress: selectedAddress
-    });
-    return true;
-  }
-  async _requestApproval(suggestedNftMeta) {
-    return this.messagingSystem.call(
-      "ApprovalController:addRequest",
-      {
-        id: suggestedNftMeta.id,
-        origin: suggestedNftMeta.origin,
-        type: _controllerutils.ApprovalType.WatchAsset,
-        requestData: {
-          id: suggestedNftMeta.id,
-          interactingAddress: suggestedNftMeta.interactingAddress,
-          asset: {
-            address: suggestedNftMeta.asset.address,
-            tokenId: suggestedNftMeta.asset.tokenId,
-            name: suggestedNftMeta.asset.name,
-            description: suggestedNftMeta.asset.description,
-            image: suggestedNftMeta.asset.image,
-            standard: suggestedNftMeta.asset.standard
-          }
-        }
-      },
-      true
-    );
-  }
-};
-var NftController_default = NftController;
-
-
-
-
-
-exports.getDefaultNftState = getDefaultNftState; exports.NftController = NftController; exports.NftController_default = NftController_default;
-//# sourceMappingURL=chunk-KM3J4DO6.js.map
\ No newline at end of file
diff --git a/dist/chunk-KM3J4DO6.js.map b/dist/chunk-KM3J4DO6.js.map
deleted file mode 100644
index ce195db356c1d4e5f5c12d1add552e6274a9b441..0000000000000000000000000000000000000000
--- a/dist/chunk-KM3J4DO6.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["../src/NftController.ts"],"names":[],"mappings":"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","sourcesContent":["import { isAddress } from '@ethersproject/address';\nimport type { AddApprovalRequest } from '@metamask/approval-controller';\nimport type {\n  BaseConfig,\n  BaseState,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseControllerV1 } from '@metamask/base-controller';\nimport {\n  safelyExecute,\n  handleFetch,\n  toChecksumHexAddress,\n  BNToHex,\n  fetchWithErrorHandling,\n  IPFS_DEFAULT_GATEWAY_URL,\n  ERC721,\n  ERC1155,\n  ApprovalType,\n  NFT_API_BASE_URL,\n} from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkState,\n} from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { Hex } from '@metamask/utils';\nimport { remove0x } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport BN from 'bn.js';\nimport { EventEmitter } from 'events';\nimport { v4 as random } from 'uuid';\n\nimport type { AssetsContractController } from './AssetsContractController';\nimport { compareNftMetadata, getFormattedIpfsUrl } from './assetsUtil';\nimport { Source } from './constants';\nimport type {\n  ApiNftContract,\n  ReservoirResponse,\n  Collection,\n  Attributes,\n  LastSale,\n} from './NftDetectionController';\n\ntype NFTStandardType = 'ERC721' | 'ERC1155';\n\ntype SuggestedNftMeta = {\n  asset: { address: string; tokenId: string } & NftMetadata;\n  id: string;\n  time: number;\n  type: NFTStandardType;\n  interactingAddress: string;\n  origin: string;\n};\n\n/**\n * @type Nft\n *\n * NFT representation\n * @property address - Hex address of a ERC721 contract\n * @property description - The NFT description\n * @property image - URI of custom NFT image associated with this tokenId\n * @property name - Name associated with this tokenId and contract address\n * @property tokenId - The NFT identifier\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property isCurrentlyOwned - Boolean indicating whether the address/chainId combination where it's currently stored currently owns this NFT\n * @property transactionId - Transaction Id associated with the NFT\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface Nft extends NftMetadata {\n  tokenId: string;\n  address: string;\n  isCurrentlyOwned?: boolean;\n}\n\ntype NftUpdate = {\n  nft: Nft;\n  newMetadata: NftMetadata;\n};\n\n/**\n * @type NftContract\n *\n * NFT contract information representation\n * @property name - Contract name\n * @property logo - Contract logo\n * @property address - Contract address\n * @property symbol - Contract symbol\n * @property description - Contract description\n * @property totalSupply - Total supply of NFTs\n * @property assetContractType - The NFT type, it could be `semi-fungible` or `non-fungible`\n * @property createdDate - Creation date\n * @property schemaName - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property externalLink - External link containing additional information\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftContract {\n  name?: string;\n  logo?: string;\n  address: string;\n  symbol?: string;\n  description?: string;\n  totalSupply?: string;\n  assetContractType?: string;\n  createdDate?: string;\n  schemaName?: string;\n  externalLink?: string;\n}\n\n/**\n * @type NftMetadata\n *\n * NFT custom information\n * @property name - NFT custom name\n * @property description - The NFT description\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property image - Image custom image URI\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property standard - NFT standard name for the NFT, e.g., ERC-721 or ERC-1155\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftMetadata {\n  name: string | null;\n  description: string | null;\n  image: string | null;\n  standard: string | null;\n  favorite?: boolean;\n  numberOfSales?: number;\n  backgroundColor?: string;\n  imagePreview?: string;\n  imageThumbnail?: string;\n  imageOriginal?: string;\n  animation?: string;\n  animationOriginal?: string;\n  externalLink?: string;\n  creator?: string;\n  transactionId?: string;\n  tokenURI?: string | null;\n  collection?: Collection;\n  address?: string;\n  attributes?: Attributes;\n  lastSale?: LastSale;\n  rarityRank?: string;\n}\n\n/**\n * @type NftConfig\n *\n * NFT controller configuration\n * @property selectedAddress - Vault selected address\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftConfig extends BaseConfig {\n  selectedAddress: string;\n  chainId: Hex;\n  ipfsGateway: string;\n  openSeaEnabled: boolean;\n  useIPFSSubdomains: boolean;\n  isIpfsGatewayEnabled: boolean;\n}\n\n/**\n * @type NftState\n *\n * NFT controller state\n * @property allNftContracts - Object containing NFT contract information\n * @property allNfts - Object containing NFTs per account and network\n * @property ignoredNfts - List of NFTs that should be ignored\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftState extends BaseState {\n  allNftContracts: {\n    [key: string]: { [chainId: Hex]: NftContract[] };\n  };\n  allNfts: { [key: string]: { [chainId: Hex]: Nft[] } };\n  ignoredNfts: Nft[];\n}\n\nconst ALL_NFTS_STATE_KEY = 'allNfts';\nconst ALL_NFTS_CONTRACTS_STATE_KEY = 'allNftContracts';\n\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\ninterface NftAsset {\n  address: string;\n  tokenId: string;\n}\n\n/**\n * The name of the {@link NftController}.\n */\nconst controllerName = 'NftController';\n\n/**\n * The external actions available to the {@link NftController}.\n */\ntype AllowedActions = AddApprovalRequest;\n\n/**\n * The messenger of the {@link NftController}.\n */\nexport type NftControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  AllowedActions,\n  never,\n  AllowedActions['type'],\n  never\n>;\n\nexport const getDefaultNftState = (): NftState => {\n  return {\n    allNftContracts: {},\n    allNfts: {},\n    ignoredNfts: [],\n  };\n};\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class NftController extends BaseControllerV1<NftConfig, NftState> {\n  private readonly mutex = new Mutex();\n\n  private readonly messagingSystem: NftControllerMessenger;\n\n  getNftApi() {\n    return `${NFT_API_BASE_URL}/tokens`;\n  }\n\n  /**\n   * Helper method to update nested state for allNfts and allNftContracts.\n   *\n   * @param newCollection - the modified piece of state to update in the controller's store\n   * @param baseStateKey - The root key in the store to update.\n   * @param passedConfig - An object containing the selectedAddress and chainId that are passed through the auto-detection flow.\n   * @param passedConfig.userAddress - the address passed through the NFT detection flow to ensure assets are stored to the correct account\n   * @param passedConfig.chainId - the chainId passed through the NFT detection flow to ensure assets are stored to the correct account\n   */\n  private updateNestedNftState(\n    newCollection: Nft[] | NftContract[],\n    baseStateKey: 'allNfts' | 'allNftContracts',\n    { userAddress, chainId }: { userAddress: string; chainId: Hex },\n  ) {\n    const { [baseStateKey]: oldState } = this.state;\n\n    const addressState = oldState[userAddress];\n    const newAddressState = {\n      ...addressState,\n      ...{ [chainId]: newCollection },\n    };\n    const newState = {\n      ...oldState,\n      ...{ [userAddress]: newAddressState },\n    };\n    this.update({\n      [baseStateKey]: newState,\n    });\n  }\n\n  /**\n   * Request individual NFT information from NFT API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromApi(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<NftMetadata> {\n    // TODO Parameterize this by chainId for non-mainnet token detection\n    // Attempt to fetch the data with the nft-api\n    const urlParams = new URLSearchParams({\n      chainIds: '1',\n      tokens: `${contractAddress}:${tokenId}`,\n      includeTopBid: 'true',\n      includeAttributes: 'true',\n      includeLastSale: 'true',\n    }).toString();\n    const nftInformation: ReservoirResponse | undefined =\n      await fetchWithErrorHandling({\n        url: `${this.getNftApi()}?${urlParams}`,\n        options: {\n          headers: {\n            Version: '1',\n          },\n        },\n      });\n    // if we were still unable to fetch the data we return out the default/null of `NftMetadata`\n    if (!nftInformation?.tokens?.[0]?.token) {\n      return {\n        name: null,\n        description: null,\n        image: null,\n        standard: null,\n      };\n    }\n\n    // if we've reached this point, we have successfully fetched some data for nftInformation\n    // now we reconfigure the data to conform to the `NftMetadata` type for storage.\n\n    const {\n      image,\n      metadata: { imageOriginal } = {},\n      name,\n      description,\n      collection,\n      kind,\n      rarityRank,\n      rarity,\n      attributes,\n      lastSale,\n      imageSmall,\n    } = nftInformation.tokens[0].token;\n\n    /* istanbul ignore next */\n    const nftMetadata: NftMetadata = Object.assign(\n      {},\n      { name: name || null },\n      { description: description || null },\n      { image: image || null },\n      collection?.creator && { creator: collection.creator },\n      imageOriginal && { imageOriginal },\n      imageSmall && { imageThumbnail: imageSmall },\n      kind && { standard: kind.toUpperCase() },\n      lastSale && { lastSale },\n      attributes && { attributes },\n      nftInformation.tokens[0].market?.topBid && {\n        topBid: nftInformation.tokens[0].market?.topBid,\n      },\n      rarityRank && { rarityRank },\n      rarity && { rarity },\n      collection && { collection },\n    );\n\n    return nftMetadata;\n  }\n\n  /**\n   * Request individual NFT information from contracts that follows Metadata Interface.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromTokenURI(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<NftMetadata> {\n    const { ipfsGateway, useIPFSSubdomains, isIpfsGatewayEnabled } =\n      this.config;\n    const result = await this.getNftURIAndStandard(\n      contractAddress,\n      tokenId,\n      networkClientId,\n    );\n    let tokenURI = result[0];\n    const standard = result[1];\n\n    const hasIpfsTokenURI = tokenURI.startsWith('ipfs://');\n\n    if (hasIpfsTokenURI && !isIpfsGatewayEnabled) {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n\n    const isDisplayNFTMediaToggleEnabled = this.config.openSeaEnabled;\n    if (!hasIpfsTokenURI && !isDisplayNFTMediaToggleEnabled) {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n\n    if (hasIpfsTokenURI) {\n      tokenURI = getFormattedIpfsUrl(ipfsGateway, tokenURI, useIPFSSubdomains);\n    }\n\n    try {\n      const object = await handleFetch(tokenURI);\n      // TODO: Check image_url existence. This is not part of EIP721 nor EIP1155\n      const image = Object.prototype.hasOwnProperty.call(object, 'image')\n        ? 'image'\n        : /* istanbul ignore next */ 'image_url';\n\n      return {\n        image: object[image],\n        name: object.name,\n        description: object.description,\n        standard,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    } catch {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n  }\n\n  /**\n   * Retrieve NFT uri with  metadata. TODO Update method to use IPFS.\n   *\n   * @param contractAddress - NFT contract address.\n   * @param tokenId - NFT token id.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving NFT uri and token standard.\n   */\n  private async getNftURIAndStandard(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<[string, string]> {\n    // try ERC721 uri\n    try {\n      const uri = await this.getERC721TokenURI(\n        contractAddress,\n        tokenId,\n        networkClientId,\n      );\n      return [uri, ERC721];\n    } catch {\n      // Ignore error\n    }\n\n    // try ERC1155 uri\n    try {\n      const tokenURI = await this.getERC1155TokenURI(\n        contractAddress,\n        tokenId,\n        networkClientId,\n      );\n\n      /**\n       * According to EIP1155 the URI value allows for ID substitution\n       * in case the string `{id}` exists.\n       * https://eips.ethereum.org/EIPS/eip-1155#metadata\n       */\n\n      if (!tokenURI.includes('{id}')) {\n        return [tokenURI, ERC1155];\n      }\n\n      const hexTokenId = remove0x(BNToHex(new BN(tokenId)))\n        .padStart(64, '0')\n        .toLowerCase();\n      return [tokenURI.replace('{id}', hexTokenId), ERC1155];\n    } catch {\n      // Ignore error\n    }\n\n    return ['', ''];\n  }\n\n  /**\n   * Request individual NFT information (name, image url and description).\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformation(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<NftMetadata> {\n    const chainId = this.getCorrectChainId({\n      networkClientId,\n    });\n    const [blockchainMetadata, nftApiMetadata] = await Promise.all([\n      safelyExecute(() =>\n        this.getNftInformationFromTokenURI(\n          contractAddress,\n          tokenId,\n          networkClientId,\n        ),\n      ),\n      this.config.openSeaEnabled && chainId === '0x1'\n        ? safelyExecute(() =>\n            this.getNftInformationFromApi(contractAddress, tokenId),\n          )\n        : undefined,\n    ]);\n    return {\n      ...nftApiMetadata,\n      name: blockchainMetadata?.name ?? nftApiMetadata?.name ?? null,\n      description:\n        blockchainMetadata?.description ?? nftApiMetadata?.description ?? null,\n      image: blockchainMetadata?.image ?? nftApiMetadata?.image ?? null,\n      standard:\n        blockchainMetadata?.standard ?? nftApiMetadata?.standard ?? null,\n      tokenURI: blockchainMetadata?.tokenURI ?? null,\n    };\n  }\n\n  /**\n   * Request NFT contract information from the contract itself.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftContractInformationFromContract(\n    contractAddress: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const [name, symbol] = await Promise.all([\n      this.getERC721AssetName(contractAddress, networkClientId),\n      this.getERC721AssetSymbol(contractAddress, networkClientId),\n    ]);\n\n    return {\n      collection: { name },\n      symbol,\n      address: contractAddress,\n    };\n  }\n\n  /**\n   * Request NFT contract information from Blockchain and aggregate with received data from NFTMetadata.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param nftMetadataFromApi - Received NFT information to be aggregated with blockchain contract information.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the NFT contract name, image and description.\n   */\n  private async getNftContractInformation(\n    contractAddress: string,\n    nftMetadataFromApi: NftMetadata,\n    networkClientId?: NetworkClientId,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const blockchainContractData = await safelyExecute(() =>\n      this.getNftContractInformationFromContract(\n        contractAddress,\n        networkClientId,\n      ),\n    );\n\n    if (\n      blockchainContractData ||\n      !Object.values(nftMetadataFromApi).every((value) => value === null)\n    ) {\n      return {\n        address: contractAddress,\n        ...blockchainContractData,\n        schema_name: nftMetadataFromApi?.standard ?? null,\n        collection: {\n          name: null,\n          image_url:\n            nftMetadataFromApi?.collection?.image ??\n            nftMetadataFromApi?.collection?.imageUrl ??\n            null,\n          tokenCount: nftMetadataFromApi?.collection?.tokenCount ?? null,\n          ...nftMetadataFromApi?.collection,\n          ...blockchainContractData?.collection,\n        },\n      };\n    }\n\n    /* istanbul ignore next */\n    return {\n      address: contractAddress,\n      asset_contract_type: null,\n      created_date: null,\n      schema_name: null,\n      symbol: null,\n      total_supply: null,\n      description: null,\n      external_link: null,\n      collection: { name: null, image_url: null },\n    };\n  }\n\n  /**\n   * Adds an individual NFT to the stored NFT list.\n   *\n   * @param tokenAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param nftMetadata - NFT optional information (name, image and description).\n   * @param nftContract - An object containing contract data of the NFT being added.\n   * @param chainId - The chainId of the network where the NFT is being added.\n   * @param userAddress - The address of the account where the NFT is being added.\n   * @param source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @returns Promise resolving to the current NFT list.\n   */\n  private async addIndividualNft(\n    tokenAddress: string,\n    tokenId: string,\n    nftMetadata: NftMetadata,\n    nftContract: NftContract,\n    chainId: Hex,\n    userAddress: string,\n    source: Source,\n  ): Promise<Nft[]> {\n    // TODO: Remove unused return\n    const releaseLock = await this.mutex.acquire();\n    try {\n      tokenAddress = toChecksumHexAddress(tokenAddress);\n      const { allNfts } = this.state;\n\n      const nfts = allNfts[userAddress]?.[chainId] || [];\n\n      const existingEntry: Nft | undefined = nfts.find(\n        (nft) =>\n          nft.address.toLowerCase() === tokenAddress.toLowerCase() &&\n          nft.tokenId === tokenId,\n      );\n\n      if (existingEntry) {\n        const differentMetadata = compareNftMetadata(\n          nftMetadata,\n          existingEntry,\n        );\n        if (differentMetadata || !existingEntry.isCurrentlyOwned) {\n          // TODO: Switch to indexToUpdate\n          const indexToRemove = nfts.findIndex(\n            (nft) =>\n              nft.address.toLowerCase() === tokenAddress.toLowerCase() &&\n              nft.tokenId === tokenId,\n          );\n          /* istanbul ignore next */\n          if (indexToRemove !== -1) {\n            nfts.splice(indexToRemove, 1);\n          }\n        } else {\n          return nfts;\n        }\n      }\n\n      const newEntry: Nft = {\n        address: tokenAddress,\n        tokenId,\n        favorite: existingEntry?.favorite || false,\n        isCurrentlyOwned: true,\n        ...nftMetadata,\n      };\n\n      const newNfts = [...nfts, newEntry];\n      this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n        chainId,\n        userAddress,\n      });\n\n      if (this.onNftAdded) {\n        this.onNftAdded({\n          address: tokenAddress,\n          symbol: nftContract.symbol,\n          tokenId: tokenId.toString(),\n          standard: nftMetadata.standard,\n          source,\n        });\n      }\n      return newNfts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds an NFT contract to the stored NFT contracts list.\n   *\n   * @param options - options.\n   * @param options.tokenAddress - Hex address of the NFT contract.\n   * @param options.userAddress - The address of the account where the NFT is being added.\n   * @param options.nftMetadata - The retrieved NFTMetadata from API.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private async addNftContract({\n    tokenAddress,\n    userAddress,\n    networkClientId,\n    source,\n    nftMetadata,\n  }: {\n    tokenAddress: string;\n    userAddress: string;\n    nftMetadata: NftMetadata;\n    networkClientId?: NetworkClientId;\n    source?: Source;\n  }): Promise<NftContract[]> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      tokenAddress = toChecksumHexAddress(tokenAddress);\n      const { allNftContracts } = this.state;\n      const chainId = this.getCorrectChainId({\n        networkClientId,\n      });\n\n      const nftContracts = allNftContracts[userAddress]?.[chainId] || [];\n\n      const existingEntry = nftContracts.find(\n        (nftContract) =>\n          nftContract.address.toLowerCase() === tokenAddress.toLowerCase(),\n      );\n      if (existingEntry) {\n        return nftContracts;\n      }\n\n      // this doesn't work currently for detection if the user switches networks while the detection is processing\n      // will be fixed once detection uses networkClientIds\n      // get name and symbol if ERC721 then put together the metadata\n      const contractInformation = await this.getNftContractInformation(\n        tokenAddress,\n        nftMetadata,\n        networkClientId,\n      );\n      const {\n        asset_contract_type,\n        created_date,\n        symbol,\n        description,\n        external_link,\n        schema_name,\n        collection: { name, image_url, tokenCount },\n      } = contractInformation;\n\n      // If the nft is auto-detected we want some valid metadata to be present\n      if (\n        source === Source.Detected &&\n        'address' in contractInformation &&\n        typeof contractInformation.address === 'string' &&\n        'collection' in contractInformation &&\n        contractInformation.collection.name === null &&\n        'image_url' in contractInformation.collection &&\n        contractInformation.collection.image_url === null &&\n        Object.entries(contractInformation).every(([key, value]) => {\n          return key === 'address' || key === 'collection' || !value;\n        })\n      ) {\n        return nftContracts;\n      }\n\n      /* istanbul ignore next */\n      const newEntry: NftContract = Object.assign(\n        {},\n        { address: tokenAddress },\n        description && { description },\n        name && { name },\n        image_url && { logo: image_url },\n        symbol && { symbol },\n        tokenCount !== null &&\n          typeof tokenCount !== 'undefined' && { totalSupply: tokenCount },\n        asset_contract_type && { assetContractType: asset_contract_type },\n        created_date && { createdDate: created_date },\n        schema_name && { schemaName: schema_name },\n        external_link && { externalLink: external_link },\n      );\n      const newNftContracts = [...nftContracts, newEntry];\n      this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {\n        chainId,\n        userAddress,\n      });\n\n      return newNftContracts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - options.\n   * @param options.chainId - The chainId of the network where the NFT is being removed.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  private removeAndIgnoreIndividualNft(\n    address: string,\n    tokenId: string,\n    {\n      chainId,\n      userAddress,\n    }: {\n      chainId: Hex;\n      userAddress: string;\n    },\n  ) {\n    address = toChecksumHexAddress(address);\n    const { allNfts, ignoredNfts } = this.state;\n    const newIgnoredNfts = [...ignoredNfts];\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const newNfts = nfts.filter((nft) => {\n      if (\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId\n      ) {\n        const alreadyIgnored = newIgnoredNfts.find(\n          (c) => c.address === address && c.tokenId === tokenId,\n        );\n        !alreadyIgnored && newIgnoredNfts.push(nft);\n        return false;\n      }\n      return true;\n    });\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      userAddress,\n      chainId,\n    });\n\n    this.update({\n      ignoredNfts: newIgnoredNfts,\n    });\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - options.\n   * @param options.chainId - The chainId of the network where the NFT is being removed.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  private removeIndividualNft(\n    address: string,\n    tokenId: string,\n    { chainId, userAddress }: { chainId: Hex; userAddress: string },\n  ) {\n    address = toChecksumHexAddress(address);\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const newNfts = nfts.filter(\n      (nft) =>\n        !(\n          nft.address.toLowerCase() === address.toLowerCase() &&\n          nft.tokenId === tokenId\n        ),\n    );\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      userAddress,\n      chainId,\n    });\n  }\n\n  /**\n   * Removes an NFT contract to the stored NFT contracts list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param options - options.\n   * @param options.chainId - The chainId of the network where the NFT is being removed.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private removeNftContract(\n    address: string,\n    { chainId, userAddress }: { chainId: Hex; userAddress: string },\n  ): NftContract[] {\n    address = toChecksumHexAddress(address);\n    const { allNftContracts } = this.state;\n    const nftContracts = allNftContracts[userAddress]?.[chainId] || [];\n\n    const newNftContracts = nftContracts.filter(\n      (nftContract) =>\n        !(nftContract.address.toLowerCase() === address.toLowerCase()),\n    );\n    this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {\n      chainId,\n      userAddress,\n    });\n\n    return newNftContracts;\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Optional API key to use with opensea\n   */\n  openSeaApiKey?: string;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'NftController';\n\n  private readonly getERC721AssetName: AssetsContractController['getERC721AssetName'];\n\n  private readonly getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n\n  private readonly getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n\n  private readonly getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n\n  private readonly getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n\n  private readonly getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  private readonly onNftAdded?: (data: {\n    address: string;\n    symbol: string | undefined;\n    tokenId: string;\n    standard: string | null;\n    source: Source;\n  }) => void;\n\n  /**\n   * Creates an NftController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getERC721AssetName - Gets the name of the asset at the given address.\n   * @param options.getERC721AssetSymbol - Gets the symbol of the asset at the given address.\n   * @param options.getERC721TokenURI - Gets the URI of the ERC721 token at the given address, with the given ID.\n   * @param options.getERC721OwnerOf - Get the owner of a ERC-721 NFT.\n   * @param options.getERC1155BalanceOf - Gets balance of a ERC-1155 NFT.\n   * @param options.getERC1155TokenURI - Gets the URI of the ERC1155 token at the given address, with the given ID.\n   * @param options.getNetworkClientById - Gets the network client for the given networkClientId.\n   * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data\n   * for tracking the NFT added event.\n   * @param options.messenger - The controller messenger.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      chainId: initialChainId,\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getERC721AssetName,\n      getERC721AssetSymbol,\n      getERC721TokenURI,\n      getERC721OwnerOf,\n      getERC1155BalanceOf,\n      getERC1155TokenURI,\n      getNetworkClientById,\n      onNftAdded,\n      messenger,\n    }: {\n      chainId: Hex;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getERC721AssetName: AssetsContractController['getERC721AssetName'];\n      getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n      getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n      getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n      getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n      getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n      onNftAdded?: (data: {\n        address: string;\n        symbol: string | undefined;\n        tokenId: string;\n        standard: string | null;\n        source: string;\n      }) => void;\n      messenger: NftControllerMessenger;\n    },\n    config?: Partial<BaseConfig>,\n    state?: Partial<NftState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      selectedAddress: '',\n      chainId: initialChainId,\n      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,\n      openSeaEnabled: false,\n      useIPFSSubdomains: true,\n      isIpfsGatewayEnabled: true,\n    };\n\n    this.defaultState = getDefaultNftState();\n    this.initialize();\n    this.getERC721AssetName = getERC721AssetName;\n    this.getERC721AssetSymbol = getERC721AssetSymbol;\n    this.getERC721TokenURI = getERC721TokenURI;\n    this.getERC721OwnerOf = getERC721OwnerOf;\n    this.getERC1155BalanceOf = getERC1155BalanceOf;\n    this.getERC1155TokenURI = getERC1155TokenURI;\n    this.getNetworkClientById = getNetworkClientById;\n    this.onNftAdded = onNftAdded;\n    this.messagingSystem = messenger;\n\n    onPreferencesStateChange(\n      async ({\n        selectedAddress,\n        ipfsGateway,\n        openSeaEnabled,\n        isIpfsGatewayEnabled,\n      }) => {\n        this.configure({\n          selectedAddress,\n          ipfsGateway,\n          openSeaEnabled,\n          isIpfsGatewayEnabled,\n        });\n\n        const needsUpdateNftMetadata =\n          (isIpfsGatewayEnabled && ipfsGateway !== '') || openSeaEnabled;\n\n        if (needsUpdateNftMetadata) {\n          const { chainId } = this.config;\n          const nfts: Nft[] =\n            this.state.allNfts[selectedAddress]?.[chainId] ?? [];\n          // filter only nfts\n          const nftsToUpdate = nfts.filter(\n            (singleNft) =>\n              !singleNft.name && !singleNft.description && !singleNft.image,\n          );\n          if (nftsToUpdate.length !== 0) {\n            await this.updateNftMetadata({\n              nfts: nftsToUpdate,\n              userAddress: selectedAddress,\n            });\n          }\n        }\n      },\n    );\n\n    onNetworkStateChange(({ providerConfig }) => {\n      const { chainId } = providerConfig;\n      this.configure({ chainId });\n    });\n  }\n\n  private async validateWatchNft(\n    asset: NftAsset,\n    type: NFTStandardType,\n    userAddress: string,\n    { networkClientId }: { networkClientId?: NetworkClientId } = {},\n  ) {\n    const { address: contractAddress, tokenId } = asset;\n\n    // Validate parameters\n    if (!type) {\n      throw rpcErrors.invalidParams('Asset type is required');\n    }\n\n    if (type !== ERC721 && type !== ERC1155) {\n      throw rpcErrors.invalidParams(\n        `Non NFT asset type ${type} not supported by watchNft`,\n      );\n    }\n\n    if (!contractAddress || !tokenId) {\n      throw rpcErrors.invalidParams('Both address and tokenId are required');\n    }\n\n    if (!isAddress(contractAddress)) {\n      throw rpcErrors.invalidParams('Invalid address');\n    }\n\n    if (!/^\\d+$/u.test(tokenId)) {\n      throw rpcErrors.invalidParams('Invalid tokenId');\n    }\n\n    // Check if the user owns the suggested NFT\n    try {\n      const isOwner = await this.isNftOwner(\n        userAddress,\n        contractAddress,\n        tokenId,\n        { networkClientId },\n      );\n      if (!isOwner) {\n        throw rpcErrors.invalidInput(\n          'Suggested NFT is not owned by the selected account',\n        );\n      }\n    } catch (error) {\n      // error thrown here: \"Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.\"\n      if (error instanceof Error) {\n        throw rpcErrors.resourceUnavailable(error.message);\n      }\n      throw error;\n    }\n  }\n\n  // temporary method to get the correct chainId until we remove chainId from the config & the chainId arg from the detection logic\n  // Just a helper method to prefer the networkClient chainId first then the chainId argument and then finally the config chainId\n  private getCorrectChainId({\n    networkClientId,\n  }: {\n    networkClientId?: NetworkClientId;\n  }) {\n    if (networkClientId) {\n      return this.getNetworkClientById(networkClientId).configuration.chainId;\n    }\n    return this.config.chainId;\n  }\n\n  /**\n   * Adds a new suggestedAsset to state. Parameters will be validated according to\n   * asset type being watched. A `<suggestedNftMeta.id>:pending` hub event will be emitted once added.\n   *\n   * @param asset - The asset to be watched. For now ERC721 and ERC1155 tokens are accepted.\n   * @param asset.address - The address of the asset contract.\n   * @param asset.tokenId - The ID of the asset.\n   * @param type - The asset type.\n   * @param origin - Domain origin to register the asset from.\n   * @param options - Options bag.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being added.\n   * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.\n   */\n  async watchNft(\n    asset: NftAsset,\n    type: NFTStandardType,\n    origin: string,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: {\n      networkClientId?: NetworkClientId;\n      userAddress?: string;\n    } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    await this.validateWatchNft(asset, type, userAddress);\n\n    const nftMetadata = await this.getNftInformation(\n      asset.address,\n      asset.tokenId,\n      networkClientId,\n    );\n\n    if (nftMetadata.standard && nftMetadata.standard !== type) {\n      throw rpcErrors.invalidInput(\n        `Suggested NFT of type ${nftMetadata.standard} does not match received type ${type}`,\n      );\n    }\n\n    const suggestedNftMeta: SuggestedNftMeta = {\n      asset: { ...asset, ...nftMetadata },\n      type,\n      id: random(),\n      time: Date.now(),\n      interactingAddress: userAddress,\n      origin,\n    };\n    await this._requestApproval(suggestedNftMeta);\n    const { address, tokenId } = asset;\n    const { name, standard, description, image } = nftMetadata;\n\n    await this.addNft(address, tokenId, {\n      nftMetadata: {\n        name: name ?? null,\n        description: description ?? null,\n        image: image ?? null,\n        standard: standard ?? null,\n      },\n      userAddress,\n      source: Source.Dapp,\n      networkClientId,\n    });\n  }\n\n  /**\n   * Sets an OpenSea API key to retrieve NFT information.\n   *\n   * @param openSeaApiKey - OpenSea API key.\n   */\n  setApiKey(openSeaApiKey: string) {\n    this.openSeaApiKey = openSeaApiKey;\n  }\n\n  /**\n   * Checks the ownership of a ERC-721 or ERC-1155 NFT for a given address.\n   *\n   * @param ownerAddress - User public address.\n   * @param nftAddress - NFT contract address.\n   * @param tokenId - NFT token ID.\n   * @param options - Options bag.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving the NFT ownership.\n   */\n  async isNftOwner(\n    ownerAddress: string,\n    nftAddress: string,\n    tokenId: string,\n    {\n      networkClientId,\n    }: {\n      networkClientId?: NetworkClientId;\n    } = {},\n  ): Promise<boolean> {\n    // Checks the ownership for ERC-721.\n    try {\n      const owner = await this.getERC721OwnerOf(\n        nftAddress,\n        tokenId,\n        networkClientId,\n      );\n      return ownerAddress.toLowerCase() === owner.toLowerCase();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-721 contract error\n    }\n\n    // Checks the ownership for ERC-1155.\n    try {\n      const balance = await this.getERC1155BalanceOf(\n        ownerAddress,\n        nftAddress,\n        tokenId,\n        networkClientId,\n      );\n      return !balance.isZero();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-1155 contract error\n    }\n\n    throw new Error(\n      `Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.`,\n    );\n  }\n\n  /**\n   * Verifies currently selected address owns entered NFT address/tokenId combo and\n   * adds the NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param options - an object of arguments\n   * @param options.userAddress - The address of the current user.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   */\n  async addNftVerifyOwnership(\n    address: string,\n    tokenId: string,\n    {\n      userAddress = this.config.selectedAddress,\n      networkClientId,\n      source,\n    }: {\n      userAddress?: string;\n      networkClientId?: NetworkClientId;\n      source?: Source;\n    } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    if (\n      !(await this.isNftOwner(userAddress, address, tokenId, {\n        networkClientId,\n      }))\n    ) {\n      throw new Error('This NFT is not owned by the user');\n    }\n    await this.addNft(address, tokenId, {\n      networkClientId,\n      userAddress,\n      source,\n    });\n  }\n\n  /**\n   * Adds an NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param tokenAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param options - an object of arguments\n   * @param options.nftMetadata - NFT optional metadata.\n   * @param options.userAddress - The address of the current user.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT list.\n   */\n  async addNft(\n    tokenAddress: string,\n    tokenId: string,\n    {\n      nftMetadata,\n      userAddress = this.config.selectedAddress,\n      source = Source.Custom,\n      networkClientId,\n    }: {\n      nftMetadata?: NftMetadata;\n      userAddress?: string;\n      source?: Source;\n      networkClientId?: NetworkClientId;\n    } = { userAddress: this.config.selectedAddress },\n  ) {\n    tokenAddress = toChecksumHexAddress(tokenAddress);\n\n    const chainId = this.getCorrectChainId({ networkClientId });\n\n    nftMetadata =\n      nftMetadata ||\n      (await this.getNftInformation(tokenAddress, tokenId, networkClientId));\n\n    const newNftContracts = await this.addNftContract({\n      tokenAddress,\n      userAddress,\n      networkClientId,\n      source,\n      nftMetadata,\n    });\n\n    // If NFT contract was not added, do not add individual NFT\n    const nftContract = newNftContracts.find(\n      (contract) =>\n        contract.address.toLowerCase() === tokenAddress.toLowerCase(),\n    );\n\n    // If NFT contract information, add individual NFT\n    if (nftContract) {\n      await this.addIndividualNft(\n        tokenAddress,\n        tokenId,\n        nftMetadata,\n        nftContract,\n        chainId,\n        userAddress,\n        source,\n      );\n    }\n  }\n\n  /**\n   * Refetches NFT metadata and updates the state\n   *\n   * @param options - Options for refetching NFT metadata\n   * @param options.nfts - nfts to update metadata for.\n   * @param options.userAddress - The current user address\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   */\n  async updateNftMetadata({\n    nfts,\n    userAddress = this.config.selectedAddress,\n    networkClientId,\n  }: {\n    nfts: Nft[];\n    userAddress?: string;\n    networkClientId?: NetworkClientId;\n  }) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n\n    const nftsWithChecksumAdr = nfts.map((nft) => {\n      return {\n        ...nft,\n        address: toChecksumHexAddress(nft.address),\n      };\n    });\n    const nftMetadataResults = await Promise.allSettled(\n      nftsWithChecksumAdr.map(async (nft) => {\n        const resMetadata = await this.getNftInformation(\n          nft.address,\n          nft.tokenId,\n          networkClientId,\n        );\n        return {\n          nft,\n          newMetadata: resMetadata,\n        };\n      }),\n    );\n\n    nftMetadataResults\n      .filter(\n        (result): result is PromiseFulfilledResult<NftUpdate> =>\n          result.status === 'fulfilled',\n      )\n      .forEach((elm) =>\n        this.updateNft(\n          elm.value.nft,\n          elm.value.newMetadata,\n          userAddress,\n          chainId,\n        ),\n      );\n  }\n\n  /**\n   * Removes an NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  removeNft(\n    address: string,\n    tokenId: string,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    address = toChecksumHexAddress(address);\n    this.removeIndividualNft(address, tokenId, { chainId, userAddress });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n\n    if (!remainingNft) {\n      this.removeNftContract(address, { chainId, userAddress });\n    }\n  }\n\n  /**\n   * Removes an NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  removeAndIgnoreNft(\n    address: string,\n    tokenId: string,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    address = toChecksumHexAddress(address);\n    this.removeAndIgnoreIndividualNft(address, tokenId, {\n      chainId,\n      userAddress,\n    });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (!remainingNft) {\n      this.removeNftContract(address, { chainId, userAddress });\n    }\n  }\n\n  /**\n   * Removes all NFTs from the ignored list.\n   */\n  clearIgnoredNfts() {\n    this.update({ ignoredNfts: [] });\n  }\n\n  /**\n   * Checks whether input NFT is still owned by the user\n   * And updates the isCurrentlyOwned value on the NFT object accordingly.\n   *\n   * @param nft - The NFT object to check and update.\n   * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.\n   * @param accountParams - The userAddress and chainId to check ownership against\n   * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure assets are stored to the correct account\n   * @param accountParams.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns the NFT with the updated isCurrentlyOwned value\n   */\n  async checkAndUpdateSingleNftOwnershipStatus(\n    nft: Nft,\n    batch: boolean,\n    {\n      userAddress = this.config.selectedAddress,\n      networkClientId,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const { address, tokenId } = nft;\n    let isOwned = nft.isCurrentlyOwned;\n    try {\n      isOwned = await this.isNftOwner(userAddress, address, tokenId, {\n        networkClientId,\n      });\n    } catch {\n      // ignore error\n      // this will only throw an error 'Unable to verify ownership' in which case\n      // we want to keep the current value of isCurrentlyOwned for this flow.\n    }\n\n    nft.isCurrentlyOwned = isOwned;\n\n    if (batch) {\n      return nft;\n    }\n\n    // if this is not part of a batched update we update this one NFT in state\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const nftToUpdate = nfts.find(\n      (item) =>\n        item.tokenId === tokenId &&\n        item.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (nftToUpdate) {\n      nftToUpdate.isCurrentlyOwned = isOwned;\n      this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {\n        userAddress,\n        chainId,\n      });\n    }\n    return nft;\n  }\n\n  /**\n   * Checks whether NFTs associated with current selectedAddress/chainId combination are still owned by the user\n   * And updates the isCurrentlyOwned value on each accordingly.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT ownership status is checked/updated.\n   */\n  async checkAndUpdateAllNftsOwnershipStatus(\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const updatedNfts = await Promise.all(\n      nfts.map(async (nft) => {\n        return (\n          (await this.checkAndUpdateSingleNftOwnershipStatus(nft, true, {\n            networkClientId,\n            userAddress,\n          })) ?? nft\n        );\n      }),\n    );\n\n    this.updateNestedNftState(updatedNfts, ALL_NFTS_STATE_KEY, {\n      userAddress,\n      chainId,\n    });\n  }\n\n  /**\n   * Update NFT favorite status.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Hex address of the NFT contract.\n   * @param favorite - NFT new favorite status.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  updateNftFavoriteStatus(\n    address: string,\n    tokenId: string,\n    favorite: boolean,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: {\n      networkClientId?: NetworkClientId;\n      userAddress?: string;\n    } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.address === address && nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nfts[index],\n      favorite,\n    };\n\n    // Update Nfts array\n    nfts[index] = updatedNft;\n\n    this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {\n      chainId,\n      userAddress,\n    });\n  }\n\n  /**\n   * Returns an NFT by the address and token id.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Number that represents the id of the token.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns Object containing the NFT and its position in the array\n   */\n  findNftByAddressAndTokenId(\n    address: string,\n    tokenId: string,\n    selectedAddress: string,\n    chainId: Hex,\n  ): { nft: Nft; index: number } | null {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) =>\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return null;\n    }\n\n    return { nft: nfts[index], index };\n  }\n\n  /**\n   * Update NFT data.\n   *\n   * @param nft - NFT object to find the right NFT to updates.\n   * @param updates - NFT partial object to update properties of the NFT.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   */\n  updateNft(\n    nft: Nft,\n    updates: Partial<Nft>,\n    selectedAddress: string,\n    chainId: Hex,\n  ) {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const nftInfo = this.findNftByAddressAndTokenId(\n      nft.address,\n      nft.tokenId,\n      selectedAddress,\n      chainId,\n    );\n\n    if (!nftInfo) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nft,\n      ...updates,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, nftInfo.index),\n      updatedNft,\n      ...nfts.slice(nftInfo.index + 1),\n    ];\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      chainId,\n      userAddress: selectedAddress,\n    });\n  }\n\n  /**\n   * Resets the transaction status of an NFT.\n   *\n   * @param transactionId - NFT transaction id.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns a boolean indicating if the reset was well succeeded or not\n   */\n  resetNftTransactionStatusByTransactionId(\n    transactionId: string,\n    selectedAddress: string,\n    chainId: Hex,\n  ): boolean {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.transactionId === transactionId,\n    );\n\n    if (index === -1) {\n      return false;\n    }\n    const updatedNft: Nft = {\n      ...nfts[index],\n      transactionId: undefined,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, index),\n      updatedNft,\n      ...nfts.slice(index + 1),\n    ];\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      chainId,\n      userAddress: selectedAddress,\n    });\n\n    return true;\n  }\n\n  async _requestApproval(suggestedNftMeta: SuggestedNftMeta) {\n    return this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        id: suggestedNftMeta.id,\n        origin: suggestedNftMeta.origin,\n        type: ApprovalType.WatchAsset,\n        requestData: {\n          id: suggestedNftMeta.id,\n          interactingAddress: suggestedNftMeta.interactingAddress,\n          asset: {\n            address: suggestedNftMeta.asset.address,\n            tokenId: suggestedNftMeta.asset.tokenId,\n            name: suggestedNftMeta.asset.name,\n            description: suggestedNftMeta.asset.description,\n            image: suggestedNftMeta.asset.image,\n            standard: suggestedNftMeta.asset.standard,\n          },\n        },\n      },\n      true,\n    );\n  }\n}\n\nexport default NftController;\n"]}
\ No newline at end of file
diff --git a/dist/chunk-MDHJNCTR.mjs b/dist/chunk-MDHJNCTR.mjs
new file mode 100644
index 0000000000000000000000000000000000000000..8ba661011a92284cbc0c4fb3d6679cf98d627c01
--- /dev/null
+++ b/dist/chunk-MDHJNCTR.mjs
@@ -0,0 +1,704 @@
+import {
+  ERC1155Standard
+} from "./chunk-S7UA2DU7.mjs";
+import {
+  ERC20Standard
+} from "./chunk-LLYYJY7H.mjs";
+import {
+  TOKEN_METADATA_NO_SUPPORT_ERROR,
+  fetchTokenMetadata
+} from "./chunk-S6KASB6I.mjs";
+import {
+  formatAggregatorNames,
+  formatIconUrlWithProxy
+} from "./chunk-X5PLVMOQ.mjs";
+
+// src/TokensController.ts
+import { Contract } from "@ethersproject/contracts";
+import { Web3Provider } from "@ethersproject/providers";
+import { BaseControllerV1 } from "@metamask/base-controller";
+import contractsMap from "@metamask/contract-metadata";
+import {
+  toChecksumHexAddress,
+  ERC721_INTERFACE_ID,
+  ORIGIN_METAMASK,
+  ApprovalType,
+  ERC20,
+  ERC721,
+  ERC1155,
+  isValidHexAddress,
+  safelyExecute
+} from "@metamask/controller-utils";
+import { abiERC721 } from "@metamask/metamask-eth-abis";
+import { rpcErrors } from "@metamask/rpc-errors";
+import { Mutex } from "async-mutex";
+import { EventEmitter } from "events";
+import { v1 as random } from "uuid";
+var controllerName = "TokensController";
+var getDefaultTokensState = () => {
+  return {
+    tokens: [],
+    ignoredTokens: [],
+    detectedTokens: [],
+    allTokens: {},
+    allIgnoredTokens: {},
+    allDetectedTokens: {}
+  };
+};
+var TokensController = class extends BaseControllerV1 {
+  /**
+   * Creates a TokensController instance.
+   *
+   * @param options - The controller options.
+   * @param options.chainId - The chain ID of the current network.
+   * @param options.config - Initial options used to configure this controller.
+   * @param options.state - Initial state to set on this controller.
+   * @param options.messenger - The controller messenger.
+   */
+  constructor({
+    chainId: initialChainId,
+    config,
+    state,
+    messenger
+  }) {
+    super(config, state);
+    this.mutex = new Mutex();
+    /**
+     * EventEmitter instance used to listen to specific EIP747 events
+     */
+    this.hub = new EventEmitter();
+    /**
+     * Name of this controller used during composition
+     */
+    this.name = "TokensController";
+    this.defaultConfig = {
+      selectedAddress: "",
+      chainId: initialChainId,
+      provider: void 0,
+      ...config
+    };
+    this.defaultState = {
+      ...getDefaultTokensState(),
+      ...state
+    };
+    this.initialize();
+    this.abortController = new AbortController();
+    this.messagingSystem = messenger;
+    this.messagingSystem.registerActionHandler(
+      `${controllerName}:addDetectedTokens`,
+      this.addDetectedTokens.bind(this)
+    );
+    this.messagingSystem.subscribe(
+      "PreferencesController:stateChange",
+      ({ selectedAddress }) => {
+        const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
+        const { chainId } = this.config;
+        this.configure({ selectedAddress });
+        this.update({
+          tokens: allTokens[chainId]?.[selectedAddress] ?? [],
+          ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] ?? [],
+          detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] ?? []
+        });
+      }
+    );
+    this.messagingSystem.subscribe(
+      "NetworkController:networkDidChange",
+      ({ providerConfig }) => {
+        const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
+        const { selectedAddress } = this.config;
+        const { chainId } = providerConfig;
+        this.abortController.abort();
+        this.abortController = new AbortController();
+        this.configure({ chainId });
+        this.update({
+          tokens: allTokens[chainId]?.[selectedAddress] || [],
+          ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] || [],
+          detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] || []
+        });
+      }
+    );
+    this.messagingSystem.subscribe(
+      "TokenListController:stateChange",
+      ({ tokenList }) => {
+        const { tokens } = this.state;
+        if (tokens.length && !tokens[0].name) {
+          this.updateTokensAttribute(tokenList, "name");
+        }
+      }
+    );
+  }
+  /**
+   * Fetch metadata for a token.
+   *
+   * @param tokenAddress - The address of the token.
+   * @returns The token metadata.
+   */
+  async fetchTokenMetadata(tokenAddress) {
+    try {
+      const token = await fetchTokenMetadata(
+        this.config.chainId,
+        tokenAddress,
+        this.abortController.signal
+      );
+      return token;
+    } catch (error) {
+      if (error instanceof Error && error.message.includes(TOKEN_METADATA_NO_SUPPORT_ERROR)) {
+        return void 0;
+      }
+      throw error;
+    }
+  }
+  /**
+   * Adds a token to the stored token list.
+   *
+   * @param options - The method argument object.
+   * @param options.address - Hex address of the token contract.
+   * @param options.symbol - Symbol of the token.
+   * @param options.decimals - Number of decimals the token uses.
+   * @param options.name - Name of the token.
+   * @param options.image - Image of the token.
+   * @param options.interactingAddress - The address of the account to add a token to.
+   * @param options.networkClientId - Network Client ID.
+   * @returns Current token list.
+   */
+  async addToken({
+    address,
+    symbol,
+    decimals,
+    name,
+    image,
+    interactingAddress,
+    networkClientId
+  }) {
+    const { chainId, selectedAddress } = this.config;
+    const releaseLock = await this.mutex.acquire();
+    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
+    let currentChainId = chainId;
+    if (networkClientId) {
+      currentChainId = this.messagingSystem.call(
+        "NetworkController:getNetworkClientById",
+        networkClientId
+      ).configuration.chainId;
+    }
+    const accountAddress = interactingAddress || selectedAddress;
+    const isInteractingWithWalletAccount = accountAddress === selectedAddress;
+    try {
+      address = toChecksumHexAddress(address);
+      const tokens = allTokens[currentChainId]?.[accountAddress] || [];
+      const ignoredTokens = allIgnoredTokens[currentChainId]?.[accountAddress] || [];
+      const detectedTokens = allDetectedTokens[currentChainId]?.[accountAddress] || [];
+      const newTokens = [...tokens];
+      const [isERC721, tokenMetadata] = await Promise.all([
+        this._detectIsERC721(address, networkClientId),
+        // TODO parameterize the token metadata fetch by networkClientId
+        this.fetchTokenMetadata(address)
+      ]);
+      if (!networkClientId && currentChainId !== this.config.chainId) {
+        throw new Error(
+          "TokensController Error: Switched networks while adding token"
+        );
+      }
+      const newEntry = {
+        address,
+        symbol,
+        decimals,
+        image: image || formatIconUrlWithProxy({
+          chainId: currentChainId,
+          tokenAddress: address
+        }),
+        isERC721,
+        aggregators: formatAggregatorNames(tokenMetadata?.aggregators || []),
+        name
+      };
+      const previousIndex = newTokens.findIndex(
+        (token) => token.address.toLowerCase() === address.toLowerCase()
+      );
+      if (previousIndex !== -1) {
+        newTokens[previousIndex] = newEntry;
+      } else {
+        newTokens.push(newEntry);
+      }
+      const newIgnoredTokens = ignoredTokens.filter(
+        (tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase()
+      );
+      const newDetectedTokens = detectedTokens.filter(
+        (token) => token.address.toLowerCase() !== address.toLowerCase()
+      );
+      const { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens } = this._getNewAllTokensState({
+        newTokens,
+        newIgnoredTokens,
+        newDetectedTokens,
+        interactingAddress: accountAddress,
+        interactingChainId: currentChainId
+      });
+      let newState = {
+        allTokens: newAllTokens,
+        allIgnoredTokens: newAllIgnoredTokens,
+        allDetectedTokens: newAllDetectedTokens
+      };
+      if (isInteractingWithWalletAccount) {
+        newState = {
+          ...newState,
+          tokens: newTokens,
+          ignoredTokens: newIgnoredTokens,
+          detectedTokens: newDetectedTokens
+        };
+      }
+      this.update(newState);
+      return newTokens;
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Add a batch of tokens.
+   *
+   * @param tokensToImport - Array of tokens to import.
+   * @param networkClientId - Optional network client ID used to determine interacting chain ID.
+   */
+  async addTokens(tokensToImport, networkClientId) {
+    const releaseLock = await this.mutex.acquire();
+    const { tokens, detectedTokens, ignoredTokens } = this.state;
+    const importedTokensMap = {};
+    const newTokensMap = tokens.reduce((output, current) => {
+      output[current.address] = current;
+      return output;
+    }, {});
+    try {
+      tokensToImport.forEach((tokenToAdd) => {
+        const { address, symbol, decimals, image, aggregators, name } = tokenToAdd;
+        const checksumAddress = toChecksumHexAddress(address);
+        const formattedToken = {
+          address: checksumAddress,
+          symbol,
+          decimals,
+          image,
+          aggregators,
+          name
+        };
+        newTokensMap[address] = formattedToken;
+        importedTokensMap[address.toLowerCase()] = true;
+        return formattedToken;
+      });
+      const newTokens = Object.values(newTokensMap);
+      const newDetectedTokens = detectedTokens.filter(
+        (token) => !importedTokensMap[token.address.toLowerCase()]
+      );
+      const newIgnoredTokens = ignoredTokens.filter(
+        (tokenAddress) => !newTokensMap[tokenAddress.toLowerCase()]
+      );
+      let interactingChainId;
+      if (networkClientId) {
+        interactingChainId = this.messagingSystem.call(
+          "NetworkController:getNetworkClientById",
+          networkClientId
+        ).configuration.chainId;
+      }
+      const { newAllTokens, newAllDetectedTokens, newAllIgnoredTokens } = this._getNewAllTokensState({
+        newTokens,
+        newDetectedTokens,
+        newIgnoredTokens,
+        interactingChainId
+      });
+      this.update({
+        tokens: newTokens,
+        allTokens: newAllTokens,
+        detectedTokens: newDetectedTokens,
+        allDetectedTokens: newAllDetectedTokens,
+        ignoredTokens: newIgnoredTokens,
+        allIgnoredTokens: newAllIgnoredTokens
+      });
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Ignore a batch of tokens.
+   *
+   * @param tokenAddressesToIgnore - Array of token addresses to ignore.
+   */
+  ignoreTokens(tokenAddressesToIgnore) {
+    const { ignoredTokens, detectedTokens, tokens } = this.state;
+    const ignoredTokensMap = {};
+    let newIgnoredTokens = [...ignoredTokens];
+    const checksummedTokenAddresses = tokenAddressesToIgnore.map((address) => {
+      const checksumAddress = toChecksumHexAddress(address);
+      ignoredTokensMap[address.toLowerCase()] = true;
+      return checksumAddress;
+    });
+    newIgnoredTokens = [...ignoredTokens, ...checksummedTokenAddresses];
+    const newDetectedTokens = detectedTokens.filter(
+      (token) => !ignoredTokensMap[token.address.toLowerCase()]
+    );
+    const newTokens = tokens.filter(
+      (token) => !ignoredTokensMap[token.address.toLowerCase()]
+    );
+    const { newAllIgnoredTokens, newAllDetectedTokens, newAllTokens } = this._getNewAllTokensState({
+      newIgnoredTokens,
+      newDetectedTokens,
+      newTokens
+    });
+    this.update({
+      ignoredTokens: newIgnoredTokens,
+      tokens: newTokens,
+      detectedTokens: newDetectedTokens,
+      allIgnoredTokens: newAllIgnoredTokens,
+      allDetectedTokens: newAllDetectedTokens,
+      allTokens: newAllTokens
+    });
+  }
+  /**
+   * Adds a batch of detected tokens to the stored token list.
+   *
+   * @param incomingDetectedTokens - Array of detected tokens to be added or updated.
+   * @param detectionDetails - An object containing the chain ID and address of the currently selected network on which the incomingDetectedTokens were detected.
+   * @param detectionDetails.selectedAddress - the account address on which the incomingDetectedTokens were detected.
+   * @param detectionDetails.chainId - the chainId on which the incomingDetectedTokens were detected.
+   */
+  async addDetectedTokens(incomingDetectedTokens, detectionDetails) {
+    const releaseLock = await this.mutex.acquire();
+    const chainId = detectionDetails?.chainId ?? this.config.chainId;
+    const accountAddress = detectionDetails?.selectedAddress ?? this.config.selectedAddress;
+    const { allTokens, allDetectedTokens, allIgnoredTokens } = this.state;
+    let newTokens = [...allTokens?.[chainId]?.[accountAddress] ?? []];
+    let newDetectedTokens = [
+      ...allDetectedTokens?.[chainId]?.[accountAddress] ?? []
+    ];
+    try {
+      incomingDetectedTokens.forEach((tokenToAdd) => {
+        const {
+          address,
+          symbol,
+          decimals,
+          image,
+          aggregators,
+          isERC721,
+          name
+        } = tokenToAdd;
+        const checksumAddress = toChecksumHexAddress(address);
+        const newEntry = {
+          address: checksumAddress,
+          symbol,
+          decimals,
+          image,
+          isERC721,
+          aggregators,
+          name
+        };
+        const previousImportedIndex = newTokens.findIndex(
+          (token) => token.address.toLowerCase() === checksumAddress.toLowerCase()
+        );
+        if (previousImportedIndex !== -1) {
+          newTokens[previousImportedIndex] = newEntry;
+        } else {
+          const ignoredTokenIndex = allIgnoredTokens?.[chainId]?.[accountAddress]?.indexOf(address) ?? -1;
+          if (ignoredTokenIndex === -1) {
+            const previousDetectedIndex = newDetectedTokens.findIndex(
+              (token) => token.address.toLowerCase() === checksumAddress.toLowerCase()
+            );
+            if (previousDetectedIndex !== -1) {
+              newDetectedTokens[previousDetectedIndex] = newEntry;
+            } else {
+              newDetectedTokens.push(newEntry);
+            }
+          }
+        }
+      });
+      const { newAllTokens, newAllDetectedTokens } = this._getNewAllTokensState(
+        {
+          newTokens,
+          newDetectedTokens,
+          interactingAddress: accountAddress,
+          interactingChainId: chainId
+        }
+      );
+      const { chainId: currentChain, selectedAddress: currentAddress } = this.config;
+      newTokens = newAllTokens?.[currentChain]?.[currentAddress] || [];
+      newDetectedTokens = newAllDetectedTokens?.[currentChain]?.[currentAddress] || [];
+      this.update({
+        tokens: newTokens,
+        allTokens: newAllTokens,
+        detectedTokens: newDetectedTokens,
+        allDetectedTokens: newAllDetectedTokens
+      });
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Adds isERC721 field to token object. This is called when a user attempts to add tokens that
+   * were previously added which do not yet had isERC721 field.
+   *
+   * @param tokenAddress - The contract address of the token requiring the isERC721 field added.
+   * @returns The new token object with the added isERC721 field.
+   */
+  async updateTokenType(tokenAddress) {
+    const isERC721 = await this._detectIsERC721(tokenAddress);
+    const { tokens } = this.state;
+    const tokenIndex = tokens.findIndex((token) => {
+      return token.address.toLowerCase() === tokenAddress.toLowerCase();
+    });
+    tokens[tokenIndex].isERC721 = isERC721;
+    this.update({ tokens });
+    return tokens[tokenIndex];
+  }
+  /**
+   * This is a function that updates the tokens name for the tokens name if it is not defined.
+   *
+   * @param tokenList - Represents the fetched token list from service API
+   * @param tokenAttribute - Represents the token attribute that we want to update on the token list
+   */
+  updateTokensAttribute(tokenList, tokenAttribute) {
+    const { tokens } = this.state;
+    const newTokens = tokens.map((token) => {
+      const newToken = tokenList[token.address.toLowerCase()];
+      return !token[tokenAttribute] && newToken?.[tokenAttribute] ? { ...token, [tokenAttribute]: newToken[tokenAttribute] } : { ...token };
+    });
+    this.update({ tokens: newTokens });
+  }
+  /**
+   * Detects whether or not a token is ERC-721 compatible.
+   *
+   * @param tokenAddress - The token contract address.
+   * @param networkClientId - Optional network client ID to fetch contract info with.
+   * @returns A boolean indicating whether the token address passed in supports the EIP-721
+   * interface.
+   */
+  async _detectIsERC721(tokenAddress, networkClientId) {
+    const checksumAddress = toChecksumHexAddress(tokenAddress);
+    if (contractsMap[checksumAddress]?.erc721 === true) {
+      return Promise.resolve(true);
+    } else if (contractsMap[checksumAddress]?.erc20 === true) {
+      return Promise.resolve(false);
+    }
+    const tokenContract = this._createEthersContract(
+      tokenAddress,
+      abiERC721,
+      networkClientId
+    );
+    try {
+      return await tokenContract.supportsInterface(ERC721_INTERFACE_ID);
+    } catch (error) {
+      return false;
+    }
+  }
+  _getProvider(networkClientId) {
+    return new Web3Provider(
+      // @ts-expect-error TODO: remove this annotation once the `Eip1193Provider` class is released
+      networkClientId ? this.messagingSystem.call(
+        "NetworkController:getNetworkClientById",
+        networkClientId
+      ).provider : this.config.provider
+    );
+  }
+  _createEthersContract(tokenAddress, abi, networkClientId) {
+    const web3provider = this._getProvider(networkClientId);
+    const tokenContract = new Contract(tokenAddress, abi, web3provider);
+    return tokenContract;
+  }
+  _generateRandomId() {
+    return random();
+  }
+  /**
+   * Adds a new suggestedAsset to the list of watched assets.
+   * Parameters will be validated according to the asset type being watched.
+   *
+   * @param options - The method options.
+   * @param options.asset - The asset to be watched. For now only ERC20 tokens are accepted.
+   * @param options.type - The asset type.
+   * @param options.interactingAddress - The address of the account that is requesting to watch the asset.
+   * @param options.networkClientId - Network Client ID.
+   * @returns A promise that resolves if the asset was watched successfully, and rejects otherwise.
+   */
+  async watchAsset({
+    asset,
+    type,
+    interactingAddress,
+    networkClientId
+  }) {
+    if (type !== ERC20) {
+      throw new Error(`Asset of type ${type} not supported`);
+    }
+    if (!asset.address) {
+      throw rpcErrors.invalidParams("Address must be specified");
+    }
+    if (!isValidHexAddress(asset.address)) {
+      throw rpcErrors.invalidParams(`Invalid address "${asset.address}"`);
+    }
+    if (await this._detectIsERC721(asset.address, networkClientId)) {
+      throw rpcErrors.invalidParams(
+        `Contract ${asset.address} must match type ${type}, but was detected as ${ERC721}`
+      );
+    }
+    const provider = this._getProvider(networkClientId);
+    const isErc1155 = await safelyExecute(
+      () => new ERC1155Standard(provider).contractSupportsBase1155Interface(
+        asset.address
+      )
+    );
+    if (isErc1155) {
+      throw rpcErrors.invalidParams(
+        `Contract ${asset.address} must match type ${type}, but was detected as ${ERC1155}`
+      );
+    }
+    const erc20 = new ERC20Standard(provider);
+    const [contractName, contractSymbol, contractDecimals] = await Promise.all([
+      safelyExecute(() => erc20.getTokenName(asset.address)),
+      safelyExecute(() => erc20.getTokenSymbol(asset.address)),
+      safelyExecute(async () => erc20.getTokenDecimals(asset.address))
+    ]);
+    asset.name = contractName;
+    if (!asset.symbol && !contractSymbol) {
+      throw rpcErrors.invalidParams(
+        "A symbol is required, but was not found in either the request or contract"
+      );
+    }
+    if (contractSymbol !== void 0 && asset.symbol !== void 0 && asset.symbol.toUpperCase() !== contractSymbol.toUpperCase()) {
+      throw rpcErrors.invalidParams(
+        `The symbol in the request (${asset.symbol}) does not match the symbol in the contract (${contractSymbol})`
+      );
+    }
+    asset.symbol = contractSymbol ?? asset.symbol;
+    if (typeof asset.symbol !== "string") {
+      throw rpcErrors.invalidParams(`Invalid symbol: not a string`);
+    }
+    if (asset.symbol.length > 11) {
+      throw rpcErrors.invalidParams(
+        `Invalid symbol "${asset.symbol}": longer than 11 characters`
+      );
+    }
+    if (asset.decimals === void 0 && contractDecimals === void 0) {
+      throw rpcErrors.invalidParams(
+        "Decimals are required, but were not found in either the request or contract"
+      );
+    }
+    if (contractDecimals !== void 0 && asset.decimals !== void 0 && String(asset.decimals) !== contractDecimals) {
+      throw rpcErrors.invalidParams(
+        `The decimals in the request (${asset.decimals}) do not match the decimals in the contract (${contractDecimals})`
+      );
+    }
+    const decimalsStr = contractDecimals ?? asset.decimals;
+    const decimalsNum = parseInt(decimalsStr, 10);
+    if (!Number.isInteger(decimalsNum) || decimalsNum > 36 || decimalsNum < 0) {
+      throw rpcErrors.invalidParams(
+        `Invalid decimals "${decimalsStr}": must be an integer 0 <= 36`
+      );
+    }
+    asset.decimals = decimalsNum;
+    const suggestedAssetMeta = {
+      asset,
+      id: this._generateRandomId(),
+      time: Date.now(),
+      type,
+      interactingAddress: interactingAddress || this.config.selectedAddress
+    };
+    await this._requestApproval(suggestedAssetMeta);
+    const { address, symbol, decimals, name, image } = asset;
+    await this.addToken({
+      address,
+      symbol,
+      decimals,
+      name,
+      image,
+      interactingAddress: suggestedAssetMeta.interactingAddress,
+      networkClientId
+    });
+  }
+  /**
+   * Takes a new tokens and ignoredTokens array for the current network/account combination
+   * and returns new allTokens and allIgnoredTokens state to update to.
+   *
+   * @param params - Object that holds token params.
+   * @param params.newTokens - The new tokens to set for the current network and selected account.
+   * @param params.newIgnoredTokens - The new ignored tokens to set for the current network and selected account.
+   * @param params.newDetectedTokens - The new detected tokens to set for the current network and selected account.
+   * @param params.interactingAddress - The account address to use to store the tokens.
+   * @param params.interactingChainId - The chainId to use to store the tokens.
+   * @returns The updated `allTokens` and `allIgnoredTokens` state.
+   */
+  _getNewAllTokensState(params) {
+    const {
+      newTokens,
+      newIgnoredTokens,
+      newDetectedTokens,
+      interactingAddress,
+      interactingChainId
+    } = params;
+    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
+    const { chainId, selectedAddress } = this.config;
+    const userAddressToAddTokens = interactingAddress ?? selectedAddress;
+    const chainIdToAddTokens = interactingChainId ?? chainId;
+    let newAllTokens = allTokens;
+    if (newTokens?.length || newTokens && allTokens && allTokens[chainIdToAddTokens] && allTokens[chainIdToAddTokens][userAddressToAddTokens]) {
+      const networkTokens = allTokens[chainIdToAddTokens];
+      const newNetworkTokens = {
+        ...networkTokens,
+        ...{ [userAddressToAddTokens]: newTokens }
+      };
+      newAllTokens = {
+        ...allTokens,
+        ...{ [chainIdToAddTokens]: newNetworkTokens }
+      };
+    }
+    let newAllIgnoredTokens = allIgnoredTokens;
+    if (newIgnoredTokens?.length || newIgnoredTokens && allIgnoredTokens && allIgnoredTokens[chainIdToAddTokens] && allIgnoredTokens[chainIdToAddTokens][userAddressToAddTokens]) {
+      const networkIgnoredTokens = allIgnoredTokens[chainIdToAddTokens];
+      const newIgnoredNetworkTokens = {
+        ...networkIgnoredTokens,
+        ...{ [userAddressToAddTokens]: newIgnoredTokens }
+      };
+      newAllIgnoredTokens = {
+        ...allIgnoredTokens,
+        ...{ [chainIdToAddTokens]: newIgnoredNetworkTokens }
+      };
+    }
+    let newAllDetectedTokens = allDetectedTokens;
+    if (newDetectedTokens?.length || newDetectedTokens && allDetectedTokens && allDetectedTokens[chainIdToAddTokens] && allDetectedTokens[chainIdToAddTokens][userAddressToAddTokens]) {
+      const networkDetectedTokens = allDetectedTokens[chainIdToAddTokens];
+      const newDetectedNetworkTokens = {
+        ...networkDetectedTokens,
+        ...{ [userAddressToAddTokens]: newDetectedTokens }
+      };
+      newAllDetectedTokens = {
+        ...allDetectedTokens,
+        ...{ [chainIdToAddTokens]: newDetectedNetworkTokens }
+      };
+    }
+    return { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens };
+  }
+  /**
+   * Removes all tokens from the ignored list.
+   */
+  clearIgnoredTokens() {
+    this.update({ ignoredTokens: [], allIgnoredTokens: {} });
+  }
+  async _requestApproval(suggestedAssetMeta) {
+    return this.messagingSystem.call(
+      "ApprovalController:addRequest",
+      {
+        id: suggestedAssetMeta.id,
+        origin: ORIGIN_METAMASK,
+        type: ApprovalType.WatchAsset,
+        requestData: {
+          id: suggestedAssetMeta.id,
+          interactingAddress: suggestedAssetMeta.interactingAddress,
+          asset: {
+            address: suggestedAssetMeta.asset.address,
+            decimals: suggestedAssetMeta.asset.decimals,
+            symbol: suggestedAssetMeta.asset.symbol,
+            image: suggestedAssetMeta.asset.image || null
+          }
+        }
+      },
+      true
+    );
+  }
+};
+var TokensController_default = TokensController;
+
+export {
+  getDefaultTokensState,
+  TokensController,
+  TokensController_default
+};
+//# sourceMappingURL=chunk-MDHJNCTR.mjs.map
\ No newline at end of file
diff --git a/dist/chunk-MDHJNCTR.mjs.map b/dist/chunk-MDHJNCTR.mjs.map
new file mode 100644
index 0000000000000000000000000000000000000000..2efffe9b510b48520ea9bb8d0037678bbbdc495b
--- /dev/null
+++ b/dist/chunk-MDHJNCTR.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/TokensController.ts"],"sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport { Web3Provider } from '@ethersproject/providers';\nimport type { AddApprovalRequest } from '@metamask/approval-controller';\nimport type {\n  BaseConfig,\n  BaseState,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseControllerV1 } from '@metamask/base-controller';\nimport contractsMap from '@metamask/contract-metadata';\nimport {\n  toChecksumHexAddress,\n  ERC721_INTERFACE_ID,\n  ORIGIN_METAMASK,\n  ApprovalType,\n  ERC20,\n  ERC721,\n  ERC1155,\n  isValidHexAddress,\n  safelyExecute,\n} from '@metamask/controller-utils';\nimport { abiERC721 } from '@metamask/metamask-eth-abis';\nimport type {\n  NetworkClientId,\n  NetworkControllerGetNetworkClientByIdAction,\n  NetworkControllerNetworkDidChangeEvent,\n  Provider,\n} from '@metamask/network-controller';\nimport type { PreferencesControllerStateChangeEvent } from '@metamask/preferences-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { Hex } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport { EventEmitter } from 'events';\nimport type { Patch } from 'immer/dist/immer';\nimport { v1 as random } from 'uuid';\n\nimport { formatAggregatorNames, formatIconUrlWithProxy } from './assetsUtil';\nimport { ERC20Standard } from './Standards/ERC20Standard';\nimport { ERC1155Standard } from './Standards/NftStandards/ERC1155/ERC1155Standard';\nimport {\n  fetchTokenMetadata,\n  TOKEN_METADATA_NO_SUPPORT_ERROR,\n} from './token-service';\nimport type {\n  TokenListMap,\n  TokenListStateChange,\n  TokenListToken,\n} from './TokenListController';\nimport type { Token } from './TokenRatesController';\n\n/**\n * @type TokensConfig\n *\n * Tokens controller configuration\n * @property selectedAddress - Vault selected address\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface TokensConfig extends BaseConfig {\n  selectedAddress: string;\n  chainId: Hex;\n  provider: Provider | undefined;\n}\n\n/**\n * @type SuggestedAssetMeta\n *\n * Suggested asset by EIP747 meta data\n * @property id - Generated UUID associated with this suggested asset\n * @property time - Timestamp associated with this this suggested asset\n * @property type - Type type this suggested asset\n * @property asset - Asset suggested object\n * @property interactingAddress - Account address that requested watch asset\n */\ntype SuggestedAssetMeta = {\n  id: string;\n  time: number;\n  type: string;\n  asset: Token;\n  interactingAddress: string;\n};\n\n/**\n * @type TokensState\n *\n * Assets controller state\n * @property tokens - List of tokens associated with the active network and address pair\n * @property ignoredTokens - List of ignoredTokens associated with the active network and address pair\n * @property detectedTokens - List of detected tokens associated with the active network and address pair\n * @property allTokens - Object containing tokens by network and account\n * @property allIgnoredTokens - Object containing hidden/ignored tokens by network and account\n * @property allDetectedTokens - Object containing tokens detected with non-zero balances\n */\nexport type TokensState = {\n  tokens: Token[];\n  ignoredTokens: string[];\n  detectedTokens: Token[];\n  allTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  allIgnoredTokens: { [chainId: Hex]: { [key: string]: string[] } };\n  allDetectedTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n};\n\n/**\n * The name of the {@link TokensController}.\n */\nconst controllerName = 'TokensController';\n\nexport type TokensControllerActions =\n  | TokensControllerGetStateAction\n  | TokensControllerAddDetectedTokensAction;\n\n// TODO: Once `TokensController` is upgraded to V2, rewrite this type using the `ControllerGetStateAction` type, which constrains `TokensState` as `Record<string, Json>`.\nexport type TokensControllerGetStateAction = {\n  type: `${typeof controllerName}:getState`;\n  handler: () => TokensState;\n};\n\nexport type TokensControllerAddDetectedTokensAction = {\n  type: `${typeof controllerName}:addDetectedTokens`;\n  handler: TokensController['addDetectedTokens'];\n};\n\n/**\n * The external actions available to the {@link TokensController}.\n */\nexport type AllowedActions =\n  | AddApprovalRequest\n  | NetworkControllerGetNetworkClientByIdAction;\n\n// TODO: Once `TokensController` is upgraded to V2, rewrite this type using the `ControllerStateChangeEvent` type, which constrains `TokensState` as `Record<string, Json>`.\nexport type TokensControllerStateChangeEvent = {\n  type: `${typeof controllerName}:stateChange`;\n  payload: [TokensState, Patch[]];\n};\n\nexport type TokensControllerEvents = TokensControllerStateChangeEvent;\n\nexport type AllowedEvents =\n  | NetworkControllerNetworkDidChangeEvent\n  | PreferencesControllerStateChangeEvent\n  | TokenListStateChange;\n\n/**\n * The messenger of the {@link TokensController}.\n */\nexport type TokensControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  TokensControllerActions | AllowedActions,\n  TokensControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\nexport const getDefaultTokensState = (): TokensState => {\n  return {\n    tokens: [],\n    ignoredTokens: [],\n    detectedTokens: [],\n    allTokens: {},\n    allIgnoredTokens: {},\n    allDetectedTokens: {},\n  };\n};\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class TokensController extends BaseControllerV1<\n  TokensConfig,\n  TokensState & BaseState\n> {\n  private readonly mutex = new Mutex();\n\n  private abortController: AbortController;\n\n  private readonly messagingSystem: TokensControllerMessenger;\n\n  /**\n   * Fetch metadata for a token.\n   *\n   * @param tokenAddress - The address of the token.\n   * @returns The token metadata.\n   */\n  private async fetchTokenMetadata(\n    tokenAddress: string,\n  ): Promise<TokenListToken | undefined> {\n    try {\n      const token = await fetchTokenMetadata<TokenListToken>(\n        this.config.chainId,\n        tokenAddress,\n        this.abortController.signal,\n      );\n      return token;\n    } catch (error) {\n      if (\n        error instanceof Error &&\n        error.message.includes(TOKEN_METADATA_NO_SUPPORT_ERROR)\n      ) {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokensController';\n\n  /**\n   * Creates a TokensController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.config - Initial options used to configure this controller.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.messenger - The controller messenger.\n   */\n  constructor({\n    chainId: initialChainId,\n    config,\n    state,\n    messenger,\n  }: {\n    chainId: Hex;\n    config?: Partial<TokensConfig>;\n    state?: Partial<TokensState>;\n    messenger: TokensControllerMessenger;\n  }) {\n    super(config, state);\n\n    this.defaultConfig = {\n      selectedAddress: '',\n      chainId: initialChainId,\n      provider: undefined,\n      ...config,\n    };\n\n    this.defaultState = {\n      ...getDefaultTokensState(),\n      ...state,\n    };\n\n    this.initialize();\n    this.abortController = new AbortController();\n\n    this.messagingSystem = messenger;\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:addDetectedTokens` as const,\n      this.addDetectedTokens.bind(this),\n    );\n\n    this.messagingSystem.subscribe(\n      'PreferencesController:stateChange',\n      ({ selectedAddress }) => {\n        const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n        const { chainId } = this.config;\n        this.configure({ selectedAddress });\n        this.update({\n          tokens: allTokens[chainId]?.[selectedAddress] ?? [],\n          ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] ?? [],\n          detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] ?? [],\n        });\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'NetworkController:networkDidChange',\n      ({ providerConfig }) => {\n        const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n        const { selectedAddress } = this.config;\n        const { chainId } = providerConfig;\n        this.abortController.abort();\n        this.abortController = new AbortController();\n        this.configure({ chainId });\n        this.update({\n          tokens: allTokens[chainId]?.[selectedAddress] || [],\n          ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] || [],\n          detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] || [],\n        });\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'TokenListController:stateChange',\n      ({ tokenList }) => {\n        const { tokens } = this.state;\n        if (tokens.length && !tokens[0].name) {\n          this.updateTokensAttribute(tokenList, 'name');\n        }\n      },\n    );\n  }\n\n  /**\n   * Adds a token to the stored token list.\n   *\n   * @param options - The method argument object.\n   * @param options.address - Hex address of the token contract.\n   * @param options.symbol - Symbol of the token.\n   * @param options.decimals - Number of decimals the token uses.\n   * @param options.name - Name of the token.\n   * @param options.image - Image of the token.\n   * @param options.interactingAddress - The address of the account to add a token to.\n   * @param options.networkClientId - Network Client ID.\n   * @returns Current token list.\n   */\n  async addToken({\n    address,\n    symbol,\n    decimals,\n    name,\n    image,\n    interactingAddress,\n    networkClientId,\n  }: {\n    address: string;\n    symbol: string;\n    decimals: number;\n    name?: string;\n    image?: string;\n    interactingAddress?: string;\n    networkClientId?: NetworkClientId;\n  }): Promise<Token[]> {\n    const { chainId, selectedAddress } = this.config;\n    const releaseLock = await this.mutex.acquire();\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    let currentChainId = chainId;\n    if (networkClientId) {\n      currentChainId = this.messagingSystem.call(\n        'NetworkController:getNetworkClientById',\n        networkClientId,\n      ).configuration.chainId;\n    }\n\n    const accountAddress = interactingAddress || selectedAddress;\n    const isInteractingWithWalletAccount = accountAddress === selectedAddress;\n\n    try {\n      address = toChecksumHexAddress(address);\n      const tokens = allTokens[currentChainId]?.[accountAddress] || [];\n      const ignoredTokens =\n        allIgnoredTokens[currentChainId]?.[accountAddress] || [];\n      const detectedTokens =\n        allDetectedTokens[currentChainId]?.[accountAddress] || [];\n      const newTokens: Token[] = [...tokens];\n      const [isERC721, tokenMetadata] = await Promise.all([\n        this._detectIsERC721(address, networkClientId),\n        // TODO parameterize the token metadata fetch by networkClientId\n        this.fetchTokenMetadata(address),\n      ]);\n      // TODO remove this once this method is fully parameterized by networkClientId\n      if (!networkClientId && currentChainId !== this.config.chainId) {\n        throw new Error(\n          'TokensController Error: Switched networks while adding token',\n        );\n      }\n      const newEntry: Token = {\n        address,\n        symbol,\n        decimals,\n        image:\n          image ||\n          formatIconUrlWithProxy({\n            chainId: currentChainId,\n            tokenAddress: address,\n          }),\n        isERC721,\n        aggregators: formatAggregatorNames(tokenMetadata?.aggregators || []),\n        name,\n      };\n      const previousIndex = newTokens.findIndex(\n        (token) => token.address.toLowerCase() === address.toLowerCase(),\n      );\n      if (previousIndex !== -1) {\n        newTokens[previousIndex] = newEntry;\n      } else {\n        newTokens.push(newEntry);\n      }\n\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase(),\n      );\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => token.address.toLowerCase() !== address.toLowerCase(),\n      );\n\n      const { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens } =\n        this._getNewAllTokensState({\n          newTokens,\n          newIgnoredTokens,\n          newDetectedTokens,\n          interactingAddress: accountAddress,\n          interactingChainId: currentChainId,\n        });\n\n      let newState: Partial<TokensState> = {\n        allTokens: newAllTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n        allDetectedTokens: newAllDetectedTokens,\n      };\n\n      // Only update active tokens if user is interacting with their active wallet account.\n      if (isInteractingWithWalletAccount) {\n        newState = {\n          ...newState,\n          tokens: newTokens,\n          ignoredTokens: newIgnoredTokens,\n          detectedTokens: newDetectedTokens,\n        };\n      }\n\n      this.update(newState);\n      return newTokens;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Add a batch of tokens.\n   *\n   * @param tokensToImport - Array of tokens to import.\n   * @param networkClientId - Optional network client ID used to determine interacting chain ID.\n   */\n  async addTokens(tokensToImport: Token[], networkClientId?: NetworkClientId) {\n    const releaseLock = await this.mutex.acquire();\n    const { tokens, detectedTokens, ignoredTokens } = this.state;\n    const importedTokensMap: { [key: string]: true } = {};\n    // Used later to dedupe imported tokens\n    const newTokensMap = tokens.reduce((output, current) => {\n      output[current.address] = current;\n      return output;\n    }, {} as { [address: string]: Token });\n    try {\n      tokensToImport.forEach((tokenToAdd) => {\n        const { address, symbol, decimals, image, aggregators, name } =\n          tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const formattedToken: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          aggregators,\n          name,\n        };\n        newTokensMap[address] = formattedToken;\n        importedTokensMap[address.toLowerCase()] = true;\n        return formattedToken;\n      });\n      const newTokens = Object.values(newTokensMap);\n\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => !importedTokensMap[token.address.toLowerCase()],\n      );\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => !newTokensMap[tokenAddress.toLowerCase()],\n      );\n\n      let interactingChainId;\n      if (networkClientId) {\n        interactingChainId = this.messagingSystem.call(\n          'NetworkController:getNetworkClientById',\n          networkClientId,\n        ).configuration.chainId;\n      }\n\n      const { newAllTokens, newAllDetectedTokens, newAllIgnoredTokens } =\n        this._getNewAllTokensState({\n          newTokens,\n          newDetectedTokens,\n          newIgnoredTokens,\n          interactingChainId,\n        });\n\n      this.update({\n        tokens: newTokens,\n        allTokens: newAllTokens,\n        detectedTokens: newDetectedTokens,\n        allDetectedTokens: newAllDetectedTokens,\n        ignoredTokens: newIgnoredTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Ignore a batch of tokens.\n   *\n   * @param tokenAddressesToIgnore - Array of token addresses to ignore.\n   */\n  ignoreTokens(tokenAddressesToIgnore: string[]) {\n    const { ignoredTokens, detectedTokens, tokens } = this.state;\n    const ignoredTokensMap: { [key: string]: true } = {};\n    let newIgnoredTokens: string[] = [...ignoredTokens];\n\n    const checksummedTokenAddresses = tokenAddressesToIgnore.map((address) => {\n      const checksumAddress = toChecksumHexAddress(address);\n      ignoredTokensMap[address.toLowerCase()] = true;\n      return checksumAddress;\n    });\n    newIgnoredTokens = [...ignoredTokens, ...checksummedTokenAddresses];\n    const newDetectedTokens = detectedTokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n    const newTokens = tokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n\n    const { newAllIgnoredTokens, newAllDetectedTokens, newAllTokens } =\n      this._getNewAllTokensState({\n        newIgnoredTokens,\n        newDetectedTokens,\n        newTokens,\n      });\n\n    this.update({\n      ignoredTokens: newIgnoredTokens,\n      tokens: newTokens,\n      detectedTokens: newDetectedTokens,\n      allIgnoredTokens: newAllIgnoredTokens,\n      allDetectedTokens: newAllDetectedTokens,\n      allTokens: newAllTokens,\n    });\n  }\n\n  /**\n   * Adds a batch of detected tokens to the stored token list.\n   *\n   * @param incomingDetectedTokens - Array of detected tokens to be added or updated.\n   * @param detectionDetails - An object containing the chain ID and address of the currently selected network on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.selectedAddress - the account address on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.chainId - the chainId on which the incomingDetectedTokens were detected.\n   */\n  async addDetectedTokens(\n    incomingDetectedTokens: Token[],\n    detectionDetails?: { selectedAddress: string; chainId: Hex },\n  ) {\n    const releaseLock = await this.mutex.acquire();\n\n    // Get existing tokens for the chain + account\n    const chainId = detectionDetails?.chainId ?? this.config.chainId;\n    const accountAddress =\n      detectionDetails?.selectedAddress ?? this.config.selectedAddress;\n\n    const { allTokens, allDetectedTokens, allIgnoredTokens } = this.state;\n    let newTokens = [...(allTokens?.[chainId]?.[accountAddress] ?? [])];\n    let newDetectedTokens = [\n      ...(allDetectedTokens?.[chainId]?.[accountAddress] ?? []),\n    ];\n\n    try {\n      incomingDetectedTokens.forEach((tokenToAdd) => {\n        const {\n          address,\n          symbol,\n          decimals,\n          image,\n          aggregators,\n          isERC721,\n          name,\n        } = tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const newEntry: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          isERC721,\n          aggregators,\n          name,\n        };\n        const previousImportedIndex = newTokens.findIndex(\n          (token) =>\n            token.address.toLowerCase() === checksumAddress.toLowerCase(),\n        );\n        if (previousImportedIndex !== -1) {\n          // Update existing data of imported token\n          newTokens[previousImportedIndex] = newEntry;\n        } else {\n          const ignoredTokenIndex =\n            allIgnoredTokens?.[chainId]?.[accountAddress]?.indexOf(address) ??\n            -1;\n\n          if (ignoredTokenIndex === -1) {\n            // Add detected token\n            const previousDetectedIndex = newDetectedTokens.findIndex(\n              (token) =>\n                token.address.toLowerCase() === checksumAddress.toLowerCase(),\n            );\n            if (previousDetectedIndex !== -1) {\n              newDetectedTokens[previousDetectedIndex] = newEntry;\n            } else {\n              newDetectedTokens.push(newEntry);\n            }\n          }\n        }\n      });\n\n      const { newAllTokens, newAllDetectedTokens } = this._getNewAllTokensState(\n        {\n          newTokens,\n          newDetectedTokens,\n          interactingAddress: accountAddress,\n          interactingChainId: chainId,\n        },\n      );\n\n      // We may be detecting tokens on a different chain/account pair than are currently configured.\n      // Re-point `tokens` and `detectedTokens` to keep them referencing the current chain/account.\n      const { chainId: currentChain, selectedAddress: currentAddress } =\n        this.config;\n\n      newTokens = newAllTokens?.[currentChain]?.[currentAddress] || [];\n      newDetectedTokens =\n        newAllDetectedTokens?.[currentChain]?.[currentAddress] || [];\n\n      this.update({\n        tokens: newTokens,\n        allTokens: newAllTokens,\n        detectedTokens: newDetectedTokens,\n        allDetectedTokens: newAllDetectedTokens,\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds isERC721 field to token object. This is called when a user attempts to add tokens that\n   * were previously added which do not yet had isERC721 field.\n   *\n   * @param tokenAddress - The contract address of the token requiring the isERC721 field added.\n   * @returns The new token object with the added isERC721 field.\n   */\n  async updateTokenType(tokenAddress: string) {\n    const isERC721 = await this._detectIsERC721(tokenAddress);\n    const { tokens } = this.state;\n    const tokenIndex = tokens.findIndex((token) => {\n      return token.address.toLowerCase() === tokenAddress.toLowerCase();\n    });\n    tokens[tokenIndex].isERC721 = isERC721;\n    this.update({ tokens });\n    return tokens[tokenIndex];\n  }\n\n  /**\n   * This is a function that updates the tokens name for the tokens name if it is not defined.\n   *\n   * @param tokenList - Represents the fetched token list from service API\n   * @param tokenAttribute - Represents the token attribute that we want to update on the token list\n   */\n  private updateTokensAttribute(\n    tokenList: TokenListMap,\n    tokenAttribute: keyof Token & keyof TokenListToken,\n  ) {\n    const { tokens } = this.state;\n\n    const newTokens = tokens.map((token) => {\n      const newToken = tokenList[token.address.toLowerCase()];\n\n      return !token[tokenAttribute] && newToken?.[tokenAttribute]\n        ? { ...token, [tokenAttribute]: newToken[tokenAttribute] }\n        : { ...token };\n    });\n\n    this.update({ tokens: newTokens });\n  }\n\n  /**\n   * Detects whether or not a token is ERC-721 compatible.\n   *\n   * @param tokenAddress - The token contract address.\n   * @param networkClientId - Optional network client ID to fetch contract info with.\n   * @returns A boolean indicating whether the token address passed in supports the EIP-721\n   * interface.\n   */\n  async _detectIsERC721(\n    tokenAddress: string,\n    networkClientId?: NetworkClientId,\n  ) {\n    const checksumAddress = toChecksumHexAddress(tokenAddress);\n    // if this token is already in our contract metadata map we don't need\n    // to check against the contract\n    if (contractsMap[checksumAddress]?.erc721 === true) {\n      return Promise.resolve(true);\n    } else if (contractsMap[checksumAddress]?.erc20 === true) {\n      return Promise.resolve(false);\n    }\n\n    const tokenContract = this._createEthersContract(\n      tokenAddress,\n      abiERC721,\n      networkClientId,\n    );\n    try {\n      return await tokenContract.supportsInterface(ERC721_INTERFACE_ID);\n    } catch (error) {\n      // currently we see a variety of errors across different networks when\n      // token contracts are not ERC721 compatible. We need to figure out a better\n      // way of differentiating token interface types but for now if we get an error\n      // we have to assume the token is not ERC721 compatible.\n      return false;\n    }\n  }\n\n  _getProvider(networkClientId?: NetworkClientId): Web3Provider {\n    return new Web3Provider(\n      // @ts-expect-error TODO: remove this annotation once the `Eip1193Provider` class is released\n      networkClientId\n        ? this.messagingSystem.call(\n            'NetworkController:getNetworkClientById',\n            networkClientId,\n          ).provider\n        : this.config.provider,\n    );\n  }\n\n  _createEthersContract(\n    tokenAddress: string,\n    abi: string,\n    networkClientId?: NetworkClientId,\n  ): Contract {\n    const web3provider = this._getProvider(networkClientId);\n    const tokenContract = new Contract(tokenAddress, abi, web3provider);\n    return tokenContract;\n  }\n\n  _generateRandomId(): string {\n    return random();\n  }\n\n  /**\n   * Adds a new suggestedAsset to the list of watched assets.\n   * Parameters will be validated according to the asset type being watched.\n   *\n   * @param options - The method options.\n   * @param options.asset - The asset to be watched. For now only ERC20 tokens are accepted.\n   * @param options.type - The asset type.\n   * @param options.interactingAddress - The address of the account that is requesting to watch the asset.\n   * @param options.networkClientId - Network Client ID.\n   * @returns A promise that resolves if the asset was watched successfully, and rejects otherwise.\n   */\n  async watchAsset({\n    asset,\n    type,\n    interactingAddress,\n    networkClientId,\n  }: {\n    asset: Token;\n    type: string;\n    interactingAddress?: string;\n    networkClientId?: NetworkClientId;\n  }): Promise<void> {\n    if (type !== ERC20) {\n      throw new Error(`Asset of type ${type} not supported`);\n    }\n\n    if (!asset.address) {\n      throw rpcErrors.invalidParams('Address must be specified');\n    }\n\n    if (!isValidHexAddress(asset.address)) {\n      throw rpcErrors.invalidParams(`Invalid address \"${asset.address}\"`);\n    }\n\n    // Validate contract\n\n    if (await this._detectIsERC721(asset.address, networkClientId)) {\n      throw rpcErrors.invalidParams(\n        `Contract ${asset.address} must match type ${type}, but was detected as ${ERC721}`,\n      );\n    }\n\n    const provider = this._getProvider(networkClientId);\n    const isErc1155 = await safelyExecute(() =>\n      new ERC1155Standard(provider).contractSupportsBase1155Interface(\n        asset.address,\n      ),\n    );\n    if (isErc1155) {\n      throw rpcErrors.invalidParams(\n        `Contract ${asset.address} must match type ${type}, but was detected as ${ERC1155}`,\n      );\n    }\n\n    const erc20 = new ERC20Standard(provider);\n    const [contractName, contractSymbol, contractDecimals] = await Promise.all([\n      safelyExecute(() => erc20.getTokenName(asset.address)),\n      safelyExecute(() => erc20.getTokenSymbol(asset.address)),\n      safelyExecute(async () => erc20.getTokenDecimals(asset.address)),\n    ]);\n\n    asset.name = contractName;\n\n    // Validate symbol\n\n    if (!asset.symbol && !contractSymbol) {\n      throw rpcErrors.invalidParams(\n        'A symbol is required, but was not found in either the request or contract',\n      );\n    }\n\n    if (\n      contractSymbol !== undefined &&\n      asset.symbol !== undefined &&\n      asset.symbol.toUpperCase() !== contractSymbol.toUpperCase()\n    ) {\n      throw rpcErrors.invalidParams(\n        `The symbol in the request (${asset.symbol}) does not match the symbol in the contract (${contractSymbol})`,\n      );\n    }\n\n    asset.symbol = contractSymbol ?? asset.symbol;\n    if (typeof asset.symbol !== 'string') {\n      throw rpcErrors.invalidParams(`Invalid symbol: not a string`);\n    }\n\n    if (asset.symbol.length > 11) {\n      throw rpcErrors.invalidParams(\n        `Invalid symbol \"${asset.symbol}\": longer than 11 characters`,\n      );\n    }\n\n    // Validate decimals\n\n    if (asset.decimals === undefined && contractDecimals === undefined) {\n      throw rpcErrors.invalidParams(\n        'Decimals are required, but were not found in either the request or contract',\n      );\n    }\n\n    if (\n      contractDecimals !== undefined &&\n      asset.decimals !== undefined &&\n      String(asset.decimals) !== contractDecimals\n    ) {\n      throw rpcErrors.invalidParams(\n        `The decimals in the request (${asset.decimals}) do not match the decimals in the contract (${contractDecimals})`,\n      );\n    }\n\n    const decimalsStr = contractDecimals ?? asset.decimals;\n    const decimalsNum = parseInt(decimalsStr as unknown as string, 10);\n    if (!Number.isInteger(decimalsNum) || decimalsNum > 36 || decimalsNum < 0) {\n      throw rpcErrors.invalidParams(\n        `Invalid decimals \"${decimalsStr}\": must be an integer 0 <= 36`,\n      );\n    }\n    asset.decimals = decimalsNum;\n\n    const suggestedAssetMeta: SuggestedAssetMeta = {\n      asset,\n      id: this._generateRandomId(),\n      time: Date.now(),\n      type,\n      interactingAddress: interactingAddress || this.config.selectedAddress,\n    };\n\n    await this._requestApproval(suggestedAssetMeta);\n\n    const { address, symbol, decimals, name, image } = asset;\n    await this.addToken({\n      address,\n      symbol,\n      decimals,\n      name,\n      image,\n      interactingAddress: suggestedAssetMeta.interactingAddress,\n      networkClientId,\n    });\n  }\n\n  /**\n   * Takes a new tokens and ignoredTokens array for the current network/account combination\n   * and returns new allTokens and allIgnoredTokens state to update to.\n   *\n   * @param params - Object that holds token params.\n   * @param params.newTokens - The new tokens to set for the current network and selected account.\n   * @param params.newIgnoredTokens - The new ignored tokens to set for the current network and selected account.\n   * @param params.newDetectedTokens - The new detected tokens to set for the current network and selected account.\n   * @param params.interactingAddress - The account address to use to store the tokens.\n   * @param params.interactingChainId - The chainId to use to store the tokens.\n   * @returns The updated `allTokens` and `allIgnoredTokens` state.\n   */\n  _getNewAllTokensState(params: {\n    newTokens?: Token[];\n    newIgnoredTokens?: string[];\n    newDetectedTokens?: Token[];\n    interactingAddress?: string;\n    interactingChainId?: Hex;\n  }) {\n    const {\n      newTokens,\n      newIgnoredTokens,\n      newDetectedTokens,\n      interactingAddress,\n      interactingChainId,\n    } = params;\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    const { chainId, selectedAddress } = this.config;\n\n    const userAddressToAddTokens = interactingAddress ?? selectedAddress;\n    const chainIdToAddTokens = interactingChainId ?? chainId;\n\n    let newAllTokens = allTokens;\n    if (\n      newTokens?.length ||\n      (newTokens &&\n        allTokens &&\n        allTokens[chainIdToAddTokens] &&\n        allTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkTokens = allTokens[chainIdToAddTokens];\n      const newNetworkTokens = {\n        ...networkTokens,\n        ...{ [userAddressToAddTokens]: newTokens },\n      };\n      newAllTokens = {\n        ...allTokens,\n        ...{ [chainIdToAddTokens]: newNetworkTokens },\n      };\n    }\n\n    let newAllIgnoredTokens = allIgnoredTokens;\n    if (\n      newIgnoredTokens?.length ||\n      (newIgnoredTokens &&\n        allIgnoredTokens &&\n        allIgnoredTokens[chainIdToAddTokens] &&\n        allIgnoredTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkIgnoredTokens = allIgnoredTokens[chainIdToAddTokens];\n      const newIgnoredNetworkTokens = {\n        ...networkIgnoredTokens,\n        ...{ [userAddressToAddTokens]: newIgnoredTokens },\n      };\n      newAllIgnoredTokens = {\n        ...allIgnoredTokens,\n        ...{ [chainIdToAddTokens]: newIgnoredNetworkTokens },\n      };\n    }\n\n    let newAllDetectedTokens = allDetectedTokens;\n    if (\n      newDetectedTokens?.length ||\n      (newDetectedTokens &&\n        allDetectedTokens &&\n        allDetectedTokens[chainIdToAddTokens] &&\n        allDetectedTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkDetectedTokens = allDetectedTokens[chainIdToAddTokens];\n      const newDetectedNetworkTokens = {\n        ...networkDetectedTokens,\n        ...{ [userAddressToAddTokens]: newDetectedTokens },\n      };\n      newAllDetectedTokens = {\n        ...allDetectedTokens,\n        ...{ [chainIdToAddTokens]: newDetectedNetworkTokens },\n      };\n    }\n    return { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens };\n  }\n\n  /**\n   * Removes all tokens from the ignored list.\n   */\n  clearIgnoredTokens() {\n    this.update({ ignoredTokens: [], allIgnoredTokens: {} });\n  }\n\n  async _requestApproval(suggestedAssetMeta: SuggestedAssetMeta) {\n    return this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        id: suggestedAssetMeta.id,\n        origin: ORIGIN_METAMASK,\n        type: ApprovalType.WatchAsset,\n        requestData: {\n          id: suggestedAssetMeta.id,\n          interactingAddress: suggestedAssetMeta.interactingAddress,\n          asset: {\n            address: suggestedAssetMeta.asset.address,\n            decimals: suggestedAssetMeta.asset.decimals,\n            symbol: suggestedAssetMeta.asset.symbol,\n            image: suggestedAssetMeta.asset.image || null,\n          },\n        },\n      },\n      true,\n    );\n  }\n}\n\nexport default TokensController;\n"],"mappings":"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","names":[]}
\ No newline at end of file
diff --git a/dist/chunk-NXGX7LZJ.mjs b/dist/chunk-NXGX7LZJ.mjs
deleted file mode 100644
index 580b67c0736e8c6054342bf5eb6cde98ba0ba96e..0000000000000000000000000000000000000000
--- a/dist/chunk-NXGX7LZJ.mjs
+++ /dev/null
@@ -1,74 +0,0 @@
-import {
-  isTokenListSupportedForNetwork
-} from "./chunk-X5PLVMOQ.mjs";
-
-// src/token-service.ts
-import { convertHexToDecimal, timeoutFetch } from "@metamask/controller-utils";
-var TOKEN_END_POINT_API = "https://token-api.metaswap.codefi.network";
-var TOKEN_METADATA_NO_SUPPORT_ERROR = "TokenService Error: Network does not support fetchTokenMetadata";
-function getTokensURL(chainId) {
-  return `${TOKEN_END_POINT_API}/tokens/${convertHexToDecimal(
-    chainId
-  )}?occurrenceFloor=3&includeNativeAssets=false&includeDuplicateSymbolAssets=false&includeTokenFees=false&includeAssetType=false`;
-}
-function getTokenMetadataURL(chainId, tokenAddress) {
-  return `${TOKEN_END_POINT_API}/token/${convertHexToDecimal(
-    chainId
-  )}?address=${tokenAddress}`;
-}
-var tenSecondsInMilliseconds = 1e4;
-var defaultTimeout = tenSecondsInMilliseconds;
-async function fetchTokenListByChainId(chainId, abortSignal, { timeout = defaultTimeout } = {}) {
-  const tokenURL = getTokensURL(chainId);
-  const response = await queryApi(tokenURL, abortSignal, timeout);
-  if (response) {
-    return parseJsonResponse(response);
-  }
-  return void 0;
-}
-async function fetchTokenMetadata(chainId, tokenAddress, abortSignal, { timeout = defaultTimeout } = {}) {
-  if (!isTokenListSupportedForNetwork(chainId)) {
-    throw new Error(TOKEN_METADATA_NO_SUPPORT_ERROR);
-  }
-  const tokenMetadataURL = getTokenMetadataURL(chainId, tokenAddress);
-  const response = await queryApi(tokenMetadataURL, abortSignal, timeout);
-  if (response) {
-    return parseJsonResponse(response);
-  }
-  return void 0;
-}
-async function queryApi(apiURL, abortSignal, timeout) {
-  const fetchOptions = {
-    referrer: apiURL,
-    referrerPolicy: "no-referrer-when-downgrade",
-    method: "GET",
-    mode: "cors",
-    signal: abortSignal,
-    cache: "default"
-  };
-  fetchOptions.headers = new window.Headers();
-  fetchOptions.headers.set("Content-Type", "application/json");
-  try {
-    return await timeoutFetch(apiURL, fetchOptions, timeout);
-  } catch (error) {
-    if (error instanceof Error && error.name === "AbortError") {
-      console.log("Request is aborted");
-    }
-  }
-  return void 0;
-}
-async function parseJsonResponse(apiResponse) {
-  const responseObj = await apiResponse.json();
-  if (responseObj?.error) {
-    throw new Error(`TokenService Error: ${responseObj.error}`);
-  }
-  return responseObj;
-}
-
-export {
-  TOKEN_END_POINT_API,
-  TOKEN_METADATA_NO_SUPPORT_ERROR,
-  fetchTokenListByChainId,
-  fetchTokenMetadata
-};
-//# sourceMappingURL=chunk-NXGX7LZJ.mjs.map
\ No newline at end of file
diff --git a/dist/chunk-NXGX7LZJ.mjs.map b/dist/chunk-NXGX7LZJ.mjs.map
deleted file mode 100644
index 8a4d0551478707d97f4ba76f6b3418eae08e6316..0000000000000000000000000000000000000000
--- a/dist/chunk-NXGX7LZJ.mjs.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["../src/token-service.ts"],"sourcesContent":["import { convertHexToDecimal, timeoutFetch } from '@metamask/controller-utils';\nimport type { Hex } from '@metamask/utils';\n\nimport { isTokenListSupportedForNetwork } from './assetsUtil';\n\nexport const TOKEN_END_POINT_API = 'https://token-api.metaswap.codefi.network';\nexport const TOKEN_METADATA_NO_SUPPORT_ERROR =\n  'TokenService Error: Network does not support fetchTokenMetadata';\n\n/**\n * Get the tokens URL for a specific network.\n *\n * @param chainId - The chain ID of the network the tokens requested are on.\n * @returns The tokens URL.\n */\nfunction getTokensURL(chainId: Hex) {\n  return `${TOKEN_END_POINT_API}/tokens/${convertHexToDecimal(\n    chainId,\n  )}?occurrenceFloor=3&includeNativeAssets=false&includeDuplicateSymbolAssets=false&includeTokenFees=false&includeAssetType=false`;\n}\n\n/**\n * Get the token metadata URL for the given network and token.\n *\n * @param chainId - The chain ID of the network the token is on.\n * @param tokenAddress - The token address.\n * @returns The token metadata URL.\n */\nfunction getTokenMetadataURL(chainId: Hex, tokenAddress: string) {\n  return `${TOKEN_END_POINT_API}/token/${convertHexToDecimal(\n    chainId,\n  )}?address=${tokenAddress}`;\n}\n\nconst tenSecondsInMilliseconds = 10_000;\n\n// Token list averages 1.6 MB in size\n// timeoutFetch by default has a 500ms timeout, which will almost always timeout given the response size.\nconst defaultTimeout = tenSecondsInMilliseconds;\n\n/**\n * Fetch the list of token metadata for a given network. This request is cancellable using the\n * abort signal passed in.\n *\n * @param chainId - The chain ID of the network the requested tokens are on.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param options - Additional fetch options.\n * @param options.timeout - The fetch timeout.\n * @returns The token list, or `undefined` if the request was cancelled.\n */\nexport async function fetchTokenListByChainId(\n  chainId: Hex,\n  abortSignal: AbortSignal,\n  { timeout = defaultTimeout } = {},\n): Promise<unknown> {\n  const tokenURL = getTokensURL(chainId);\n  const response = await queryApi(tokenURL, abortSignal, timeout);\n  if (response) {\n    return parseJsonResponse(response);\n  }\n  return undefined;\n}\n\n/**\n * Fetch metadata for the token address provided for a given network. This request is cancellable\n * using the abort signal passed in.\n *\n * @param chainId - The chain ID of the network the token is on.\n * @param tokenAddress - The address of the token to fetch metadata for.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param options - Additional fetch options.\n * @param options.timeout - The fetch timeout.\n * @returns The token metadata, or `undefined` if the request was either aborted or failed.\n */\nexport async function fetchTokenMetadata<T>(\n  chainId: Hex,\n  tokenAddress: string,\n  abortSignal: AbortSignal,\n  { timeout = defaultTimeout } = {},\n): Promise<T | undefined> {\n  if (!isTokenListSupportedForNetwork(chainId)) {\n    throw new Error(TOKEN_METADATA_NO_SUPPORT_ERROR);\n  }\n  const tokenMetadataURL = getTokenMetadataURL(chainId, tokenAddress);\n  const response = await queryApi(tokenMetadataURL, abortSignal, timeout);\n  if (response) {\n    return parseJsonResponse(response) as Promise<T>;\n  }\n  return undefined;\n}\n\n/**\n * Perform fetch request against the api.\n *\n * @param apiURL - The URL of the API to fetch.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param timeout - The fetch timeout.\n * @returns Promise resolving request response.\n */\nasync function queryApi(\n  apiURL: string,\n  abortSignal: AbortSignal,\n  timeout: number,\n): Promise<Response | undefined> {\n  const fetchOptions: RequestInit = {\n    referrer: apiURL,\n    referrerPolicy: 'no-referrer-when-downgrade',\n    method: 'GET',\n    mode: 'cors',\n    signal: abortSignal,\n    cache: 'default',\n  };\n  fetchOptions.headers = new window.Headers();\n  fetchOptions.headers.set('Content-Type', 'application/json');\n  try {\n    return await timeoutFetch(apiURL, fetchOptions, timeout);\n  } catch (error) {\n    if (error instanceof Error && error.name === 'AbortError') {\n      console.log('Request is aborted');\n    }\n  }\n  return undefined;\n}\n\n/**\n * Parse an API response and return the response JSON data.\n *\n * @param apiResponse - The API response to parse.\n * @returns The response JSON data.\n * @throws Will throw if the response includes an error.\n */\nasync function parseJsonResponse(apiResponse: Response): Promise<unknown> {\n  const responseObj = await apiResponse.json();\n  // api may return errors as json without setting an error http status code\n  if (responseObj?.error) {\n    throw new Error(`TokenService Error: ${responseObj.error}`);\n  }\n  return responseObj;\n}\n"],"mappings":";;;;;AAAA,SAAS,qBAAqB,oBAAoB;AAK3C,IAAM,sBAAsB;AAC5B,IAAM,kCACX;AAQF,SAAS,aAAa,SAAc;AAClC,SAAO,GAAG,mBAAmB,WAAW;AAAA,IACtC;AAAA,EACF,CAAC;AACH;AASA,SAAS,oBAAoB,SAAc,cAAsB;AAC/D,SAAO,GAAG,mBAAmB,UAAU;AAAA,IACrC;AAAA,EACF,CAAC,YAAY,YAAY;AAC3B;AAEA,IAAM,2BAA2B;AAIjC,IAAM,iBAAiB;AAYvB,eAAsB,wBACpB,SACA,aACA,EAAE,UAAU,eAAe,IAAI,CAAC,GACd;AAClB,QAAM,WAAW,aAAa,OAAO;AACrC,QAAM,WAAW,MAAM,SAAS,UAAU,aAAa,OAAO;AAC9D,MAAI,UAAU;AACZ,WAAO,kBAAkB,QAAQ;AAAA,EACnC;AACA,SAAO;AACT;AAaA,eAAsB,mBACpB,SACA,cACA,aACA,EAAE,UAAU,eAAe,IAAI,CAAC,GACR;AACxB,MAAI,CAAC,+BAA+B,OAAO,GAAG;AAC5C,UAAM,IAAI,MAAM,+BAA+B;AAAA,EACjD;AACA,QAAM,mBAAmB,oBAAoB,SAAS,YAAY;AAClE,QAAM,WAAW,MAAM,SAAS,kBAAkB,aAAa,OAAO;AACtE,MAAI,UAAU;AACZ,WAAO,kBAAkB,QAAQ;AAAA,EACnC;AACA,SAAO;AACT;AAUA,eAAe,SACb,QACA,aACA,SAC+B;AAC/B,QAAM,eAA4B;AAAA,IAChC,UAAU;AAAA,IACV,gBAAgB;AAAA,IAChB,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,OAAO;AAAA,EACT;AACA,eAAa,UAAU,IAAI,OAAO,QAAQ;AAC1C,eAAa,QAAQ,IAAI,gBAAgB,kBAAkB;AAC3D,MAAI;AACF,WAAO,MAAM,aAAa,QAAQ,cAAc,OAAO;AAAA,EACzD,SAAS,OAAO;AACd,QAAI,iBAAiB,SAAS,MAAM,SAAS,cAAc;AACzD,cAAQ,IAAI,oBAAoB;AAAA,IAClC;AAAA,EACF;AACA,SAAO;AACT;AASA,eAAe,kBAAkB,aAAyC;AACxE,QAAM,cAAc,MAAM,YAAY,KAAK;AAE3C,MAAI,aAAa,OAAO;AACtB,UAAM,IAAI,MAAM,uBAAuB,YAAY,KAAK,EAAE;AAAA,EAC5D;AACA,SAAO;AACT;","names":[]}
\ No newline at end of file
diff --git a/dist/chunk-OHSQRYVL.js b/dist/chunk-OHSQRYVL.js
deleted file mode 100644
index d6cc116b002c5e8b355783e7a8a34eb4bb186ad6..0000000000000000000000000000000000000000
--- a/dist/chunk-OHSQRYVL.js
+++ /dev/null
@@ -1,74 +0,0 @@
-"use strict";Object.defineProperty(exports, "__esModule", {value: true});
-
-var _chunkLS6R3HQLjs = require('./chunk-LS6R3HQL.js');
-
-// src/token-service.ts
-var _controllerutils = require('@metamask/controller-utils');
-var TOKEN_END_POINT_API = "https://token-api.metaswap.codefi.network";
-var TOKEN_METADATA_NO_SUPPORT_ERROR = "TokenService Error: Network does not support fetchTokenMetadata";
-function getTokensURL(chainId) {
-  return `${TOKEN_END_POINT_API}/tokens/${_controllerutils.convertHexToDecimal.call(void 0, 
-    chainId
-  )}?occurrenceFloor=3&includeNativeAssets=false&includeDuplicateSymbolAssets=false&includeTokenFees=false&includeAssetType=false`;
-}
-function getTokenMetadataURL(chainId, tokenAddress) {
-  return `${TOKEN_END_POINT_API}/token/${_controllerutils.convertHexToDecimal.call(void 0, 
-    chainId
-  )}?address=${tokenAddress}`;
-}
-var tenSecondsInMilliseconds = 1e4;
-var defaultTimeout = tenSecondsInMilliseconds;
-async function fetchTokenListByChainId(chainId, abortSignal, { timeout = defaultTimeout } = {}) {
-  const tokenURL = getTokensURL(chainId);
-  const response = await queryApi(tokenURL, abortSignal, timeout);
-  if (response) {
-    return parseJsonResponse(response);
-  }
-  return void 0;
-}
-async function fetchTokenMetadata(chainId, tokenAddress, abortSignal, { timeout = defaultTimeout } = {}) {
-  if (!_chunkLS6R3HQLjs.isTokenListSupportedForNetwork.call(void 0, chainId)) {
-    throw new Error(TOKEN_METADATA_NO_SUPPORT_ERROR);
-  }
-  const tokenMetadataURL = getTokenMetadataURL(chainId, tokenAddress);
-  const response = await queryApi(tokenMetadataURL, abortSignal, timeout);
-  if (response) {
-    return parseJsonResponse(response);
-  }
-  return void 0;
-}
-async function queryApi(apiURL, abortSignal, timeout) {
-  const fetchOptions = {
-    referrer: apiURL,
-    referrerPolicy: "no-referrer-when-downgrade",
-    method: "GET",
-    mode: "cors",
-    signal: abortSignal,
-    cache: "default"
-  };
-  fetchOptions.headers = new window.Headers();
-  fetchOptions.headers.set("Content-Type", "application/json");
-  try {
-    return await _controllerutils.timeoutFetch.call(void 0, apiURL, fetchOptions, timeout);
-  } catch (error) {
-    if (error instanceof Error && error.name === "AbortError") {
-      console.log("Request is aborted");
-    }
-  }
-  return void 0;
-}
-async function parseJsonResponse(apiResponse) {
-  const responseObj = await apiResponse.json();
-  if (responseObj?.error) {
-    throw new Error(`TokenService Error: ${responseObj.error}`);
-  }
-  return responseObj;
-}
-
-
-
-
-
-
-exports.TOKEN_END_POINT_API = TOKEN_END_POINT_API; exports.TOKEN_METADATA_NO_SUPPORT_ERROR = TOKEN_METADATA_NO_SUPPORT_ERROR; exports.fetchTokenListByChainId = fetchTokenListByChainId; exports.fetchTokenMetadata = fetchTokenMetadata;
-//# sourceMappingURL=chunk-OHSQRYVL.js.map
\ No newline at end of file
diff --git a/dist/chunk-OHSQRYVL.js.map b/dist/chunk-OHSQRYVL.js.map
deleted file mode 100644
index 35e9d0797efc69db3614702573ac53519ffd227d..0000000000000000000000000000000000000000
--- a/dist/chunk-OHSQRYVL.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["../src/token-service.ts"],"names":[],"mappings":";;;;;AAAA,SAAS,qBAAqB,oBAAoB;AAK3C,IAAM,sBAAsB;AAC5B,IAAM,kCACX;AAQF,SAAS,aAAa,SAAc;AAClC,SAAO,GAAG,mBAAmB,WAAW;AAAA,IACtC;AAAA,EACF,CAAC;AACH;AASA,SAAS,oBAAoB,SAAc,cAAsB;AAC/D,SAAO,GAAG,mBAAmB,UAAU;AAAA,IACrC;AAAA,EACF,CAAC,YAAY,YAAY;AAC3B;AAEA,IAAM,2BAA2B;AAIjC,IAAM,iBAAiB;AAYvB,eAAsB,wBACpB,SACA,aACA,EAAE,UAAU,eAAe,IAAI,CAAC,GACd;AAClB,QAAM,WAAW,aAAa,OAAO;AACrC,QAAM,WAAW,MAAM,SAAS,UAAU,aAAa,OAAO;AAC9D,MAAI,UAAU;AACZ,WAAO,kBAAkB,QAAQ;AAAA,EACnC;AACA,SAAO;AACT;AAaA,eAAsB,mBACpB,SACA,cACA,aACA,EAAE,UAAU,eAAe,IAAI,CAAC,GACR;AACxB,MAAI,CAAC,+BAA+B,OAAO,GAAG;AAC5C,UAAM,IAAI,MAAM,+BAA+B;AAAA,EACjD;AACA,QAAM,mBAAmB,oBAAoB,SAAS,YAAY;AAClE,QAAM,WAAW,MAAM,SAAS,kBAAkB,aAAa,OAAO;AACtE,MAAI,UAAU;AACZ,WAAO,kBAAkB,QAAQ;AAAA,EACnC;AACA,SAAO;AACT;AAUA,eAAe,SACb,QACA,aACA,SAC+B;AAC/B,QAAM,eAA4B;AAAA,IAChC,UAAU;AAAA,IACV,gBAAgB;AAAA,IAChB,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,OAAO;AAAA,EACT;AACA,eAAa,UAAU,IAAI,OAAO,QAAQ;AAC1C,eAAa,QAAQ,IAAI,gBAAgB,kBAAkB;AAC3D,MAAI;AACF,WAAO,MAAM,aAAa,QAAQ,cAAc,OAAO;AAAA,EACzD,SAAS,OAAO;AACd,QAAI,iBAAiB,SAAS,MAAM,SAAS,cAAc;AACzD,cAAQ,IAAI,oBAAoB;AAAA,IAClC;AAAA,EACF;AACA,SAAO;AACT;AASA,eAAe,kBAAkB,aAAyC;AACxE,QAAM,cAAc,MAAM,YAAY,KAAK;AAE3C,MAAI,aAAa,OAAO;AACtB,UAAM,IAAI,MAAM,uBAAuB,YAAY,KAAK,EAAE;AAAA,EAC5D;AACA,SAAO;AACT","sourcesContent":["import { convertHexToDecimal, timeoutFetch } from '@metamask/controller-utils';\nimport type { Hex } from '@metamask/utils';\n\nimport { isTokenListSupportedForNetwork } from './assetsUtil';\n\nexport const TOKEN_END_POINT_API = 'https://token-api.metaswap.codefi.network';\nexport const TOKEN_METADATA_NO_SUPPORT_ERROR =\n  'TokenService Error: Network does not support fetchTokenMetadata';\n\n/**\n * Get the tokens URL for a specific network.\n *\n * @param chainId - The chain ID of the network the tokens requested are on.\n * @returns The tokens URL.\n */\nfunction getTokensURL(chainId: Hex) {\n  return `${TOKEN_END_POINT_API}/tokens/${convertHexToDecimal(\n    chainId,\n  )}?occurrenceFloor=3&includeNativeAssets=false&includeDuplicateSymbolAssets=false&includeTokenFees=false&includeAssetType=false`;\n}\n\n/**\n * Get the token metadata URL for the given network and token.\n *\n * @param chainId - The chain ID of the network the token is on.\n * @param tokenAddress - The token address.\n * @returns The token metadata URL.\n */\nfunction getTokenMetadataURL(chainId: Hex, tokenAddress: string) {\n  return `${TOKEN_END_POINT_API}/token/${convertHexToDecimal(\n    chainId,\n  )}?address=${tokenAddress}`;\n}\n\nconst tenSecondsInMilliseconds = 10_000;\n\n// Token list averages 1.6 MB in size\n// timeoutFetch by default has a 500ms timeout, which will almost always timeout given the response size.\nconst defaultTimeout = tenSecondsInMilliseconds;\n\n/**\n * Fetch the list of token metadata for a given network. This request is cancellable using the\n * abort signal passed in.\n *\n * @param chainId - The chain ID of the network the requested tokens are on.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param options - Additional fetch options.\n * @param options.timeout - The fetch timeout.\n * @returns The token list, or `undefined` if the request was cancelled.\n */\nexport async function fetchTokenListByChainId(\n  chainId: Hex,\n  abortSignal: AbortSignal,\n  { timeout = defaultTimeout } = {},\n): Promise<unknown> {\n  const tokenURL = getTokensURL(chainId);\n  const response = await queryApi(tokenURL, abortSignal, timeout);\n  if (response) {\n    return parseJsonResponse(response);\n  }\n  return undefined;\n}\n\n/**\n * Fetch metadata for the token address provided for a given network. This request is cancellable\n * using the abort signal passed in.\n *\n * @param chainId - The chain ID of the network the token is on.\n * @param tokenAddress - The address of the token to fetch metadata for.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param options - Additional fetch options.\n * @param options.timeout - The fetch timeout.\n * @returns The token metadata, or `undefined` if the request was either aborted or failed.\n */\nexport async function fetchTokenMetadata<T>(\n  chainId: Hex,\n  tokenAddress: string,\n  abortSignal: AbortSignal,\n  { timeout = defaultTimeout } = {},\n): Promise<T | undefined> {\n  if (!isTokenListSupportedForNetwork(chainId)) {\n    throw new Error(TOKEN_METADATA_NO_SUPPORT_ERROR);\n  }\n  const tokenMetadataURL = getTokenMetadataURL(chainId, tokenAddress);\n  const response = await queryApi(tokenMetadataURL, abortSignal, timeout);\n  if (response) {\n    return parseJsonResponse(response) as Promise<T>;\n  }\n  return undefined;\n}\n\n/**\n * Perform fetch request against the api.\n *\n * @param apiURL - The URL of the API to fetch.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param timeout - The fetch timeout.\n * @returns Promise resolving request response.\n */\nasync function queryApi(\n  apiURL: string,\n  abortSignal: AbortSignal,\n  timeout: number,\n): Promise<Response | undefined> {\n  const fetchOptions: RequestInit = {\n    referrer: apiURL,\n    referrerPolicy: 'no-referrer-when-downgrade',\n    method: 'GET',\n    mode: 'cors',\n    signal: abortSignal,\n    cache: 'default',\n  };\n  fetchOptions.headers = new window.Headers();\n  fetchOptions.headers.set('Content-Type', 'application/json');\n  try {\n    return await timeoutFetch(apiURL, fetchOptions, timeout);\n  } catch (error) {\n    if (error instanceof Error && error.name === 'AbortError') {\n      console.log('Request is aborted');\n    }\n  }\n  return undefined;\n}\n\n/**\n * Parse an API response and return the response JSON data.\n *\n * @param apiResponse - The API response to parse.\n * @returns The response JSON data.\n * @throws Will throw if the response includes an error.\n */\nasync function parseJsonResponse(apiResponse: Response): Promise<unknown> {\n  const responseObj = await apiResponse.json();\n  // api may return errors as json without setting an error http status code\n  if (responseObj?.error) {\n    throw new Error(`TokenService Error: ${responseObj.error}`);\n  }\n  return responseObj;\n}\n"]}
\ No newline at end of file
diff --git a/dist/chunk-OKEA7NPV.js b/dist/chunk-OKEA7NPV.js
new file mode 100644
index 0000000000000000000000000000000000000000..67d072ed905674de6788b9e7e6a81eee91563908
--- /dev/null
+++ b/dist/chunk-OKEA7NPV.js
@@ -0,0 +1,85 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunkLS6R3HQLjs = require('./chunk-LS6R3HQL.js');
+
+// src/token-service.ts
+
+
+
+
+var _controllerutils = require('@metamask/controller-utils');
+var TOKEN_END_POINT_API = "https://token-api.metaswap.codefi.network";
+var TOKEN_METADATA_NO_SUPPORT_ERROR = "TokenService Error: Network does not support fetchTokenMetadata";
+function getTokensURL(chainId) {
+  const occurrenceFloor = chainId === _controllerutils.ChainId["linea-mainnet"] ? 1 : 3;
+  return `${TOKEN_END_POINT_API}/tokens/${_controllerutils.convertHexToDecimal.call(void 0, 
+    chainId
+  )}?occurrenceFloor=${occurrenceFloor}&includeNativeAssets=false&includeDuplicateSymbolAssets=false&includeTokenFees=false&includeAssetType=false`;
+}
+function getTokenMetadataURL(chainId, tokenAddress) {
+  return `${TOKEN_END_POINT_API}/token/${_controllerutils.convertHexToDecimal.call(void 0, 
+    chainId
+  )}?address=${tokenAddress}`;
+}
+var tenSecondsInMilliseconds = 1e4;
+var defaultTimeout = tenSecondsInMilliseconds;
+async function fetchTokenListByChainId(chainId, abortSignal, { timeout = defaultTimeout } = {}) {
+  const tokenURL = getTokensURL(chainId);
+  const response = await queryApi(tokenURL, abortSignal, timeout);
+  if (response) {
+    const result = await parseJsonResponse(response);
+    if (Array.isArray(result) && chainId === _controllerutils.ChainId["linea-mainnet"]) {
+      return result.filter(
+        (elm) => elm.aggregators.includes("lineaTeam") || elm.aggregators.length >= 3
+      );
+    }
+    return result;
+  }
+  return void 0;
+}
+async function fetchTokenMetadata(chainId, tokenAddress, abortSignal, { timeout = defaultTimeout } = {}) {
+  if (!_chunkLS6R3HQLjs.isTokenListSupportedForNetwork.call(void 0, chainId)) {
+    throw new Error(TOKEN_METADATA_NO_SUPPORT_ERROR);
+  }
+  const tokenMetadataURL = getTokenMetadataURL(chainId, tokenAddress);
+  const response = await queryApi(tokenMetadataURL, abortSignal, timeout);
+  if (response) {
+    return parseJsonResponse(response);
+  }
+  return void 0;
+}
+async function queryApi(apiURL, abortSignal, timeout) {
+  const fetchOptions = {
+    referrer: apiURL,
+    referrerPolicy: "no-referrer-when-downgrade",
+    method: "GET",
+    mode: "cors",
+    signal: abortSignal,
+    cache: "default"
+  };
+  fetchOptions.headers = new window.Headers();
+  fetchOptions.headers.set("Content-Type", "application/json");
+  try {
+    return await _controllerutils.timeoutFetch.call(void 0, apiURL, fetchOptions, timeout);
+  } catch (error) {
+    if (error instanceof Error && error.name === "AbortError") {
+      console.log("Request is aborted");
+    }
+  }
+  return void 0;
+}
+async function parseJsonResponse(apiResponse) {
+  const responseObj = await apiResponse.json();
+  if (responseObj?.error) {
+    throw new Error(`TokenService Error: ${responseObj.error}`);
+  }
+  return responseObj;
+}
+
+
+
+
+
+
+exports.TOKEN_END_POINT_API = TOKEN_END_POINT_API; exports.TOKEN_METADATA_NO_SUPPORT_ERROR = TOKEN_METADATA_NO_SUPPORT_ERROR; exports.fetchTokenListByChainId = fetchTokenListByChainId; exports.fetchTokenMetadata = fetchTokenMetadata;
+//# sourceMappingURL=chunk-OKEA7NPV.js.map
\ No newline at end of file
diff --git a/dist/chunk-OKEA7NPV.js.map b/dist/chunk-OKEA7NPV.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..e5589ae08612278ce489f9703ba34444aa5a96fa
--- /dev/null
+++ b/dist/chunk-OKEA7NPV.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/token-service.ts"],"names":[],"mappings":";;;;;AAAA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAKA,IAAM,sBAAsB;AAC5B,IAAM,kCACX;AAQF,SAAS,aAAa,SAAc;AAClC,QAAM,kBAAkB,YAAY,QAAQ,eAAe,IAAI,IAAI;AACnE,SAAO,GAAG,mBAAmB,WAAW;AAAA,IACtC;AAAA,EACF,CAAC,oBAAoB,eAAe;AACtC;AASA,SAAS,oBAAoB,SAAc,cAAsB;AAC/D,SAAO,GAAG,mBAAmB,UAAU;AAAA,IACrC;AAAA,EACF,CAAC,YAAY,YAAY;AAC3B;AAEA,IAAM,2BAA2B;AAIjC,IAAM,iBAAiB;AAYvB,eAAsB,wBACpB,SACA,aACA,EAAE,UAAU,eAAe,IAAI,CAAC,GACd;AAClB,QAAM,WAAW,aAAa,OAAO;AACrC,QAAM,WAAW,MAAM,SAAS,UAAU,aAAa,OAAO;AAC9D,MAAI,UAAU;AACZ,UAAM,SAAS,MAAM,kBAAkB,QAAQ;AAC/C,QAAI,MAAM,QAAQ,MAAM,KAAK,YAAY,QAAQ,eAAe,GAAG;AACjE,aAAO,OAAO;AAAA,QACZ,CAAC,QACC,IAAI,YAAY,SAAS,WAAW,KAAK,IAAI,YAAY,UAAU;AAAA,MACvE;AAAA,IACF;AACA,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAaA,eAAsB,mBACpB,SACA,cACA,aACA,EAAE,UAAU,eAAe,IAAI,CAAC,GACR;AACxB,MAAI,CAAC,+BAA+B,OAAO,GAAG;AAC5C,UAAM,IAAI,MAAM,+BAA+B;AAAA,EACjD;AACA,QAAM,mBAAmB,oBAAoB,SAAS,YAAY;AAClE,QAAM,WAAW,MAAM,SAAS,kBAAkB,aAAa,OAAO;AACtE,MAAI,UAAU;AACZ,WAAO,kBAAkB,QAAQ;AAAA,EACnC;AACA,SAAO;AACT;AAUA,eAAe,SACb,QACA,aACA,SAC+B;AAC/B,QAAM,eAA4B;AAAA,IAChC,UAAU;AAAA,IACV,gBAAgB;AAAA,IAChB,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,OAAO;AAAA,EACT;AACA,eAAa,UAAU,IAAI,OAAO,QAAQ;AAC1C,eAAa,QAAQ,IAAI,gBAAgB,kBAAkB;AAC3D,MAAI;AACF,WAAO,MAAM,aAAa,QAAQ,cAAc,OAAO;AAAA,EACzD,SAAS,OAAO;AACd,QAAI,iBAAiB,SAAS,MAAM,SAAS,cAAc;AACzD,cAAQ,IAAI,oBAAoB;AAAA,IAClC;AAAA,EACF;AACA,SAAO;AACT;AASA,eAAe,kBAAkB,aAAyC;AACxE,QAAM,cAAc,MAAM,YAAY,KAAK;AAE3C,MAAI,aAAa,OAAO;AACtB,UAAM,IAAI,MAAM,uBAAuB,YAAY,KAAK,EAAE;AAAA,EAC5D;AACA,SAAO;AACT","sourcesContent":["import {\n  ChainId,\n  convertHexToDecimal,\n  timeoutFetch,\n} from '@metamask/controller-utils';\nimport type { Hex } from '@metamask/utils';\n\nimport { isTokenListSupportedForNetwork } from './assetsUtil';\n\nexport const TOKEN_END_POINT_API = 'https://token-api.metaswap.codefi.network';\nexport const TOKEN_METADATA_NO_SUPPORT_ERROR =\n  'TokenService Error: Network does not support fetchTokenMetadata';\n\n/**\n * Get the tokens URL for a specific network.\n *\n * @param chainId - The chain ID of the network the tokens requested are on.\n * @returns The tokens URL.\n */\nfunction getTokensURL(chainId: Hex) {\n  const occurrenceFloor = chainId === ChainId['linea-mainnet'] ? 1 : 3;\n  return `${TOKEN_END_POINT_API}/tokens/${convertHexToDecimal(\n    chainId,\n  )}?occurrenceFloor=${occurrenceFloor}&includeNativeAssets=false&includeDuplicateSymbolAssets=false&includeTokenFees=false&includeAssetType=false`;\n}\n\n/**\n * Get the token metadata URL for the given network and token.\n *\n * @param chainId - The chain ID of the network the token is on.\n * @param tokenAddress - The token address.\n * @returns The token metadata URL.\n */\nfunction getTokenMetadataURL(chainId: Hex, tokenAddress: string) {\n  return `${TOKEN_END_POINT_API}/token/${convertHexToDecimal(\n    chainId,\n  )}?address=${tokenAddress}`;\n}\n\nconst tenSecondsInMilliseconds = 10_000;\n\n// Token list averages 1.6 MB in size\n// timeoutFetch by default has a 500ms timeout, which will almost always timeout given the response size.\nconst defaultTimeout = tenSecondsInMilliseconds;\n\n/**\n * Fetch the list of token metadata for a given network. This request is cancellable using the\n * abort signal passed in.\n *\n * @param chainId - The chain ID of the network the requested tokens are on.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param options - Additional fetch options.\n * @param options.timeout - The fetch timeout.\n * @returns The token list, or `undefined` if the request was cancelled.\n */\nexport async function fetchTokenListByChainId(\n  chainId: Hex,\n  abortSignal: AbortSignal,\n  { timeout = defaultTimeout } = {},\n): Promise<unknown> {\n  const tokenURL = getTokensURL(chainId);\n  const response = await queryApi(tokenURL, abortSignal, timeout);\n  if (response) {\n    const result = await parseJsonResponse(response);\n    if (Array.isArray(result) && chainId === ChainId['linea-mainnet']) {\n      return result.filter(\n        (elm) =>\n          elm.aggregators.includes('lineaTeam') || elm.aggregators.length >= 3,\n      );\n    }\n    return result;\n  }\n  return undefined;\n}\n\n/**\n * Fetch metadata for the token address provided for a given network. This request is cancellable\n * using the abort signal passed in.\n *\n * @param chainId - The chain ID of the network the token is on.\n * @param tokenAddress - The address of the token to fetch metadata for.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param options - Additional fetch options.\n * @param options.timeout - The fetch timeout.\n * @returns The token metadata, or `undefined` if the request was either aborted or failed.\n */\nexport async function fetchTokenMetadata<T>(\n  chainId: Hex,\n  tokenAddress: string,\n  abortSignal: AbortSignal,\n  { timeout = defaultTimeout } = {},\n): Promise<T | undefined> {\n  if (!isTokenListSupportedForNetwork(chainId)) {\n    throw new Error(TOKEN_METADATA_NO_SUPPORT_ERROR);\n  }\n  const tokenMetadataURL = getTokenMetadataURL(chainId, tokenAddress);\n  const response = await queryApi(tokenMetadataURL, abortSignal, timeout);\n  if (response) {\n    return parseJsonResponse(response) as Promise<T>;\n  }\n  return undefined;\n}\n\n/**\n * Perform fetch request against the api.\n *\n * @param apiURL - The URL of the API to fetch.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param timeout - The fetch timeout.\n * @returns Promise resolving request response.\n */\nasync function queryApi(\n  apiURL: string,\n  abortSignal: AbortSignal,\n  timeout: number,\n): Promise<Response | undefined> {\n  const fetchOptions: RequestInit = {\n    referrer: apiURL,\n    referrerPolicy: 'no-referrer-when-downgrade',\n    method: 'GET',\n    mode: 'cors',\n    signal: abortSignal,\n    cache: 'default',\n  };\n  fetchOptions.headers = new window.Headers();\n  fetchOptions.headers.set('Content-Type', 'application/json');\n  try {\n    return await timeoutFetch(apiURL, fetchOptions, timeout);\n  } catch (error) {\n    if (error instanceof Error && error.name === 'AbortError') {\n      console.log('Request is aborted');\n    }\n  }\n  return undefined;\n}\n\n/**\n * Parse an API response and return the response JSON data.\n *\n * @param apiResponse - The API response to parse.\n * @returns The response JSON data.\n * @throws Will throw if the response includes an error.\n */\nasync function parseJsonResponse(apiResponse: Response): Promise<unknown> {\n  const responseObj = await apiResponse.json();\n  // api may return errors as json without setting an error http status code\n  if (responseObj?.error) {\n    throw new Error(`TokenService Error: ${responseObj.error}`);\n  }\n  return responseObj;\n}\n"]}
\ No newline at end of file
diff --git a/dist/chunk-ONJIVH6M.mjs b/dist/chunk-ONJIVH6M.mjs
new file mode 100644
index 0000000000000000000000000000000000000000..f4b34b1eb4934d6ab5727f6ddce82ef88b0704df
--- /dev/null
+++ b/dist/chunk-ONJIVH6M.mjs
@@ -0,0 +1,1202 @@
+import {
+  compareNftMetadata,
+  getFormattedIpfsUrl
+} from "./chunk-X5PLVMOQ.mjs";
+
+// src/NftController.ts
+import { isAddress } from "@ethersproject/address";
+import { BaseControllerV1 } from "@metamask/base-controller";
+import {
+  safelyExecute,
+  handleFetch,
+  toChecksumHexAddress,
+  BNToHex,
+  fetchWithErrorHandling,
+  IPFS_DEFAULT_GATEWAY_URL,
+  ERC721,
+  ERC1155,
+  ApprovalType,
+  NFT_API_BASE_URL
+} from "@metamask/controller-utils";
+import { rpcErrors } from "@metamask/rpc-errors";
+import { remove0x } from "@metamask/utils";
+import { Mutex } from "async-mutex";
+import BN from "bn.js";
+import { EventEmitter } from "events";
+import { v4 as random } from "uuid";
+var ALL_NFTS_STATE_KEY = "allNfts";
+var ALL_NFTS_CONTRACTS_STATE_KEY = "allNftContracts";
+var getDefaultNftState = () => {
+  return {
+    allNftContracts: {},
+    allNfts: {},
+    ignoredNfts: []
+  };
+};
+var NftController = class extends BaseControllerV1 {
+  /**
+   * Creates an NftController instance.
+   *
+   * @param options - The controller options.
+   * @param options.chainId - The chain ID of the current network.
+   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
+   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
+   * @param options.getERC721AssetName - Gets the name of the asset at the given address.
+   * @param options.getERC721AssetSymbol - Gets the symbol of the asset at the given address.
+   * @param options.getERC721TokenURI - Gets the URI of the ERC721 token at the given address, with the given ID.
+   * @param options.getERC721OwnerOf - Get the owner of a ERC-721 NFT.
+   * @param options.getERC1155BalanceOf - Gets balance of a ERC-1155 NFT.
+   * @param options.getERC1155TokenURI - Gets the URI of the ERC1155 token at the given address, with the given ID.
+   * @param options.getNetworkClientById - Gets the network client for the given networkClientId.
+   * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data
+   * for tracking the NFT added event.
+   * @param options.messenger - The controller messenger.
+   * @param config - Initial options used to configure this controller.
+   * @param state - Initial state to set on this controller.
+   */
+  constructor({
+    chainId: initialChainId,
+    onPreferencesStateChange,
+    onNetworkStateChange,
+    getERC721AssetName,
+    getERC721AssetSymbol,
+    getERC721TokenURI,
+    getERC721OwnerOf,
+    getERC1155BalanceOf,
+    getERC1155TokenURI,
+    getNetworkClientById,
+    onNftAdded,
+    messenger
+  }, config, state) {
+    super(config, state);
+    this.mutex = new Mutex();
+    /**
+     * EventEmitter instance used to listen to specific EIP747 events
+     */
+    this.hub = new EventEmitter();
+    /**
+     * Name of this controller used during composition
+     */
+    this.name = "NftController";
+    this.defaultConfig = {
+      selectedAddress: "",
+      chainId: initialChainId,
+      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,
+      openSeaEnabled: false,
+      useIPFSSubdomains: true,
+      isIpfsGatewayEnabled: true
+    };
+    this.defaultState = getDefaultNftState();
+    this.initialize();
+    this.getERC721AssetName = getERC721AssetName;
+    this.getERC721AssetSymbol = getERC721AssetSymbol;
+    this.getERC721TokenURI = getERC721TokenURI;
+    this.getERC721OwnerOf = getERC721OwnerOf;
+    this.getERC1155BalanceOf = getERC1155BalanceOf;
+    this.getERC1155TokenURI = getERC1155TokenURI;
+    this.getNetworkClientById = getNetworkClientById;
+    this.onNftAdded = onNftAdded;
+    this.messagingSystem = messenger;
+    onPreferencesStateChange(
+      async ({
+        selectedAddress,
+        ipfsGateway,
+        openSeaEnabled,
+        isIpfsGatewayEnabled
+      }) => {
+        this.configure({
+          selectedAddress,
+          ipfsGateway,
+          openSeaEnabled,
+          isIpfsGatewayEnabled
+        });
+        const needsUpdateNftMetadata = isIpfsGatewayEnabled && ipfsGateway !== "" || openSeaEnabled;
+        if (needsUpdateNftMetadata) {
+          const { chainId } = this.config;
+          const nfts = this.state.allNfts[selectedAddress]?.[chainId] ?? [];
+          const nftsToUpdate = nfts.filter(
+            (singleNft) => !singleNft.name && !singleNft.description && !singleNft.image
+          );
+          if (nftsToUpdate.length !== 0) {
+            await this.updateNftMetadata({
+              nfts: nftsToUpdate,
+              userAddress: selectedAddress
+            });
+          }
+        }
+      }
+    );
+    onNetworkStateChange(({ providerConfig }) => {
+      const { chainId } = providerConfig;
+      this.configure({ chainId });
+    });
+  }
+  getNftApi() {
+    return `${NFT_API_BASE_URL}/tokens`;
+  }
+  /**
+   * Helper method to update nested state for allNfts and allNftContracts.
+   *
+   * @param newCollection - the modified piece of state to update in the controller's store
+   * @param baseStateKey - The root key in the store to update.
+   * @param passedConfig - An object containing the selectedAddress and chainId that are passed through the auto-detection flow.
+   * @param passedConfig.userAddress - the address passed through the NFT detection flow to ensure assets are stored to the correct account
+   * @param passedConfig.chainId - the chainId passed through the NFT detection flow to ensure assets are stored to the correct account
+   */
+  updateNestedNftState(newCollection, baseStateKey, { userAddress, chainId }) {
+    const { [baseStateKey]: oldState } = this.state;
+    const addressState = oldState[userAddress];
+    const newAddressState = {
+      ...addressState,
+      ...{ [chainId]: newCollection }
+    };
+    const newState = {
+      ...oldState,
+      ...{ [userAddress]: newAddressState }
+    };
+    this.update({
+      [baseStateKey]: newState
+    });
+  }
+  /**
+   * Request individual NFT information from NFT API.
+   *
+   * @param contractAddress - Hex address of the NFT contract.
+   * @param tokenId - The NFT identifier.
+   * @returns Promise resolving to the current NFT name and image.
+   */
+  async getNftInformationFromApi(contractAddress, tokenId) {
+    const urlParams = new URLSearchParams({
+      chainIds: "1",
+      tokens: `${contractAddress}:${tokenId}`,
+      includeTopBid: "true",
+      includeAttributes: "true",
+      includeLastSale: "true"
+    }).toString();
+    const nftInformation = await fetchWithErrorHandling({
+      url: `${this.getNftApi()}?${urlParams}`,
+      options: {
+        headers: {
+          Version: "1"
+        }
+      }
+    });
+    if (!nftInformation?.tokens?.[0]?.token) {
+      return {
+        name: null,
+        description: null,
+        image: null,
+        standard: null
+      };
+    }
+    const {
+      image,
+      metadata: { imageOriginal } = {},
+      name,
+      description,
+      collection,
+      kind,
+      rarityRank,
+      rarity,
+      attributes,
+      lastSale,
+      imageSmall
+    } = nftInformation.tokens[0].token;
+    const nftMetadata = Object.assign(
+      {},
+      { name: name || null },
+      { description: description || null },
+      { image: image || null },
+      collection?.creator && { creator: collection.creator },
+      imageOriginal && { imageOriginal },
+      imageSmall && { imageThumbnail: imageSmall },
+      kind && { standard: kind.toUpperCase() },
+      lastSale && { lastSale },
+      attributes && { attributes },
+      nftInformation.tokens[0].market?.topBid && {
+        topBid: nftInformation.tokens[0].market?.topBid
+      },
+      rarityRank && { rarityRank },
+      rarity && { rarity },
+      collection && { collection }
+    );
+    return nftMetadata;
+  }
+  /**
+   * Request individual NFT information from contracts that follows Metadata Interface.
+   *
+   * @param contractAddress - Hex address of the NFT contract.
+   * @param tokenId - The NFT identifier.
+   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving to the current NFT name and image.
+   */
+  async getNftInformationFromTokenURI(contractAddress, tokenId, networkClientId) {
+    const { ipfsGateway, useIPFSSubdomains, isIpfsGatewayEnabled } = this.config;
+    const result = await this.getNftURIAndStandard(
+      contractAddress,
+      tokenId,
+      networkClientId
+    );
+    let tokenURI = result[0];
+    const standard = result[1];
+    const hasIpfsTokenURI = tokenURI.startsWith("ipfs://");
+    if (hasIpfsTokenURI && !isIpfsGatewayEnabled) {
+      return {
+        image: null,
+        name: null,
+        description: null,
+        standard: standard || null,
+        favorite: false,
+        tokenURI: tokenURI ?? null
+      };
+    }
+    const isDisplayNFTMediaToggleEnabled = this.config.openSeaEnabled;
+    if (!hasIpfsTokenURI && !isDisplayNFTMediaToggleEnabled) {
+      return {
+        image: null,
+        name: null,
+        description: null,
+        standard: standard || null,
+        favorite: false,
+        tokenURI: tokenURI ?? null
+      };
+    }
+    if (hasIpfsTokenURI) {
+      tokenURI = getFormattedIpfsUrl(ipfsGateway, tokenURI, useIPFSSubdomains);
+    }
+    try {
+      const object = await handleFetch(tokenURI);
+      const image = Object.prototype.hasOwnProperty.call(object, "image") ? "image" : (
+        /* istanbul ignore next */
+        "image_url"
+      );
+      return {
+        image: object[image],
+        name: object.name,
+        description: object.description,
+        standard,
+        favorite: false,
+        tokenURI: tokenURI ?? null
+      };
+    } catch {
+      return {
+        image: null,
+        name: null,
+        description: null,
+        standard: standard || null,
+        favorite: false,
+        tokenURI: tokenURI ?? null
+      };
+    }
+  }
+  /**
+   * Retrieve NFT uri with  metadata. TODO Update method to use IPFS.
+   *
+   * @param contractAddress - NFT contract address.
+   * @param tokenId - NFT token id.
+   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving NFT uri and token standard.
+   */
+  async getNftURIAndStandard(contractAddress, tokenId, networkClientId) {
+    try {
+      const uri = await this.getERC721TokenURI(
+        contractAddress,
+        tokenId,
+        networkClientId
+      );
+      return [uri, ERC721];
+    } catch {
+    }
+    try {
+      const tokenURI = await this.getERC1155TokenURI(
+        contractAddress,
+        tokenId,
+        networkClientId
+      );
+      if (!tokenURI.includes("{id}")) {
+        return [tokenURI, ERC1155];
+      }
+      const hexTokenId = remove0x(BNToHex(new BN(tokenId))).padStart(64, "0").toLowerCase();
+      return [tokenURI.replace("{id}", hexTokenId), ERC1155];
+    } catch {
+    }
+    return ["", ""];
+  }
+  /**
+   * Request individual NFT information (name, image url and description).
+   *
+   * @param contractAddress - Hex address of the NFT contract.
+   * @param tokenId - The NFT identifier.
+   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving to the current NFT name and image.
+   */
+  async getNftInformation(contractAddress, tokenId, networkClientId) {
+    const chainId = this.getCorrectChainId({
+      networkClientId
+    });
+    const [blockchainMetadata, nftApiMetadata] = await Promise.all([
+      safelyExecute(
+        () => this.getNftInformationFromTokenURI(
+          contractAddress,
+          tokenId,
+          networkClientId
+        )
+      ),
+      this.config.openSeaEnabled && chainId === "0x1" ? safelyExecute(
+        () => this.getNftInformationFromApi(contractAddress, tokenId)
+      ) : void 0
+    ]);
+    return {
+      ...nftApiMetadata,
+      name: blockchainMetadata?.name ?? nftApiMetadata?.name ?? null,
+      description: blockchainMetadata?.description ?? nftApiMetadata?.description ?? null,
+      image: blockchainMetadata?.image ?? nftApiMetadata?.image ?? null,
+      standard: blockchainMetadata?.standard ?? nftApiMetadata?.standard ?? null,
+      tokenURI: blockchainMetadata?.tokenURI ?? null
+    };
+  }
+  /**
+   * Request NFT contract information from the contract itself.
+   *
+   * @param contractAddress - Hex address of the NFT contract.
+   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving to the current NFT name and image.
+   */
+  async getNftContractInformationFromContract(contractAddress, networkClientId) {
+    const [name, symbol] = await Promise.all([
+      this.getERC721AssetName(contractAddress, networkClientId),
+      this.getERC721AssetSymbol(contractAddress, networkClientId)
+    ]);
+    return {
+      collection: { name },
+      symbol,
+      address: contractAddress
+    };
+  }
+  /**
+   * Request NFT contract information from Blockchain and aggregate with received data from NFTMetadata.
+   *
+   * @param contractAddress - Hex address of the NFT contract.
+   * @param nftMetadataFromApi - Received NFT information to be aggregated with blockchain contract information.
+   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving to the NFT contract name, image and description.
+   */
+  async getNftContractInformation(contractAddress, nftMetadataFromApi, networkClientId) {
+    const blockchainContractData = await safelyExecute(
+      () => this.getNftContractInformationFromContract(
+        contractAddress,
+        networkClientId
+      )
+    );
+    if (blockchainContractData || !Object.values(nftMetadataFromApi).every((value) => value === null)) {
+      return {
+        address: contractAddress,
+        ...blockchainContractData,
+        schema_name: nftMetadataFromApi?.standard ?? null,
+        collection: {
+          name: null,
+          image_url: nftMetadataFromApi?.collection?.image ?? nftMetadataFromApi?.collection?.imageUrl ?? null,
+          tokenCount: nftMetadataFromApi?.collection?.tokenCount ?? null,
+          ...nftMetadataFromApi?.collection,
+          ...blockchainContractData?.collection
+        }
+      };
+    }
+    return {
+      address: contractAddress,
+      asset_contract_type: null,
+      created_date: null,
+      schema_name: null,
+      symbol: null,
+      total_supply: null,
+      description: null,
+      external_link: null,
+      collection: { name: null, image_url: null }
+    };
+  }
+  /**
+   * Adds an individual NFT to the stored NFT list.
+   *
+   * @param tokenAddress - Hex address of the NFT contract.
+   * @param tokenId - The NFT identifier.
+   * @param nftMetadata - NFT optional information (name, image and description).
+   * @param nftContract - An object containing contract data of the NFT being added.
+   * @param chainId - The chainId of the network where the NFT is being added.
+   * @param userAddress - The address of the account where the NFT is being added.
+   * @param source - Whether the NFT was detected, added manually or suggested by a dapp.
+   * @returns Promise resolving to the current NFT list.
+   */
+  async addIndividualNft(tokenAddress, tokenId, nftMetadata, nftContract, chainId, userAddress, source) {
+    const releaseLock = await this.mutex.acquire();
+    try {
+      tokenAddress = toChecksumHexAddress(tokenAddress);
+      const { allNfts } = this.state;
+      const nfts = allNfts[userAddress]?.[chainId] || [];
+      const existingEntry = nfts.find(
+        (nft) => nft.address.toLowerCase() === tokenAddress.toLowerCase() && nft.tokenId === tokenId
+      );
+      if (existingEntry) {
+        const differentMetadata = compareNftMetadata(
+          nftMetadata,
+          existingEntry
+        );
+        if (differentMetadata || !existingEntry.isCurrentlyOwned) {
+          const indexToRemove = nfts.findIndex(
+            (nft) => nft.address.toLowerCase() === tokenAddress.toLowerCase() && nft.tokenId === tokenId
+          );
+          if (indexToRemove !== -1) {
+            nfts.splice(indexToRemove, 1);
+          }
+        } else {
+          return nfts;
+        }
+      }
+      const newEntry = {
+        address: tokenAddress,
+        tokenId,
+        favorite: existingEntry?.favorite || false,
+        isCurrentlyOwned: true,
+        ...nftMetadata
+      };
+      const newNfts = [...nfts, newEntry];
+      this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+        chainId,
+        userAddress
+      });
+      if (this.onNftAdded) {
+        this.onNftAdded({
+          address: tokenAddress,
+          symbol: nftContract.symbol,
+          tokenId: tokenId.toString(),
+          standard: nftMetadata.standard,
+          source
+        });
+      }
+      return newNfts;
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Adds an NFT contract to the stored NFT contracts list.
+   *
+   * @param options - options.
+   * @param options.tokenAddress - Hex address of the NFT contract.
+   * @param options.userAddress - The address of the account where the NFT is being added.
+   * @param options.nftMetadata - The retrieved NFTMetadata from API.
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
+   * @returns Promise resolving to the current NFT contracts list.
+   */
+  async addNftContract({
+    tokenAddress,
+    userAddress,
+    networkClientId,
+    source,
+    nftMetadata
+  }) {
+    const releaseLock = await this.mutex.acquire();
+    try {
+      tokenAddress = toChecksumHexAddress(tokenAddress);
+      const { allNftContracts } = this.state;
+      const chainId = this.getCorrectChainId({
+        networkClientId
+      });
+      const nftContracts = allNftContracts[userAddress]?.[chainId] || [];
+      const existingEntry = nftContracts.find(
+        (nftContract) => nftContract.address.toLowerCase() === tokenAddress.toLowerCase()
+      );
+      if (existingEntry) {
+        return nftContracts;
+      }
+      const contractInformation = await this.getNftContractInformation(
+        tokenAddress,
+        nftMetadata,
+        networkClientId
+      );
+      const {
+        asset_contract_type,
+        created_date,
+        symbol,
+        description,
+        external_link,
+        schema_name,
+        collection: { name, image_url, tokenCount }
+      } = contractInformation;
+      if (source === "detected" /* Detected */ && "address" in contractInformation && typeof contractInformation.address === "string" && "collection" in contractInformation && contractInformation.collection.name === null && "image_url" in contractInformation.collection && contractInformation.collection.image_url === null && Object.entries(contractInformation).every(([key, value]) => {
+        return key === "address" || key === "collection" || !value;
+      })) {
+        return nftContracts;
+      }
+      const newEntry = Object.assign(
+        {},
+        { address: tokenAddress },
+        description && { description },
+        name && { name },
+        image_url && { logo: image_url },
+        symbol && { symbol },
+        tokenCount !== null && typeof tokenCount !== "undefined" && { totalSupply: tokenCount },
+        asset_contract_type && { assetContractType: asset_contract_type },
+        created_date && { createdDate: created_date },
+        schema_name && { schemaName: schema_name },
+        external_link && { externalLink: external_link }
+      );
+      const newNftContracts = [...nftContracts, newEntry];
+      this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {
+        chainId,
+        userAddress
+      });
+      return newNftContracts;
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Removes an individual NFT from the stored token list and saves it in ignored NFTs list.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - Token identifier of the NFT.
+   * @param options - options.
+   * @param options.chainId - The chainId of the network where the NFT is being removed.
+   * @param options.userAddress - The address of the account where the NFT is being removed.
+   */
+  removeAndIgnoreIndividualNft(address, tokenId, {
+    chainId,
+    userAddress
+  }) {
+    address = toChecksumHexAddress(address);
+    const { allNfts, ignoredNfts } = this.state;
+    const newIgnoredNfts = [...ignoredNfts];
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const newNfts = nfts.filter((nft) => {
+      if (nft.address.toLowerCase() === address.toLowerCase() && nft.tokenId === tokenId) {
+        const alreadyIgnored = newIgnoredNfts.find(
+          (c) => c.address === address && c.tokenId === tokenId
+        );
+        !alreadyIgnored && newIgnoredNfts.push(nft);
+        return false;
+      }
+      return true;
+    });
+    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+      userAddress,
+      chainId
+    });
+    this.update({
+      ignoredNfts: newIgnoredNfts
+    });
+  }
+  /**
+   * Removes an individual NFT from the stored token list.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - Token identifier of the NFT.
+   * @param options - options.
+   * @param options.chainId - The chainId of the network where the NFT is being removed.
+   * @param options.userAddress - The address of the account where the NFT is being removed.
+   */
+  removeIndividualNft(address, tokenId, { chainId, userAddress }) {
+    address = toChecksumHexAddress(address);
+    const { allNfts } = this.state;
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const newNfts = nfts.filter(
+      (nft) => !(nft.address.toLowerCase() === address.toLowerCase() && nft.tokenId === tokenId)
+    );
+    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+      userAddress,
+      chainId
+    });
+  }
+  /**
+   * Removes an NFT contract to the stored NFT contracts list.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param options - options.
+   * @param options.chainId - The chainId of the network where the NFT is being removed.
+   * @param options.userAddress - The address of the account where the NFT is being removed.
+   * @returns Promise resolving to the current NFT contracts list.
+   */
+  removeNftContract(address, { chainId, userAddress }) {
+    address = toChecksumHexAddress(address);
+    const { allNftContracts } = this.state;
+    const nftContracts = allNftContracts[userAddress]?.[chainId] || [];
+    const newNftContracts = nftContracts.filter(
+      (nftContract) => !(nftContract.address.toLowerCase() === address.toLowerCase())
+    );
+    this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {
+      chainId,
+      userAddress
+    });
+    return newNftContracts;
+  }
+  async validateWatchNft(asset, type, userAddress, { networkClientId } = {}) {
+    const { address: contractAddress, tokenId } = asset;
+    if (!type) {
+      throw rpcErrors.invalidParams("Asset type is required");
+    }
+    if (type !== ERC721 && type !== ERC1155) {
+      throw rpcErrors.invalidParams(
+        `Non NFT asset type ${type} not supported by watchNft`
+      );
+    }
+    if (!contractAddress || !tokenId) {
+      throw rpcErrors.invalidParams("Both address and tokenId are required");
+    }
+    if (!isAddress(contractAddress)) {
+      throw rpcErrors.invalidParams("Invalid address");
+    }
+    if (!/^\d+$/u.test(tokenId)) {
+      throw rpcErrors.invalidParams("Invalid tokenId");
+    }
+    try {
+      const isOwner = await this.isNftOwner(
+        userAddress,
+        contractAddress,
+        tokenId,
+        { networkClientId }
+      );
+      if (!isOwner) {
+        throw rpcErrors.invalidInput(
+          "Suggested NFT is not owned by the selected account"
+        );
+      }
+    } catch (error) {
+      if (error instanceof Error) {
+        throw rpcErrors.resourceUnavailable(error.message);
+      }
+      throw error;
+    }
+  }
+  // temporary method to get the correct chainId until we remove chainId from the config & the chainId arg from the detection logic
+  // Just a helper method to prefer the networkClient chainId first then the chainId argument and then finally the config chainId
+  getCorrectChainId({
+    networkClientId
+  }) {
+    if (networkClientId) {
+      return this.getNetworkClientById(networkClientId).configuration.chainId;
+    }
+    return this.config.chainId;
+  }
+  /**
+   * Adds a new suggestedAsset to state. Parameters will be validated according to
+   * asset type being watched. A `<suggestedNftMeta.id>:pending` hub event will be emitted once added.
+   *
+   * @param asset - The asset to be watched. For now ERC721 and ERC1155 tokens are accepted.
+   * @param asset.address - The address of the asset contract.
+   * @param asset.tokenId - The ID of the asset.
+   * @param type - The asset type.
+   * @param origin - Domain origin to register the asset from.
+   * @param options - Options bag.
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.userAddress - The address of the account where the NFT is being added.
+   * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.
+   */
+  async watchNft(asset, type, origin, {
+    networkClientId,
+    userAddress = this.config.selectedAddress
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    await this.validateWatchNft(asset, type, userAddress);
+    const nftMetadata = await this.getNftInformation(
+      asset.address,
+      asset.tokenId,
+      networkClientId
+    );
+    if (nftMetadata.standard && nftMetadata.standard !== type) {
+      throw rpcErrors.invalidInput(
+        `Suggested NFT of type ${nftMetadata.standard} does not match received type ${type}`
+      );
+    }
+    const suggestedNftMeta = {
+      asset: { ...asset, ...nftMetadata },
+      type,
+      id: random(),
+      time: Date.now(),
+      interactingAddress: userAddress,
+      origin
+    };
+    await this._requestApproval(suggestedNftMeta);
+    const { address, tokenId } = asset;
+    const { name, standard, description, image } = nftMetadata;
+    await this.addNft(address, tokenId, {
+      nftMetadata: {
+        name: name ?? null,
+        description: description ?? null,
+        image: image ?? null,
+        standard: standard ?? null
+      },
+      userAddress,
+      source: "dapp" /* Dapp */,
+      networkClientId
+    });
+  }
+  /**
+   * Sets an OpenSea API key to retrieve NFT information.
+   *
+   * @param openSeaApiKey - OpenSea API key.
+   */
+  setApiKey(openSeaApiKey) {
+    this.openSeaApiKey = openSeaApiKey;
+  }
+  /**
+   * Checks the ownership of a ERC-721 or ERC-1155 NFT for a given address.
+   *
+   * @param ownerAddress - User public address.
+   * @param nftAddress - NFT contract address.
+   * @param tokenId - NFT token ID.
+   * @param options - Options bag.
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving the NFT ownership.
+   */
+  async isNftOwner(ownerAddress, nftAddress, tokenId, {
+    networkClientId
+  } = {}) {
+    try {
+      const owner = await this.getERC721OwnerOf(
+        nftAddress,
+        tokenId,
+        networkClientId
+      );
+      return ownerAddress.toLowerCase() === owner.toLowerCase();
+    } catch {
+    }
+    try {
+      const balance = await this.getERC1155BalanceOf(
+        ownerAddress,
+        nftAddress,
+        tokenId,
+        networkClientId
+      );
+      return !balance.isZero();
+    } catch {
+    }
+    throw new Error(
+      `Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.`
+    );
+  }
+  /**
+   * Verifies currently selected address owns entered NFT address/tokenId combo and
+   * adds the NFT and respective NFT contract to the stored NFT and NFT contracts lists.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - The NFT identifier.
+   * @param options - an object of arguments
+   * @param options.userAddress - The address of the current user.
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
+   */
+  async addNftVerifyOwnership(address, tokenId, {
+    userAddress = this.config.selectedAddress,
+    networkClientId,
+    source
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    if (!await this.isNftOwner(userAddress, address, tokenId, {
+      networkClientId
+    })) {
+      throw new Error("This NFT is not owned by the user");
+    }
+    await this.addNft(address, tokenId, {
+      networkClientId,
+      userAddress,
+      source
+    });
+  }
+  /**
+   * Adds an NFT and respective NFT contract to the stored NFT and NFT contracts lists.
+   *
+   * @param tokenAddress - Hex address of the NFT contract.
+   * @param tokenId - The NFT identifier.
+   * @param options - an object of arguments
+   * @param options.nftMetadata - NFT optional metadata.
+   * @param options.userAddress - The address of the current user.
+   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns Promise resolving to the current NFT list.
+   */
+  async addNft(tokenAddress, tokenId, {
+    nftMetadata,
+    userAddress = this.config.selectedAddress,
+    source = "custom" /* Custom */,
+    networkClientId
+  } = { userAddress: this.config.selectedAddress }) {
+    tokenAddress = toChecksumHexAddress(tokenAddress);
+    const chainId = this.getCorrectChainId({ networkClientId });
+    nftMetadata = nftMetadata || await this.getNftInformation(tokenAddress, tokenId, networkClientId);
+    const newNftContracts = await this.addNftContract({
+      tokenAddress,
+      userAddress,
+      networkClientId,
+      source,
+      nftMetadata
+    });
+    const nftContract = newNftContracts.find(
+      (contract) => contract.address.toLowerCase() === tokenAddress.toLowerCase()
+    );
+    if (nftContract) {
+      await this.addIndividualNft(
+        tokenAddress,
+        tokenId,
+        nftMetadata,
+        nftContract,
+        chainId,
+        userAddress,
+        source
+      );
+    }
+  }
+  /**
+   * Refetches NFT metadata and updates the state
+   *
+   * @param options - Options for refetching NFT metadata
+   * @param options.nfts - nfts to update metadata for.
+   * @param options.userAddress - The current user address
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   */
+  async updateNftMetadata({
+    nfts,
+    userAddress = this.config.selectedAddress,
+    networkClientId
+  }) {
+    const chainId = this.getCorrectChainId({ networkClientId });
+    const nftsWithChecksumAdr = nfts.map((nft) => {
+      return {
+        ...nft,
+        address: toChecksumHexAddress(nft.address)
+      };
+    });
+    const nftMetadataResults = await Promise.allSettled(
+      nftsWithChecksumAdr.map(async (nft) => {
+        const resMetadata = await this.getNftInformation(
+          nft.address,
+          nft.tokenId,
+          networkClientId
+        );
+        return {
+          nft,
+          newMetadata: resMetadata
+        };
+      })
+    );
+    const successfulNewFetchedNfts = nftMetadataResults.filter(
+      (result) => result.status === "fulfilled"
+    );
+    const nftsWithDifferentMetadata = [];
+    const { allNfts } = this.state;
+    const stateNfts = allNfts[userAddress]?.[chainId] || [];
+    successfulNewFetchedNfts.forEach((singleNft) => {
+      const existingEntry = stateNfts.find(
+        (nft) => nft.address.toLowerCase() === singleNft.value.nft.address.toLowerCase() && nft.tokenId === singleNft.value.nft.tokenId
+      );
+      if (existingEntry) {
+        const differentMetadata = compareNftMetadata(
+          singleNft.value.newMetadata,
+          existingEntry
+        );
+        if (differentMetadata) {
+          nftsWithDifferentMetadata.push(singleNft);
+        }
+      }
+    });
+    if (nftsWithDifferentMetadata.length !== 0) {
+      nftsWithDifferentMetadata.forEach(
+        (elm) => this.updateNft(
+          elm.value.nft,
+          elm.value.newMetadata,
+          userAddress,
+          chainId
+        )
+      );
+    }
+  }
+  /**
+   * Removes an NFT from the stored token list.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - Token identifier of the NFT.
+   * @param options - an object of arguments
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.userAddress - The address of the account where the NFT is being removed.
+   */
+  removeNft(address, tokenId, {
+    networkClientId,
+    userAddress = this.config.selectedAddress
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    const chainId = this.getCorrectChainId({ networkClientId });
+    address = toChecksumHexAddress(address);
+    this.removeIndividualNft(address, tokenId, { chainId, userAddress });
+    const { allNfts } = this.state;
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const remainingNft = nfts.find(
+      (nft) => nft.address.toLowerCase() === address.toLowerCase()
+    );
+    if (!remainingNft) {
+      this.removeNftContract(address, { chainId, userAddress });
+    }
+  }
+  /**
+   * Removes an NFT from the stored token list and saves it in ignored NFTs list.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - Token identifier of the NFT.
+   * @param options - an object of arguments
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.userAddress - The address of the account where the NFT is being removed.
+   */
+  removeAndIgnoreNft(address, tokenId, {
+    networkClientId,
+    userAddress = this.config.selectedAddress
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    const chainId = this.getCorrectChainId({ networkClientId });
+    address = toChecksumHexAddress(address);
+    this.removeAndIgnoreIndividualNft(address, tokenId, {
+      chainId,
+      userAddress
+    });
+    const { allNfts } = this.state;
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const remainingNft = nfts.find(
+      (nft) => nft.address.toLowerCase() === address.toLowerCase()
+    );
+    if (!remainingNft) {
+      this.removeNftContract(address, { chainId, userAddress });
+    }
+  }
+  /**
+   * Removes all NFTs from the ignored list.
+   */
+  clearIgnoredNfts() {
+    this.update({ ignoredNfts: [] });
+  }
+  /**
+   * Checks whether input NFT is still owned by the user
+   * And updates the isCurrentlyOwned value on the NFT object accordingly.
+   *
+   * @param nft - The NFT object to check and update.
+   * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.
+   * @param accountParams - The userAddress and chainId to check ownership against
+   * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure assets are stored to the correct account
+   * @param accountParams.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @returns the NFT with the updated isCurrentlyOwned value
+   */
+  async checkAndUpdateSingleNftOwnershipStatus(nft, batch, {
+    userAddress = this.config.selectedAddress,
+    networkClientId
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    const chainId = this.getCorrectChainId({ networkClientId });
+    const { address, tokenId } = nft;
+    let isOwned = nft.isCurrentlyOwned;
+    try {
+      isOwned = await this.isNftOwner(userAddress, address, tokenId, {
+        networkClientId
+      });
+    } catch {
+    }
+    nft.isCurrentlyOwned = isOwned;
+    if (batch) {
+      return nft;
+    }
+    const { allNfts } = this.state;
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const nftToUpdate = nfts.find(
+      (item) => item.tokenId === tokenId && item.address.toLowerCase() === address.toLowerCase()
+    );
+    if (nftToUpdate) {
+      nftToUpdate.isCurrentlyOwned = isOwned;
+      this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {
+        userAddress,
+        chainId
+      });
+    }
+    return nft;
+  }
+  /**
+   * Checks whether NFTs associated with current selectedAddress/chainId combination are still owned by the user
+   * And updates the isCurrentlyOwned value on each accordingly.
+   * @param options - an object of arguments
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.userAddress - The address of the account where the NFT ownership status is checked/updated.
+   */
+  async checkAndUpdateAllNftsOwnershipStatus({
+    networkClientId,
+    userAddress = this.config.selectedAddress
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    const chainId = this.getCorrectChainId({ networkClientId });
+    const { allNfts } = this.state;
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const updatedNfts = await Promise.all(
+      nfts.map(async (nft) => {
+        return await this.checkAndUpdateSingleNftOwnershipStatus(nft, true, {
+          networkClientId,
+          userAddress
+        }) ?? nft;
+      })
+    );
+    this.updateNestedNftState(updatedNfts, ALL_NFTS_STATE_KEY, {
+      userAddress,
+      chainId
+    });
+  }
+  /**
+   * Update NFT favorite status.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - Hex address of the NFT contract.
+   * @param favorite - NFT new favorite status.
+   * @param options - an object of arguments
+   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+   * @param options.userAddress - The address of the account where the NFT is being removed.
+   */
+  updateNftFavoriteStatus(address, tokenId, favorite, {
+    networkClientId,
+    userAddress = this.config.selectedAddress
+  } = {
+    userAddress: this.config.selectedAddress
+  }) {
+    const chainId = this.getCorrectChainId({ networkClientId });
+    const { allNfts } = this.state;
+    const nfts = allNfts[userAddress]?.[chainId] || [];
+    const index = nfts.findIndex(
+      (nft) => nft.address === address && nft.tokenId === tokenId
+    );
+    if (index === -1) {
+      return;
+    }
+    const updatedNft = {
+      ...nfts[index],
+      favorite
+    };
+    nfts[index] = updatedNft;
+    this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {
+      chainId,
+      userAddress
+    });
+  }
+  /**
+   * Returns an NFT by the address and token id.
+   *
+   * @param address - Hex address of the NFT contract.
+   * @param tokenId - Number that represents the id of the token.
+   * @param selectedAddress - Hex address of the user account.
+   * @param chainId - Id of the current network.
+   * @returns Object containing the NFT and its position in the array
+   */
+  findNftByAddressAndTokenId(address, tokenId, selectedAddress, chainId) {
+    const { allNfts } = this.state;
+    const nfts = allNfts[selectedAddress]?.[chainId] || [];
+    const index = nfts.findIndex(
+      (nft) => nft.address.toLowerCase() === address.toLowerCase() && nft.tokenId === tokenId
+    );
+    if (index === -1) {
+      return null;
+    }
+    return { nft: nfts[index], index };
+  }
+  /**
+   * Update NFT data.
+   *
+   * @param nft - NFT object to find the right NFT to updates.
+   * @param updates - NFT partial object to update properties of the NFT.
+   * @param selectedAddress - Hex address of the user account.
+   * @param chainId - Id of the current network.
+   */
+  updateNft(nft, updates, selectedAddress, chainId) {
+    const { allNfts } = this.state;
+    const nfts = allNfts[selectedAddress]?.[chainId] || [];
+    const nftInfo = this.findNftByAddressAndTokenId(
+      nft.address,
+      nft.tokenId,
+      selectedAddress,
+      chainId
+    );
+    if (!nftInfo) {
+      return;
+    }
+    const updatedNft = {
+      ...nft,
+      ...updates
+    };
+    const newNfts = [
+      ...nfts.slice(0, nftInfo.index),
+      updatedNft,
+      ...nfts.slice(nftInfo.index + 1)
+    ];
+    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+      chainId,
+      userAddress: selectedAddress
+    });
+  }
+  /**
+   * Resets the transaction status of an NFT.
+   *
+   * @param transactionId - NFT transaction id.
+   * @param selectedAddress - Hex address of the user account.
+   * @param chainId - Id of the current network.
+   * @returns a boolean indicating if the reset was well succeeded or not
+   */
+  resetNftTransactionStatusByTransactionId(transactionId, selectedAddress, chainId) {
+    const { allNfts } = this.state;
+    const nfts = allNfts[selectedAddress]?.[chainId] || [];
+    const index = nfts.findIndex(
+      (nft) => nft.transactionId === transactionId
+    );
+    if (index === -1) {
+      return false;
+    }
+    const updatedNft = {
+      ...nfts[index],
+      transactionId: void 0
+    };
+    const newNfts = [
+      ...nfts.slice(0, index),
+      updatedNft,
+      ...nfts.slice(index + 1)
+    ];
+    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
+      chainId,
+      userAddress: selectedAddress
+    });
+    return true;
+  }
+  async _requestApproval(suggestedNftMeta) {
+    return this.messagingSystem.call(
+      "ApprovalController:addRequest",
+      {
+        id: suggestedNftMeta.id,
+        origin: suggestedNftMeta.origin,
+        type: ApprovalType.WatchAsset,
+        requestData: {
+          id: suggestedNftMeta.id,
+          interactingAddress: suggestedNftMeta.interactingAddress,
+          asset: {
+            address: suggestedNftMeta.asset.address,
+            tokenId: suggestedNftMeta.asset.tokenId,
+            name: suggestedNftMeta.asset.name,
+            description: suggestedNftMeta.asset.description,
+            image: suggestedNftMeta.asset.image,
+            standard: suggestedNftMeta.asset.standard
+          }
+        }
+      },
+      true
+    );
+  }
+};
+var NftController_default = NftController;
+
+export {
+  getDefaultNftState,
+  NftController,
+  NftController_default
+};
+//# sourceMappingURL=chunk-ONJIVH6M.mjs.map
\ No newline at end of file
diff --git a/dist/chunk-ONJIVH6M.mjs.map b/dist/chunk-ONJIVH6M.mjs.map
new file mode 100644
index 0000000000000000000000000000000000000000..8c8ad2ee46c950c99df94559648b5702539b0fc8
--- /dev/null
+++ b/dist/chunk-ONJIVH6M.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/NftController.ts"],"sourcesContent":["import { isAddress } from '@ethersproject/address';\nimport type { AddApprovalRequest } from '@metamask/approval-controller';\nimport type {\n  BaseConfig,\n  BaseState,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseControllerV1 } from '@metamask/base-controller';\nimport {\n  safelyExecute,\n  handleFetch,\n  toChecksumHexAddress,\n  BNToHex,\n  fetchWithErrorHandling,\n  IPFS_DEFAULT_GATEWAY_URL,\n  ERC721,\n  ERC1155,\n  ApprovalType,\n  NFT_API_BASE_URL,\n} from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkState,\n} from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { Hex } from '@metamask/utils';\nimport { remove0x } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport BN from 'bn.js';\nimport { EventEmitter } from 'events';\nimport { v4 as random } from 'uuid';\n\nimport type { AssetsContractController } from './AssetsContractController';\nimport { compareNftMetadata, getFormattedIpfsUrl } from './assetsUtil';\nimport { Source } from './constants';\nimport type {\n  ApiNftContract,\n  ReservoirResponse,\n  Collection,\n  Attributes,\n  LastSale,\n} from './NftDetectionController';\n\ntype NFTStandardType = 'ERC721' | 'ERC1155';\n\ntype SuggestedNftMeta = {\n  asset: { address: string; tokenId: string } & NftMetadata;\n  id: string;\n  time: number;\n  type: NFTStandardType;\n  interactingAddress: string;\n  origin: string;\n};\n\n/**\n * @type Nft\n *\n * NFT representation\n * @property address - Hex address of a ERC721 contract\n * @property description - The NFT description\n * @property image - URI of custom NFT image associated with this tokenId\n * @property name - Name associated with this tokenId and contract address\n * @property tokenId - The NFT identifier\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property isCurrentlyOwned - Boolean indicating whether the address/chainId combination where it's currently stored currently owns this NFT\n * @property transactionId - Transaction Id associated with the NFT\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface Nft extends NftMetadata {\n  tokenId: string;\n  address: string;\n  isCurrentlyOwned?: boolean;\n}\n\ntype NftUpdate = {\n  nft: Nft;\n  newMetadata: NftMetadata;\n};\n\n/**\n * @type NftContract\n *\n * NFT contract information representation\n * @property name - Contract name\n * @property logo - Contract logo\n * @property address - Contract address\n * @property symbol - Contract symbol\n * @property description - Contract description\n * @property totalSupply - Total supply of NFTs\n * @property assetContractType - The NFT type, it could be `semi-fungible` or `non-fungible`\n * @property createdDate - Creation date\n * @property schemaName - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property externalLink - External link containing additional information\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftContract {\n  name?: string;\n  logo?: string;\n  address: string;\n  symbol?: string;\n  description?: string;\n  totalSupply?: string;\n  assetContractType?: string;\n  createdDate?: string;\n  schemaName?: string;\n  externalLink?: string;\n}\n\n/**\n * @type NftMetadata\n *\n * NFT custom information\n * @property name - NFT custom name\n * @property description - The NFT description\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property image - Image custom image URI\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property standard - NFT standard name for the NFT, e.g., ERC-721 or ERC-1155\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftMetadata {\n  name: string | null;\n  description: string | null;\n  image: string | null;\n  standard: string | null;\n  favorite?: boolean;\n  numberOfSales?: number;\n  backgroundColor?: string;\n  imagePreview?: string;\n  imageThumbnail?: string;\n  imageOriginal?: string;\n  animation?: string;\n  animationOriginal?: string;\n  externalLink?: string;\n  creator?: string;\n  transactionId?: string;\n  tokenURI?: string | null;\n  collection?: Collection;\n  address?: string;\n  attributes?: Attributes;\n  lastSale?: LastSale;\n  rarityRank?: string;\n}\n\n/**\n * @type NftConfig\n *\n * NFT controller configuration\n * @property selectedAddress - Vault selected address\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftConfig extends BaseConfig {\n  selectedAddress: string;\n  chainId: Hex;\n  ipfsGateway: string;\n  openSeaEnabled: boolean;\n  useIPFSSubdomains: boolean;\n  isIpfsGatewayEnabled: boolean;\n}\n\n/**\n * @type NftState\n *\n * NFT controller state\n * @property allNftContracts - Object containing NFT contract information\n * @property allNfts - Object containing NFTs per account and network\n * @property ignoredNfts - List of NFTs that should be ignored\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftState extends BaseState {\n  allNftContracts: {\n    [key: string]: { [chainId: Hex]: NftContract[] };\n  };\n  allNfts: { [key: string]: { [chainId: Hex]: Nft[] } };\n  ignoredNfts: Nft[];\n}\n\nconst ALL_NFTS_STATE_KEY = 'allNfts';\nconst ALL_NFTS_CONTRACTS_STATE_KEY = 'allNftContracts';\n\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\ninterface NftAsset {\n  address: string;\n  tokenId: string;\n}\n\n/**\n * The name of the {@link NftController}.\n */\nconst controllerName = 'NftController';\n\n/**\n * The external actions available to the {@link NftController}.\n */\ntype AllowedActions = AddApprovalRequest;\n\n/**\n * The messenger of the {@link NftController}.\n */\nexport type NftControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  AllowedActions,\n  never,\n  AllowedActions['type'],\n  never\n>;\n\nexport const getDefaultNftState = (): NftState => {\n  return {\n    allNftContracts: {},\n    allNfts: {},\n    ignoredNfts: [],\n  };\n};\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class NftController extends BaseControllerV1<NftConfig, NftState> {\n  private readonly mutex = new Mutex();\n\n  private readonly messagingSystem: NftControllerMessenger;\n\n  getNftApi() {\n    return `${NFT_API_BASE_URL}/tokens`;\n  }\n\n  /**\n   * Helper method to update nested state for allNfts and allNftContracts.\n   *\n   * @param newCollection - the modified piece of state to update in the controller's store\n   * @param baseStateKey - The root key in the store to update.\n   * @param passedConfig - An object containing the selectedAddress and chainId that are passed through the auto-detection flow.\n   * @param passedConfig.userAddress - the address passed through the NFT detection flow to ensure assets are stored to the correct account\n   * @param passedConfig.chainId - the chainId passed through the NFT detection flow to ensure assets are stored to the correct account\n   */\n  private updateNestedNftState(\n    newCollection: Nft[] | NftContract[],\n    baseStateKey: 'allNfts' | 'allNftContracts',\n    { userAddress, chainId }: { userAddress: string; chainId: Hex },\n  ) {\n    const { [baseStateKey]: oldState } = this.state;\n\n    const addressState = oldState[userAddress];\n    const newAddressState = {\n      ...addressState,\n      ...{ [chainId]: newCollection },\n    };\n    const newState = {\n      ...oldState,\n      ...{ [userAddress]: newAddressState },\n    };\n    this.update({\n      [baseStateKey]: newState,\n    });\n  }\n\n  /**\n   * Request individual NFT information from NFT API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromApi(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<NftMetadata> {\n    // TODO Parameterize this by chainId for non-mainnet token detection\n    // Attempt to fetch the data with the nft-api\n    const urlParams = new URLSearchParams({\n      chainIds: '1',\n      tokens: `${contractAddress}:${tokenId}`,\n      includeTopBid: 'true',\n      includeAttributes: 'true',\n      includeLastSale: 'true',\n    }).toString();\n    const nftInformation: ReservoirResponse | undefined =\n      await fetchWithErrorHandling({\n        url: `${this.getNftApi()}?${urlParams}`,\n        options: {\n          headers: {\n            Version: '1',\n          },\n        },\n      });\n    // if we were still unable to fetch the data we return out the default/null of `NftMetadata`\n    if (!nftInformation?.tokens?.[0]?.token) {\n      return {\n        name: null,\n        description: null,\n        image: null,\n        standard: null,\n      };\n    }\n\n    // if we've reached this point, we have successfully fetched some data for nftInformation\n    // now we reconfigure the data to conform to the `NftMetadata` type for storage.\n\n    const {\n      image,\n      metadata: { imageOriginal } = {},\n      name,\n      description,\n      collection,\n      kind,\n      rarityRank,\n      rarity,\n      attributes,\n      lastSale,\n      imageSmall,\n    } = nftInformation.tokens[0].token;\n\n    /* istanbul ignore next */\n    const nftMetadata: NftMetadata = Object.assign(\n      {},\n      { name: name || null },\n      { description: description || null },\n      { image: image || null },\n      collection?.creator && { creator: collection.creator },\n      imageOriginal && { imageOriginal },\n      imageSmall && { imageThumbnail: imageSmall },\n      kind && { standard: kind.toUpperCase() },\n      lastSale && { lastSale },\n      attributes && { attributes },\n      nftInformation.tokens[0].market?.topBid && {\n        topBid: nftInformation.tokens[0].market?.topBid,\n      },\n      rarityRank && { rarityRank },\n      rarity && { rarity },\n      collection && { collection },\n    );\n\n    return nftMetadata;\n  }\n\n  /**\n   * Request individual NFT information from contracts that follows Metadata Interface.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromTokenURI(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<NftMetadata> {\n    const { ipfsGateway, useIPFSSubdomains, isIpfsGatewayEnabled } =\n      this.config;\n    const result = await this.getNftURIAndStandard(\n      contractAddress,\n      tokenId,\n      networkClientId,\n    );\n    let tokenURI = result[0];\n    const standard = result[1];\n\n    const hasIpfsTokenURI = tokenURI.startsWith('ipfs://');\n\n    if (hasIpfsTokenURI && !isIpfsGatewayEnabled) {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n\n    const isDisplayNFTMediaToggleEnabled = this.config.openSeaEnabled;\n    if (!hasIpfsTokenURI && !isDisplayNFTMediaToggleEnabled) {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n\n    if (hasIpfsTokenURI) {\n      tokenURI = getFormattedIpfsUrl(ipfsGateway, tokenURI, useIPFSSubdomains);\n    }\n\n    try {\n      const object = await handleFetch(tokenURI);\n      // TODO: Check image_url existence. This is not part of EIP721 nor EIP1155\n      const image = Object.prototype.hasOwnProperty.call(object, 'image')\n        ? 'image'\n        : /* istanbul ignore next */ 'image_url';\n\n      return {\n        image: object[image],\n        name: object.name,\n        description: object.description,\n        standard,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    } catch {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n  }\n\n  /**\n   * Retrieve NFT uri with  metadata. TODO Update method to use IPFS.\n   *\n   * @param contractAddress - NFT contract address.\n   * @param tokenId - NFT token id.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving NFT uri and token standard.\n   */\n  private async getNftURIAndStandard(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<[string, string]> {\n    // try ERC721 uri\n    try {\n      const uri = await this.getERC721TokenURI(\n        contractAddress,\n        tokenId,\n        networkClientId,\n      );\n      return [uri, ERC721];\n    } catch {\n      // Ignore error\n    }\n\n    // try ERC1155 uri\n    try {\n      const tokenURI = await this.getERC1155TokenURI(\n        contractAddress,\n        tokenId,\n        networkClientId,\n      );\n\n      /**\n       * According to EIP1155 the URI value allows for ID substitution\n       * in case the string `{id}` exists.\n       * https://eips.ethereum.org/EIPS/eip-1155#metadata\n       */\n\n      if (!tokenURI.includes('{id}')) {\n        return [tokenURI, ERC1155];\n      }\n\n      const hexTokenId = remove0x(BNToHex(new BN(tokenId)))\n        .padStart(64, '0')\n        .toLowerCase();\n      return [tokenURI.replace('{id}', hexTokenId), ERC1155];\n    } catch {\n      // Ignore error\n    }\n\n    return ['', ''];\n  }\n\n  /**\n   * Request individual NFT information (name, image url and description).\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformation(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<NftMetadata> {\n    const chainId = this.getCorrectChainId({\n      networkClientId,\n    });\n    const [blockchainMetadata, nftApiMetadata] = await Promise.all([\n      safelyExecute(() =>\n        this.getNftInformationFromTokenURI(\n          contractAddress,\n          tokenId,\n          networkClientId,\n        ),\n      ),\n      this.config.openSeaEnabled && chainId === '0x1'\n        ? safelyExecute(() =>\n            this.getNftInformationFromApi(contractAddress, tokenId),\n          )\n        : undefined,\n    ]);\n    return {\n      ...nftApiMetadata,\n      name: blockchainMetadata?.name ?? nftApiMetadata?.name ?? null,\n      description:\n        blockchainMetadata?.description ?? nftApiMetadata?.description ?? null,\n      image: blockchainMetadata?.image ?? nftApiMetadata?.image ?? null,\n      standard:\n        blockchainMetadata?.standard ?? nftApiMetadata?.standard ?? null,\n      tokenURI: blockchainMetadata?.tokenURI ?? null,\n    };\n  }\n\n  /**\n   * Request NFT contract information from the contract itself.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftContractInformationFromContract(\n    contractAddress: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const [name, symbol] = await Promise.all([\n      this.getERC721AssetName(contractAddress, networkClientId),\n      this.getERC721AssetSymbol(contractAddress, networkClientId),\n    ]);\n\n    return {\n      collection: { name },\n      symbol,\n      address: contractAddress,\n    };\n  }\n\n  /**\n   * Request NFT contract information from Blockchain and aggregate with received data from NFTMetadata.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param nftMetadataFromApi - Received NFT information to be aggregated with blockchain contract information.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the NFT contract name, image and description.\n   */\n  private async getNftContractInformation(\n    contractAddress: string,\n    nftMetadataFromApi: NftMetadata,\n    networkClientId?: NetworkClientId,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const blockchainContractData = await safelyExecute(() =>\n      this.getNftContractInformationFromContract(\n        contractAddress,\n        networkClientId,\n      ),\n    );\n\n    if (\n      blockchainContractData ||\n      !Object.values(nftMetadataFromApi).every((value) => value === null)\n    ) {\n      return {\n        address: contractAddress,\n        ...blockchainContractData,\n        schema_name: nftMetadataFromApi?.standard ?? null,\n        collection: {\n          name: null,\n          image_url:\n            nftMetadataFromApi?.collection?.image ??\n            nftMetadataFromApi?.collection?.imageUrl ??\n            null,\n          tokenCount: nftMetadataFromApi?.collection?.tokenCount ?? null,\n          ...nftMetadataFromApi?.collection,\n          ...blockchainContractData?.collection,\n        },\n      };\n    }\n\n    /* istanbul ignore next */\n    return {\n      address: contractAddress,\n      asset_contract_type: null,\n      created_date: null,\n      schema_name: null,\n      symbol: null,\n      total_supply: null,\n      description: null,\n      external_link: null,\n      collection: { name: null, image_url: null },\n    };\n  }\n\n  /**\n   * Adds an individual NFT to the stored NFT list.\n   *\n   * @param tokenAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param nftMetadata - NFT optional information (name, image and description).\n   * @param nftContract - An object containing contract data of the NFT being added.\n   * @param chainId - The chainId of the network where the NFT is being added.\n   * @param userAddress - The address of the account where the NFT is being added.\n   * @param source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @returns Promise resolving to the current NFT list.\n   */\n  private async addIndividualNft(\n    tokenAddress: string,\n    tokenId: string,\n    nftMetadata: NftMetadata,\n    nftContract: NftContract,\n    chainId: Hex,\n    userAddress: string,\n    source: Source,\n  ): Promise<Nft[]> {\n    // TODO: Remove unused return\n    const releaseLock = await this.mutex.acquire();\n    try {\n      tokenAddress = toChecksumHexAddress(tokenAddress);\n      const { allNfts } = this.state;\n\n      const nfts = allNfts[userAddress]?.[chainId] || [];\n\n      const existingEntry: Nft | undefined = nfts.find(\n        (nft) =>\n          nft.address.toLowerCase() === tokenAddress.toLowerCase() &&\n          nft.tokenId === tokenId,\n      );\n\n      if (existingEntry) {\n        const differentMetadata = compareNftMetadata(\n          nftMetadata,\n          existingEntry,\n        );\n        if (differentMetadata || !existingEntry.isCurrentlyOwned) {\n          // TODO: Switch to indexToUpdate\n          const indexToRemove = nfts.findIndex(\n            (nft) =>\n              nft.address.toLowerCase() === tokenAddress.toLowerCase() &&\n              nft.tokenId === tokenId,\n          );\n          /* istanbul ignore next */\n          if (indexToRemove !== -1) {\n            nfts.splice(indexToRemove, 1);\n          }\n        } else {\n          return nfts;\n        }\n      }\n\n      const newEntry: Nft = {\n        address: tokenAddress,\n        tokenId,\n        favorite: existingEntry?.favorite || false,\n        isCurrentlyOwned: true,\n        ...nftMetadata,\n      };\n\n      const newNfts = [...nfts, newEntry];\n      this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n        chainId,\n        userAddress,\n      });\n\n      if (this.onNftAdded) {\n        this.onNftAdded({\n          address: tokenAddress,\n          symbol: nftContract.symbol,\n          tokenId: tokenId.toString(),\n          standard: nftMetadata.standard,\n          source,\n        });\n      }\n      return newNfts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds an NFT contract to the stored NFT contracts list.\n   *\n   * @param options - options.\n   * @param options.tokenAddress - Hex address of the NFT contract.\n   * @param options.userAddress - The address of the account where the NFT is being added.\n   * @param options.nftMetadata - The retrieved NFTMetadata from API.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private async addNftContract({\n    tokenAddress,\n    userAddress,\n    networkClientId,\n    source,\n    nftMetadata,\n  }: {\n    tokenAddress: string;\n    userAddress: string;\n    nftMetadata: NftMetadata;\n    networkClientId?: NetworkClientId;\n    source?: Source;\n  }): Promise<NftContract[]> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      tokenAddress = toChecksumHexAddress(tokenAddress);\n      const { allNftContracts } = this.state;\n      const chainId = this.getCorrectChainId({\n        networkClientId,\n      });\n\n      const nftContracts = allNftContracts[userAddress]?.[chainId] || [];\n\n      const existingEntry = nftContracts.find(\n        (nftContract) =>\n          nftContract.address.toLowerCase() === tokenAddress.toLowerCase(),\n      );\n      if (existingEntry) {\n        return nftContracts;\n      }\n\n      // this doesn't work currently for detection if the user switches networks while the detection is processing\n      // will be fixed once detection uses networkClientIds\n      // get name and symbol if ERC721 then put together the metadata\n      const contractInformation = await this.getNftContractInformation(\n        tokenAddress,\n        nftMetadata,\n        networkClientId,\n      );\n      const {\n        asset_contract_type,\n        created_date,\n        symbol,\n        description,\n        external_link,\n        schema_name,\n        collection: { name, image_url, tokenCount },\n      } = contractInformation;\n\n      // If the nft is auto-detected we want some valid metadata to be present\n      if (\n        source === Source.Detected &&\n        'address' in contractInformation &&\n        typeof contractInformation.address === 'string' &&\n        'collection' in contractInformation &&\n        contractInformation.collection.name === null &&\n        'image_url' in contractInformation.collection &&\n        contractInformation.collection.image_url === null &&\n        Object.entries(contractInformation).every(([key, value]) => {\n          return key === 'address' || key === 'collection' || !value;\n        })\n      ) {\n        return nftContracts;\n      }\n\n      /* istanbul ignore next */\n      const newEntry: NftContract = Object.assign(\n        {},\n        { address: tokenAddress },\n        description && { description },\n        name && { name },\n        image_url && { logo: image_url },\n        symbol && { symbol },\n        tokenCount !== null &&\n          typeof tokenCount !== 'undefined' && { totalSupply: tokenCount },\n        asset_contract_type && { assetContractType: asset_contract_type },\n        created_date && { createdDate: created_date },\n        schema_name && { schemaName: schema_name },\n        external_link && { externalLink: external_link },\n      );\n      const newNftContracts = [...nftContracts, newEntry];\n      this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {\n        chainId,\n        userAddress,\n      });\n\n      return newNftContracts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - options.\n   * @param options.chainId - The chainId of the network where the NFT is being removed.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  private removeAndIgnoreIndividualNft(\n    address: string,\n    tokenId: string,\n    {\n      chainId,\n      userAddress,\n    }: {\n      chainId: Hex;\n      userAddress: string;\n    },\n  ) {\n    address = toChecksumHexAddress(address);\n    const { allNfts, ignoredNfts } = this.state;\n    const newIgnoredNfts = [...ignoredNfts];\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const newNfts = nfts.filter((nft) => {\n      if (\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId\n      ) {\n        const alreadyIgnored = newIgnoredNfts.find(\n          (c) => c.address === address && c.tokenId === tokenId,\n        );\n        !alreadyIgnored && newIgnoredNfts.push(nft);\n        return false;\n      }\n      return true;\n    });\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      userAddress,\n      chainId,\n    });\n\n    this.update({\n      ignoredNfts: newIgnoredNfts,\n    });\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - options.\n   * @param options.chainId - The chainId of the network where the NFT is being removed.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  private removeIndividualNft(\n    address: string,\n    tokenId: string,\n    { chainId, userAddress }: { chainId: Hex; userAddress: string },\n  ) {\n    address = toChecksumHexAddress(address);\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const newNfts = nfts.filter(\n      (nft) =>\n        !(\n          nft.address.toLowerCase() === address.toLowerCase() &&\n          nft.tokenId === tokenId\n        ),\n    );\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      userAddress,\n      chainId,\n    });\n  }\n\n  /**\n   * Removes an NFT contract to the stored NFT contracts list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param options - options.\n   * @param options.chainId - The chainId of the network where the NFT is being removed.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private removeNftContract(\n    address: string,\n    { chainId, userAddress }: { chainId: Hex; userAddress: string },\n  ): NftContract[] {\n    address = toChecksumHexAddress(address);\n    const { allNftContracts } = this.state;\n    const nftContracts = allNftContracts[userAddress]?.[chainId] || [];\n\n    const newNftContracts = nftContracts.filter(\n      (nftContract) =>\n        !(nftContract.address.toLowerCase() === address.toLowerCase()),\n    );\n    this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {\n      chainId,\n      userAddress,\n    });\n\n    return newNftContracts;\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Optional API key to use with opensea\n   */\n  openSeaApiKey?: string;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'NftController';\n\n  private readonly getERC721AssetName: AssetsContractController['getERC721AssetName'];\n\n  private readonly getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n\n  private readonly getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n\n  private readonly getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n\n  private readonly getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n\n  private readonly getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  private readonly onNftAdded?: (data: {\n    address: string;\n    symbol: string | undefined;\n    tokenId: string;\n    standard: string | null;\n    source: Source;\n  }) => void;\n\n  /**\n   * Creates an NftController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getERC721AssetName - Gets the name of the asset at the given address.\n   * @param options.getERC721AssetSymbol - Gets the symbol of the asset at the given address.\n   * @param options.getERC721TokenURI - Gets the URI of the ERC721 token at the given address, with the given ID.\n   * @param options.getERC721OwnerOf - Get the owner of a ERC-721 NFT.\n   * @param options.getERC1155BalanceOf - Gets balance of a ERC-1155 NFT.\n   * @param options.getERC1155TokenURI - Gets the URI of the ERC1155 token at the given address, with the given ID.\n   * @param options.getNetworkClientById - Gets the network client for the given networkClientId.\n   * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data\n   * for tracking the NFT added event.\n   * @param options.messenger - The controller messenger.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      chainId: initialChainId,\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getERC721AssetName,\n      getERC721AssetSymbol,\n      getERC721TokenURI,\n      getERC721OwnerOf,\n      getERC1155BalanceOf,\n      getERC1155TokenURI,\n      getNetworkClientById,\n      onNftAdded,\n      messenger,\n    }: {\n      chainId: Hex;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getERC721AssetName: AssetsContractController['getERC721AssetName'];\n      getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n      getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n      getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n      getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n      getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n      onNftAdded?: (data: {\n        address: string;\n        symbol: string | undefined;\n        tokenId: string;\n        standard: string | null;\n        source: string;\n      }) => void;\n      messenger: NftControllerMessenger;\n    },\n    config?: Partial<BaseConfig>,\n    state?: Partial<NftState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      selectedAddress: '',\n      chainId: initialChainId,\n      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,\n      openSeaEnabled: false,\n      useIPFSSubdomains: true,\n      isIpfsGatewayEnabled: true,\n    };\n\n    this.defaultState = getDefaultNftState();\n    this.initialize();\n    this.getERC721AssetName = getERC721AssetName;\n    this.getERC721AssetSymbol = getERC721AssetSymbol;\n    this.getERC721TokenURI = getERC721TokenURI;\n    this.getERC721OwnerOf = getERC721OwnerOf;\n    this.getERC1155BalanceOf = getERC1155BalanceOf;\n    this.getERC1155TokenURI = getERC1155TokenURI;\n    this.getNetworkClientById = getNetworkClientById;\n    this.onNftAdded = onNftAdded;\n    this.messagingSystem = messenger;\n\n    onPreferencesStateChange(\n      async ({\n        selectedAddress,\n        ipfsGateway,\n        openSeaEnabled,\n        isIpfsGatewayEnabled,\n      }) => {\n        this.configure({\n          selectedAddress,\n          ipfsGateway,\n          openSeaEnabled,\n          isIpfsGatewayEnabled,\n        });\n\n        const needsUpdateNftMetadata =\n          (isIpfsGatewayEnabled && ipfsGateway !== '') || openSeaEnabled;\n\n        if (needsUpdateNftMetadata) {\n          const { chainId } = this.config;\n          const nfts: Nft[] =\n            this.state.allNfts[selectedAddress]?.[chainId] ?? [];\n          // filter only nfts\n          const nftsToUpdate = nfts.filter(\n            (singleNft) =>\n              !singleNft.name && !singleNft.description && !singleNft.image,\n          );\n          if (nftsToUpdate.length !== 0) {\n            await this.updateNftMetadata({\n              nfts: nftsToUpdate,\n              userAddress: selectedAddress,\n            });\n          }\n        }\n      },\n    );\n\n    onNetworkStateChange(({ providerConfig }) => {\n      const { chainId } = providerConfig;\n      this.configure({ chainId });\n    });\n  }\n\n  private async validateWatchNft(\n    asset: NftAsset,\n    type: NFTStandardType,\n    userAddress: string,\n    { networkClientId }: { networkClientId?: NetworkClientId } = {},\n  ) {\n    const { address: contractAddress, tokenId } = asset;\n\n    // Validate parameters\n    if (!type) {\n      throw rpcErrors.invalidParams('Asset type is required');\n    }\n\n    if (type !== ERC721 && type !== ERC1155) {\n      throw rpcErrors.invalidParams(\n        `Non NFT asset type ${type} not supported by watchNft`,\n      );\n    }\n\n    if (!contractAddress || !tokenId) {\n      throw rpcErrors.invalidParams('Both address and tokenId are required');\n    }\n\n    if (!isAddress(contractAddress)) {\n      throw rpcErrors.invalidParams('Invalid address');\n    }\n\n    if (!/^\\d+$/u.test(tokenId)) {\n      throw rpcErrors.invalidParams('Invalid tokenId');\n    }\n\n    // Check if the user owns the suggested NFT\n    try {\n      const isOwner = await this.isNftOwner(\n        userAddress,\n        contractAddress,\n        tokenId,\n        { networkClientId },\n      );\n      if (!isOwner) {\n        throw rpcErrors.invalidInput(\n          'Suggested NFT is not owned by the selected account',\n        );\n      }\n    } catch (error) {\n      // error thrown here: \"Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.\"\n      if (error instanceof Error) {\n        throw rpcErrors.resourceUnavailable(error.message);\n      }\n      throw error;\n    }\n  }\n\n  // temporary method to get the correct chainId until we remove chainId from the config & the chainId arg from the detection logic\n  // Just a helper method to prefer the networkClient chainId first then the chainId argument and then finally the config chainId\n  private getCorrectChainId({\n    networkClientId,\n  }: {\n    networkClientId?: NetworkClientId;\n  }) {\n    if (networkClientId) {\n      return this.getNetworkClientById(networkClientId).configuration.chainId;\n    }\n    return this.config.chainId;\n  }\n\n  /**\n   * Adds a new suggestedAsset to state. Parameters will be validated according to\n   * asset type being watched. A `<suggestedNftMeta.id>:pending` hub event will be emitted once added.\n   *\n   * @param asset - The asset to be watched. For now ERC721 and ERC1155 tokens are accepted.\n   * @param asset.address - The address of the asset contract.\n   * @param asset.tokenId - The ID of the asset.\n   * @param type - The asset type.\n   * @param origin - Domain origin to register the asset from.\n   * @param options - Options bag.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being added.\n   * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.\n   */\n  async watchNft(\n    asset: NftAsset,\n    type: NFTStandardType,\n    origin: string,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: {\n      networkClientId?: NetworkClientId;\n      userAddress?: string;\n    } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    await this.validateWatchNft(asset, type, userAddress);\n\n    const nftMetadata = await this.getNftInformation(\n      asset.address,\n      asset.tokenId,\n      networkClientId,\n    );\n\n    if (nftMetadata.standard && nftMetadata.standard !== type) {\n      throw rpcErrors.invalidInput(\n        `Suggested NFT of type ${nftMetadata.standard} does not match received type ${type}`,\n      );\n    }\n\n    const suggestedNftMeta: SuggestedNftMeta = {\n      asset: { ...asset, ...nftMetadata },\n      type,\n      id: random(),\n      time: Date.now(),\n      interactingAddress: userAddress,\n      origin,\n    };\n    await this._requestApproval(suggestedNftMeta);\n    const { address, tokenId } = asset;\n    const { name, standard, description, image } = nftMetadata;\n\n    await this.addNft(address, tokenId, {\n      nftMetadata: {\n        name: name ?? null,\n        description: description ?? null,\n        image: image ?? null,\n        standard: standard ?? null,\n      },\n      userAddress,\n      source: Source.Dapp,\n      networkClientId,\n    });\n  }\n\n  /**\n   * Sets an OpenSea API key to retrieve NFT information.\n   *\n   * @param openSeaApiKey - OpenSea API key.\n   */\n  setApiKey(openSeaApiKey: string) {\n    this.openSeaApiKey = openSeaApiKey;\n  }\n\n  /**\n   * Checks the ownership of a ERC-721 or ERC-1155 NFT for a given address.\n   *\n   * @param ownerAddress - User public address.\n   * @param nftAddress - NFT contract address.\n   * @param tokenId - NFT token ID.\n   * @param options - Options bag.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving the NFT ownership.\n   */\n  async isNftOwner(\n    ownerAddress: string,\n    nftAddress: string,\n    tokenId: string,\n    {\n      networkClientId,\n    }: {\n      networkClientId?: NetworkClientId;\n    } = {},\n  ): Promise<boolean> {\n    // Checks the ownership for ERC-721.\n    try {\n      const owner = await this.getERC721OwnerOf(\n        nftAddress,\n        tokenId,\n        networkClientId,\n      );\n      return ownerAddress.toLowerCase() === owner.toLowerCase();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-721 contract error\n    }\n\n    // Checks the ownership for ERC-1155.\n    try {\n      const balance = await this.getERC1155BalanceOf(\n        ownerAddress,\n        nftAddress,\n        tokenId,\n        networkClientId,\n      );\n      return !balance.isZero();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-1155 contract error\n    }\n\n    throw new Error(\n      `Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.`,\n    );\n  }\n\n  /**\n   * Verifies currently selected address owns entered NFT address/tokenId combo and\n   * adds the NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param options - an object of arguments\n   * @param options.userAddress - The address of the current user.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   */\n  async addNftVerifyOwnership(\n    address: string,\n    tokenId: string,\n    {\n      userAddress = this.config.selectedAddress,\n      networkClientId,\n      source,\n    }: {\n      userAddress?: string;\n      networkClientId?: NetworkClientId;\n      source?: Source;\n    } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    if (\n      !(await this.isNftOwner(userAddress, address, tokenId, {\n        networkClientId,\n      }))\n    ) {\n      throw new Error('This NFT is not owned by the user');\n    }\n    await this.addNft(address, tokenId, {\n      networkClientId,\n      userAddress,\n      source,\n    });\n  }\n\n  /**\n   * Adds an NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param tokenAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param options - an object of arguments\n   * @param options.nftMetadata - NFT optional metadata.\n   * @param options.userAddress - The address of the current user.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT list.\n   */\n  async addNft(\n    tokenAddress: string,\n    tokenId: string,\n    {\n      nftMetadata,\n      userAddress = this.config.selectedAddress,\n      source = Source.Custom,\n      networkClientId,\n    }: {\n      nftMetadata?: NftMetadata;\n      userAddress?: string;\n      source?: Source;\n      networkClientId?: NetworkClientId;\n    } = { userAddress: this.config.selectedAddress },\n  ) {\n    tokenAddress = toChecksumHexAddress(tokenAddress);\n\n    const chainId = this.getCorrectChainId({ networkClientId });\n\n    nftMetadata =\n      nftMetadata ||\n      (await this.getNftInformation(tokenAddress, tokenId, networkClientId));\n\n    const newNftContracts = await this.addNftContract({\n      tokenAddress,\n      userAddress,\n      networkClientId,\n      source,\n      nftMetadata,\n    });\n\n    // If NFT contract was not added, do not add individual NFT\n    const nftContract = newNftContracts.find(\n      (contract) =>\n        contract.address.toLowerCase() === tokenAddress.toLowerCase(),\n    );\n\n    // If NFT contract information, add individual NFT\n    if (nftContract) {\n      await this.addIndividualNft(\n        tokenAddress,\n        tokenId,\n        nftMetadata,\n        nftContract,\n        chainId,\n        userAddress,\n        source,\n      );\n    }\n  }\n\n  /**\n   * Refetches NFT metadata and updates the state\n   *\n   * @param options - Options for refetching NFT metadata\n   * @param options.nfts - nfts to update metadata for.\n   * @param options.userAddress - The current user address\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   */\n  async updateNftMetadata({\n    nfts,\n    userAddress = this.config.selectedAddress,\n    networkClientId,\n  }: {\n    nfts: Nft[];\n    userAddress?: string;\n    networkClientId?: NetworkClientId;\n  }) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n\n    const nftsWithChecksumAdr = nfts.map((nft) => {\n      return {\n        ...nft,\n        address: toChecksumHexAddress(nft.address),\n      };\n    });\n    const nftMetadataResults = await Promise.allSettled(\n      nftsWithChecksumAdr.map(async (nft) => {\n        const resMetadata = await this.getNftInformation(\n          nft.address,\n          nft.tokenId,\n          networkClientId,\n        );\n        return {\n          nft,\n          newMetadata: resMetadata,\n        };\n      }),\n    );\n    const successfulNewFetchedNfts = nftMetadataResults.filter(\n      (result): result is PromiseFulfilledResult<NftUpdate> =>\n        result.status === 'fulfilled',\n    );\n    // We want to avoid updating the state if the state and fetched nft info are the same\n    const nftsWithDifferentMetadata: PromiseFulfilledResult<NftUpdate>[] = [];\n    const { allNfts } = this.state;\n    const stateNfts = allNfts[userAddress]?.[chainId] || [];\n\n    successfulNewFetchedNfts.forEach((singleNft) => {\n      const existingEntry: Nft | undefined = stateNfts.find(\n        (nft) =>\n          nft.address.toLowerCase() ===\n            singleNft.value.nft.address.toLowerCase() &&\n          nft.tokenId === singleNft.value.nft.tokenId,\n      );\n\n      if (existingEntry) {\n        const differentMetadata = compareNftMetadata(\n          singleNft.value.newMetadata,\n          existingEntry,\n        );\n\n        if (differentMetadata) {\n          nftsWithDifferentMetadata.push(singleNft);\n        }\n      }\n    });\n\n    if (nftsWithDifferentMetadata.length !== 0) {\n      nftsWithDifferentMetadata.forEach((elm) =>\n        this.updateNft(\n          elm.value.nft,\n          elm.value.newMetadata,\n          userAddress,\n          chainId,\n        ),\n      );\n    }\n  }\n\n  /**\n   * Removes an NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  removeNft(\n    address: string,\n    tokenId: string,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    address = toChecksumHexAddress(address);\n    this.removeIndividualNft(address, tokenId, { chainId, userAddress });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n\n    if (!remainingNft) {\n      this.removeNftContract(address, { chainId, userAddress });\n    }\n  }\n\n  /**\n   * Removes an NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  removeAndIgnoreNft(\n    address: string,\n    tokenId: string,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    address = toChecksumHexAddress(address);\n    this.removeAndIgnoreIndividualNft(address, tokenId, {\n      chainId,\n      userAddress,\n    });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (!remainingNft) {\n      this.removeNftContract(address, { chainId, userAddress });\n    }\n  }\n\n  /**\n   * Removes all NFTs from the ignored list.\n   */\n  clearIgnoredNfts() {\n    this.update({ ignoredNfts: [] });\n  }\n\n  /**\n   * Checks whether input NFT is still owned by the user\n   * And updates the isCurrentlyOwned value on the NFT object accordingly.\n   *\n   * @param nft - The NFT object to check and update.\n   * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.\n   * @param accountParams - The userAddress and chainId to check ownership against\n   * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure assets are stored to the correct account\n   * @param accountParams.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns the NFT with the updated isCurrentlyOwned value\n   */\n  async checkAndUpdateSingleNftOwnershipStatus(\n    nft: Nft,\n    batch: boolean,\n    {\n      userAddress = this.config.selectedAddress,\n      networkClientId,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const { address, tokenId } = nft;\n    let isOwned = nft.isCurrentlyOwned;\n    try {\n      isOwned = await this.isNftOwner(userAddress, address, tokenId, {\n        networkClientId,\n      });\n    } catch {\n      // ignore error\n      // this will only throw an error 'Unable to verify ownership' in which case\n      // we want to keep the current value of isCurrentlyOwned for this flow.\n    }\n\n    nft.isCurrentlyOwned = isOwned;\n\n    if (batch) {\n      return nft;\n    }\n\n    // if this is not part of a batched update we update this one NFT in state\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const nftToUpdate = nfts.find(\n      (item) =>\n        item.tokenId === tokenId &&\n        item.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (nftToUpdate) {\n      nftToUpdate.isCurrentlyOwned = isOwned;\n      this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {\n        userAddress,\n        chainId,\n      });\n    }\n    return nft;\n  }\n\n  /**\n   * Checks whether NFTs associated with current selectedAddress/chainId combination are still owned by the user\n   * And updates the isCurrentlyOwned value on each accordingly.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT ownership status is checked/updated.\n   */\n  async checkAndUpdateAllNftsOwnershipStatus(\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const updatedNfts = await Promise.all(\n      nfts.map(async (nft) => {\n        return (\n          (await this.checkAndUpdateSingleNftOwnershipStatus(nft, true, {\n            networkClientId,\n            userAddress,\n          })) ?? nft\n        );\n      }),\n    );\n\n    this.updateNestedNftState(updatedNfts, ALL_NFTS_STATE_KEY, {\n      userAddress,\n      chainId,\n    });\n  }\n\n  /**\n   * Update NFT favorite status.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Hex address of the NFT contract.\n   * @param favorite - NFT new favorite status.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  updateNftFavoriteStatus(\n    address: string,\n    tokenId: string,\n    favorite: boolean,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: {\n      networkClientId?: NetworkClientId;\n      userAddress?: string;\n    } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.address === address && nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nfts[index],\n      favorite,\n    };\n\n    // Update Nfts array\n    nfts[index] = updatedNft;\n\n    this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {\n      chainId,\n      userAddress,\n    });\n  }\n\n  /**\n   * Returns an NFT by the address and token id.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Number that represents the id of the token.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns Object containing the NFT and its position in the array\n   */\n  findNftByAddressAndTokenId(\n    address: string,\n    tokenId: string,\n    selectedAddress: string,\n    chainId: Hex,\n  ): { nft: Nft; index: number } | null {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) =>\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return null;\n    }\n\n    return { nft: nfts[index], index };\n  }\n\n  /**\n   * Update NFT data.\n   *\n   * @param nft - NFT object to find the right NFT to updates.\n   * @param updates - NFT partial object to update properties of the NFT.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   */\n  updateNft(\n    nft: Nft,\n    updates: Partial<Nft>,\n    selectedAddress: string,\n    chainId: Hex,\n  ) {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const nftInfo = this.findNftByAddressAndTokenId(\n      nft.address,\n      nft.tokenId,\n      selectedAddress,\n      chainId,\n    );\n\n    if (!nftInfo) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nft,\n      ...updates,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, nftInfo.index),\n      updatedNft,\n      ...nfts.slice(nftInfo.index + 1),\n    ];\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      chainId,\n      userAddress: selectedAddress,\n    });\n  }\n\n  /**\n   * Resets the transaction status of an NFT.\n   *\n   * @param transactionId - NFT transaction id.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns a boolean indicating if the reset was well succeeded or not\n   */\n  resetNftTransactionStatusByTransactionId(\n    transactionId: string,\n    selectedAddress: string,\n    chainId: Hex,\n  ): boolean {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.transactionId === transactionId,\n    );\n\n    if (index === -1) {\n      return false;\n    }\n    const updatedNft: Nft = {\n      ...nfts[index],\n      transactionId: undefined,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, index),\n      updatedNft,\n      ...nfts.slice(index + 1),\n    ];\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      chainId,\n      userAddress: selectedAddress,\n    });\n\n    return true;\n  }\n\n  async _requestApproval(suggestedNftMeta: SuggestedNftMeta) {\n    return this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        id: suggestedNftMeta.id,\n        origin: suggestedNftMeta.origin,\n        type: ApprovalType.WatchAsset,\n        requestData: {\n          id: suggestedNftMeta.id,\n          interactingAddress: suggestedNftMeta.interactingAddress,\n          asset: {\n            address: suggestedNftMeta.asset.address,\n            tokenId: suggestedNftMeta.asset.tokenId,\n            name: suggestedNftMeta.asset.name,\n            description: suggestedNftMeta.asset.description,\n            image: suggestedNftMeta.asset.image,\n            standard: suggestedNftMeta.asset.standard,\n          },\n        },\n      },\n      true,\n    );\n  }\n}\n\nexport default NftController;\n"],"mappings":";;;;;;AAAA,SAAS,iBAAiB;AAO1B,SAAS,wBAAwB;AACjC;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAOP,SAAS,iBAAiB;AAE1B,SAAS,gBAAgB;AACzB,SAAS,aAAa;AACtB,OAAO,QAAQ;AACf,SAAS,oBAAoB;AAC7B,SAAS,MAAM,cAAc;AA4K7B,IAAM,qBAAqB;AAC3B,IAAM,+BAA+B;AA+B9B,IAAM,qBAAqB,MAAgB;AAChD,SAAO;AAAA,IACL,iBAAiB,CAAC;AAAA,IAClB,SAAS,CAAC;AAAA,IACV,aAAa,CAAC;AAAA,EAChB;AACF;AAKO,IAAM,gBAAN,cAA4B,iBAAsC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA2tBvE,YACE;AAAA,IACE,SAAS;AAAA,IACT;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAwBA,QACA,OACA;AACA,UAAM,QAAQ,KAAK;AAnwBrB,SAAiB,QAAQ,IAAI,MAAM;AAoqBnC;AAAA;AAAA;AAAA,eAAM,IAAI,aAAa;AAUvB;AAAA;AAAA;AAAA,SAAS,OAAO;AAsFd,SAAK,gBAAgB;AAAA,MACnB,iBAAiB;AAAA,MACjB,SAAS;AAAA,MACT,aAAa;AAAA,MACb,gBAAgB;AAAA,MAChB,mBAAmB;AAAA,MACnB,sBAAsB;AAAA,IACxB;AAEA,SAAK,eAAe,mBAAmB;AACvC,SAAK,WAAW;AAChB,SAAK,qBAAqB;AAC1B,SAAK,uBAAuB;AAC5B,SAAK,oBAAoB;AACzB,SAAK,mBAAmB;AACxB,SAAK,sBAAsB;AAC3B,SAAK,qBAAqB;AAC1B,SAAK,uBAAuB;AAC5B,SAAK,aAAa;AAClB,SAAK,kBAAkB;AAEvB;AAAA,MACE,OAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,MAAM;AACJ,aAAK,UAAU;AAAA,UACb;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AAED,cAAM,yBACH,wBAAwB,gBAAgB,MAAO;AAElD,YAAI,wBAAwB;AAC1B,gBAAM,EAAE,QAAQ,IAAI,KAAK;AACzB,gBAAM,OACJ,KAAK,MAAM,QAAQ,eAAe,IAAI,OAAO,KAAK,CAAC;AAErD,gBAAM,eAAe,KAAK;AAAA,YACxB,CAAC,cACC,CAAC,UAAU,QAAQ,CAAC,UAAU,eAAe,CAAC,UAAU;AAAA,UAC5D;AACA,cAAI,aAAa,WAAW,GAAG;AAC7B,kBAAM,KAAK,kBAAkB;AAAA,cAC3B,MAAM;AAAA,cACN,aAAa;AAAA,YACf,CAAC;AAAA,UACH;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,yBAAqB,CAAC,EAAE,eAAe,MAAM;AAC3C,YAAM,EAAE,QAAQ,IAAI;AACpB,WAAK,UAAU,EAAE,QAAQ,CAAC;AAAA,IAC5B,CAAC;AAAA,EACH;AAAA,EA7zBA,YAAY;AACV,WAAO,GAAG,gBAAgB;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWQ,qBACN,eACA,cACA,EAAE,aAAa,QAAQ,GACvB;AACA,UAAM,EAAE,CAAC,YAAY,GAAG,SAAS,IAAI,KAAK;AAE1C,UAAM,eAAe,SAAS,WAAW;AACzC,UAAM,kBAAkB;AAAA,MACtB,GAAG;AAAA,MACH,GAAG,EAAE,CAAC,OAAO,GAAG,cAAc;AAAA,IAChC;AACA,UAAM,WAAW;AAAA,MACf,GAAG;AAAA,MACH,GAAG,EAAE,CAAC,WAAW,GAAG,gBAAgB;AAAA,IACtC;AACA,SAAK,OAAO;AAAA,MACV,CAAC,YAAY,GAAG;AAAA,IAClB,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAc,yBACZ,iBACA,SACsB;AAGtB,UAAM,YAAY,IAAI,gBAAgB;AAAA,MACpC,UAAU;AAAA,MACV,QAAQ,GAAG,eAAe,IAAI,OAAO;AAAA,MACrC,eAAe;AAAA,MACf,mBAAmB;AAAA,MACnB,iBAAiB;AAAA,IACnB,CAAC,EAAE,SAAS;AACZ,UAAM,iBACJ,MAAM,uBAAuB;AAAA,MAC3B,KAAK,GAAG,KAAK,UAAU,CAAC,IAAI,SAAS;AAAA,MACrC,SAAS;AAAA,QACP,SAAS;AAAA,UACP,SAAS;AAAA,QACX;AAAA,MACF;AAAA,IACF,CAAC;AAEH,QAAI,CAAC,gBAAgB,SAAS,CAAC,GAAG,OAAO;AACvC,aAAO;AAAA,QACL,MAAM;AAAA,QACN,aAAa;AAAA,QACb,OAAO;AAAA,QACP,UAAU;AAAA,MACZ;AAAA,IACF;AAKA,UAAM;AAAA,MACJ;AAAA,MACA,UAAU,EAAE,cAAc,IAAI,CAAC;AAAA,MAC/B;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,IAAI,eAAe,OAAO,CAAC,EAAE;AAG7B,UAAM,cAA2B,OAAO;AAAA,MACtC,CAAC;AAAA,MACD,EAAE,MAAM,QAAQ,KAAK;AAAA,MACrB,EAAE,aAAa,eAAe,KAAK;AAAA,MACnC,EAAE,OAAO,SAAS,KAAK;AAAA,MACvB,YAAY,WAAW,EAAE,SAAS,WAAW,QAAQ;AAAA,MACrD,iBAAiB,EAAE,cAAc;AAAA,MACjC,cAAc,EAAE,gBAAgB,WAAW;AAAA,MAC3C,QAAQ,EAAE,UAAU,KAAK,YAAY,EAAE;AAAA,MACvC,YAAY,EAAE,SAAS;AAAA,MACvB,cAAc,EAAE,WAAW;AAAA,MAC3B,eAAe,OAAO,CAAC,EAAE,QAAQ,UAAU;AAAA,QACzC,QAAQ,eAAe,OAAO,CAAC,EAAE,QAAQ;AAAA,MAC3C;AAAA,MACA,cAAc,EAAE,WAAW;AAAA,MAC3B,UAAU,EAAE,OAAO;AAAA,MACnB,cAAc,EAAE,WAAW;AAAA,IAC7B;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAc,8BACZ,iBACA,SACA,iBACsB;AACtB,UAAM,EAAE,aAAa,mBAAmB,qBAAqB,IAC3D,KAAK;AACP,UAAM,SAAS,MAAM,KAAK;AAAA,MACxB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,QAAI,WAAW,OAAO,CAAC;AACvB,UAAM,WAAW,OAAO,CAAC;AAEzB,UAAM,kBAAkB,SAAS,WAAW,SAAS;AAErD,QAAI,mBAAmB,CAAC,sBAAsB;AAC5C,aAAO;AAAA,QACL,OAAO;AAAA,QACP,MAAM;AAAA,QACN,aAAa;AAAA,QACb,UAAU,YAAY;AAAA,QACtB,UAAU;AAAA,QACV,UAAU,YAAY;AAAA,MACxB;AAAA,IACF;AAEA,UAAM,iCAAiC,KAAK,OAAO;AACnD,QAAI,CAAC,mBAAmB,CAAC,gCAAgC;AACvD,aAAO;AAAA,QACL,OAAO;AAAA,QACP,MAAM;AAAA,QACN,aAAa;AAAA,QACb,UAAU,YAAY;AAAA,QACtB,UAAU;AAAA,QACV,UAAU,YAAY;AAAA,MACxB;AAAA,IACF;AAEA,QAAI,iBAAiB;AACnB,iBAAW,oBAAoB,aAAa,UAAU,iBAAiB;AAAA,IACzE;AAEA,QAAI;AACF,YAAM,SAAS,MAAM,YAAY,QAAQ;AAEzC,YAAM,QAAQ,OAAO,UAAU,eAAe,KAAK,QAAQ,OAAO,IAC9D;AAAA;AAAA,QAC2B;AAAA;AAE/B,aAAO;AAAA,QACL,OAAO,OAAO,KAAK;AAAA,QACnB,MAAM,OAAO;AAAA,QACb,aAAa,OAAO;AAAA,QACpB;AAAA,QACA,UAAU;AAAA,QACV,UAAU,YAAY;AAAA,MACxB;AAAA,IACF,QAAQ;AACN,aAAO;AAAA,QACL,OAAO;AAAA,QACP,MAAM;AAAA,QACN,aAAa;AAAA,QACb,UAAU,YAAY;AAAA,QACtB,UAAU;AAAA,QACV,UAAU,YAAY;AAAA,MACxB;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAc,qBACZ,iBACA,SACA,iBAC2B;AAE3B,QAAI;AACF,YAAM,MAAM,MAAM,KAAK;AAAA,QACrB;AAAA,QACA;AAAA,QACA;AAAA,MACF;AACA,aAAO,CAAC,KAAK,MAAM;AAAA,IACrB,QAAQ;AAAA,IAER;AAGA,QAAI;AACF,YAAM,WAAW,MAAM,KAAK;AAAA,QAC1B;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAQA,UAAI,CAAC,SAAS,SAAS,MAAM,GAAG;AAC9B,eAAO,CAAC,UAAU,OAAO;AAAA,MAC3B;AAEA,YAAM,aAAa,SAAS,QAAQ,IAAI,GAAG,OAAO,CAAC,CAAC,EACjD,SAAS,IAAI,GAAG,EAChB,YAAY;AACf,aAAO,CAAC,SAAS,QAAQ,QAAQ,UAAU,GAAG,OAAO;AAAA,IACvD,QAAQ;AAAA,IAER;AAEA,WAAO,CAAC,IAAI,EAAE;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAc,kBACZ,iBACA,SACA,iBACsB;AACtB,UAAM,UAAU,KAAK,kBAAkB;AAAA,MACrC;AAAA,IACF,CAAC;AACD,UAAM,CAAC,oBAAoB,cAAc,IAAI,MAAM,QAAQ,IAAI;AAAA,MAC7D;AAAA,QAAc,MACZ,KAAK;AAAA,UACH;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,MACA,KAAK,OAAO,kBAAkB,YAAY,QACtC;AAAA,QAAc,MACZ,KAAK,yBAAyB,iBAAiB,OAAO;AAAA,MACxD,IACA;AAAA,IACN,CAAC;AACD,WAAO;AAAA,MACL,GAAG;AAAA,MACH,MAAM,oBAAoB,QAAQ,gBAAgB,QAAQ;AAAA,MAC1D,aACE,oBAAoB,eAAe,gBAAgB,eAAe;AAAA,MACpE,OAAO,oBAAoB,SAAS,gBAAgB,SAAS;AAAA,MAC7D,UACE,oBAAoB,YAAY,gBAAgB,YAAY;AAAA,MAC9D,UAAU,oBAAoB,YAAY;AAAA,IAC5C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAc,sCACZ,iBACA,iBAKA;AACA,UAAM,CAAC,MAAM,MAAM,IAAI,MAAM,QAAQ,IAAI;AAAA,MACvC,KAAK,mBAAmB,iBAAiB,eAAe;AAAA,MACxD,KAAK,qBAAqB,iBAAiB,eAAe;AAAA,IAC5D,CAAC;AAED,WAAO;AAAA,MACL,YAAY,EAAE,KAAK;AAAA,MACnB;AAAA,MACA,SAAS;AAAA,IACX;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAc,0BACZ,iBACA,oBACA,iBAKA;AACA,UAAM,yBAAyB,MAAM;AAAA,MAAc,MACjD,KAAK;AAAA,QACH;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,QACE,0BACA,CAAC,OAAO,OAAO,kBAAkB,EAAE,MAAM,CAAC,UAAU,UAAU,IAAI,GAClE;AACA,aAAO;AAAA,QACL,SAAS;AAAA,QACT,GAAG;AAAA,QACH,aAAa,oBAAoB,YAAY;AAAA,QAC7C,YAAY;AAAA,UACV,MAAM;AAAA,UACN,WACE,oBAAoB,YAAY,SAChC,oBAAoB,YAAY,YAChC;AAAA,UACF,YAAY,oBAAoB,YAAY,cAAc;AAAA,UAC1D,GAAG,oBAAoB;AAAA,UACvB,GAAG,wBAAwB;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AAGA,WAAO;AAAA,MACL,SAAS;AAAA,MACT,qBAAqB;AAAA,MACrB,cAAc;AAAA,MACd,aAAa;AAAA,MACb,QAAQ;AAAA,MACR,cAAc;AAAA,MACd,aAAa;AAAA,MACb,eAAe;AAAA,MACf,YAAY,EAAE,MAAM,MAAM,WAAW,KAAK;AAAA,IAC5C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,MAAc,iBACZ,cACA,SACA,aACA,aACA,SACA,aACA,QACgB;AAEhB,UAAM,cAAc,MAAM,KAAK,MAAM,QAAQ;AAC7C,QAAI;AACF,qBAAe,qBAAqB,YAAY;AAChD,YAAM,EAAE,QAAQ,IAAI,KAAK;AAEzB,YAAM,OAAO,QAAQ,WAAW,IAAI,OAAO,KAAK,CAAC;AAEjD,YAAM,gBAAiC,KAAK;AAAA,QAC1C,CAAC,QACC,IAAI,QAAQ,YAAY,MAAM,aAAa,YAAY,KACvD,IAAI,YAAY;AAAA,MACpB;AAEA,UAAI,eAAe;AACjB,cAAM,oBAAoB;AAAA,UACxB;AAAA,UACA;AAAA,QACF;AACA,YAAI,qBAAqB,CAAC,cAAc,kBAAkB;AAExD,gBAAM,gBAAgB,KAAK;AAAA,YACzB,CAAC,QACC,IAAI,QAAQ,YAAY,MAAM,aAAa,YAAY,KACvD,IAAI,YAAY;AAAA,UACpB;AAEA,cAAI,kBAAkB,IAAI;AACxB,iBAAK,OAAO,eAAe,CAAC;AAAA,UAC9B;AAAA,QACF,OAAO;AACL,iBAAO;AAAA,QACT;AAAA,MACF;AAEA,YAAM,WAAgB;AAAA,QACpB,SAAS;AAAA,QACT;AAAA,QACA,UAAU,eAAe,YAAY;AAAA,QACrC,kBAAkB;AAAA,QAClB,GAAG;AAAA,MACL;AAEA,YAAM,UAAU,CAAC,GAAG,MAAM,QAAQ;AAClC,WAAK,qBAAqB,SAAS,oBAAoB;AAAA,QACrD;AAAA,QACA;AAAA,MACF,CAAC;AAED,UAAI,KAAK,YAAY;AACnB,aAAK,WAAW;AAAA,UACd,SAAS;AAAA,UACT,QAAQ,YAAY;AAAA,UACpB,SAAS,QAAQ,SAAS;AAAA,UAC1B,UAAU,YAAY;AAAA,UACtB;AAAA,QACF,CAAC;AAAA,MACH;AACA,aAAO;AAAA,IACT,UAAE;AACA,kBAAY;AAAA,IACd;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,MAAc,eAAe;AAAA,IAC3B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAM2B;AACzB,UAAM,cAAc,MAAM,KAAK,MAAM,QAAQ;AAC7C,QAAI;AACF,qBAAe,qBAAqB,YAAY;AAChD,YAAM,EAAE,gBAAgB,IAAI,KAAK;AACjC,YAAM,UAAU,KAAK,kBAAkB;AAAA,QACrC;AAAA,MACF,CAAC;AAED,YAAM,eAAe,gBAAgB,WAAW,IAAI,OAAO,KAAK,CAAC;AAEjE,YAAM,gBAAgB,aAAa;AAAA,QACjC,CAAC,gBACC,YAAY,QAAQ,YAAY,MAAM,aAAa,YAAY;AAAA,MACnE;AACA,UAAI,eAAe;AACjB,eAAO;AAAA,MACT;AAKA,YAAM,sBAAsB,MAAM,KAAK;AAAA,QACrC;AAAA,QACA;AAAA,QACA;AAAA,MACF;AACA,YAAM;AAAA,QACJ;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,YAAY,EAAE,MAAM,WAAW,WAAW;AAAA,MAC5C,IAAI;AAGJ,UACE,wCACA,aAAa,uBACb,OAAO,oBAAoB,YAAY,YACvC,gBAAgB,uBAChB,oBAAoB,WAAW,SAAS,QACxC,eAAe,oBAAoB,cACnC,oBAAoB,WAAW,cAAc,QAC7C,OAAO,QAAQ,mBAAmB,EAAE,MAAM,CAAC,CAAC,KAAK,KAAK,MAAM;AAC1D,eAAO,QAAQ,aAAa,QAAQ,gBAAgB,CAAC;AAAA,MACvD,CAAC,GACD;AACA,eAAO;AAAA,MACT;AAGA,YAAM,WAAwB,OAAO;AAAA,QACnC,CAAC;AAAA,QACD,EAAE,SAAS,aAAa;AAAA,QACxB,eAAe,EAAE,YAAY;AAAA,QAC7B,QAAQ,EAAE,KAAK;AAAA,QACf,aAAa,EAAE,MAAM,UAAU;AAAA,QAC/B,UAAU,EAAE,OAAO;AAAA,QACnB,eAAe,QACb,OAAO,eAAe,eAAe,EAAE,aAAa,WAAW;AAAA,QACjE,uBAAuB,EAAE,mBAAmB,oBAAoB;AAAA,QAChE,gBAAgB,EAAE,aAAa,aAAa;AAAA,QAC5C,eAAe,EAAE,YAAY,YAAY;AAAA,QACzC,iBAAiB,EAAE,cAAc,cAAc;AAAA,MACjD;AACA,YAAM,kBAAkB,CAAC,GAAG,cAAc,QAAQ;AAClD,WAAK,qBAAqB,iBAAiB,8BAA8B;AAAA,QACvE;AAAA,QACA;AAAA,MACF,CAAC;AAED,aAAO;AAAA,IACT,UAAE;AACA,kBAAY;AAAA,IACd;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWQ,6BACN,SACA,SACA;AAAA,IACE;AAAA,IACA;AAAA,EACF,GAIA;AACA,cAAU,qBAAqB,OAAO;AACtC,UAAM,EAAE,SAAS,YAAY,IAAI,KAAK;AACtC,UAAM,iBAAiB,CAAC,GAAG,WAAW;AACtC,UAAM,OAAO,QAAQ,WAAW,IAAI,OAAO,KAAK,CAAC;AACjD,UAAM,UAAU,KAAK,OAAO,CAAC,QAAQ;AACnC,UACE,IAAI,QAAQ,YAAY,MAAM,QAAQ,YAAY,KAClD,IAAI,YAAY,SAChB;AACA,cAAM,iBAAiB,eAAe;AAAA,UACpC,CAAC,MAAM,EAAE,YAAY,WAAW,EAAE,YAAY;AAAA,QAChD;AACA,SAAC,kBAAkB,eAAe,KAAK,GAAG;AAC1C,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT,CAAC;AAED,SAAK,qBAAqB,SAAS,oBAAoB;AAAA,MACrD;AAAA,MACA;AAAA,IACF,CAAC;AAED,SAAK,OAAO;AAAA,MACV,aAAa;AAAA,IACf,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWQ,oBACN,SACA,SACA,EAAE,SAAS,YAAY,GACvB;AACA,cAAU,qBAAqB,OAAO;AACtC,UAAM,EAAE,QAAQ,IAAI,KAAK;AACzB,UAAM,OAAO,QAAQ,WAAW,IAAI,OAAO,KAAK,CAAC;AACjD,UAAM,UAAU,KAAK;AAAA,MACnB,CAAC,QACC,EACE,IAAI,QAAQ,YAAY,MAAM,QAAQ,YAAY,KAClD,IAAI,YAAY;AAAA,IAEtB;AACA,SAAK,qBAAqB,SAAS,oBAAoB;AAAA,MACrD;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWQ,kBACN,SACA,EAAE,SAAS,YAAY,GACR;AACf,cAAU,qBAAqB,OAAO;AACtC,UAAM,EAAE,gBAAgB,IAAI,KAAK;AACjC,UAAM,eAAe,gBAAgB,WAAW,IAAI,OAAO,KAAK,CAAC;AAEjE,UAAM,kBAAkB,aAAa;AAAA,MACnC,CAAC,gBACC,EAAE,YAAY,QAAQ,YAAY,MAAM,QAAQ,YAAY;AAAA,IAChE;AACA,SAAK,qBAAqB,iBAAiB,8BAA8B;AAAA,MACvE;AAAA,MACA;AAAA,IACF,CAAC;AAED,WAAO;AAAA,EACT;AAAA,EAoKA,MAAc,iBACZ,OACA,MACA,aACA,EAAE,gBAAgB,IAA2C,CAAC,GAC9D;AACA,UAAM,EAAE,SAAS,iBAAiB,QAAQ,IAAI;AAG9C,QAAI,CAAC,MAAM;AACT,YAAM,UAAU,cAAc,wBAAwB;AAAA,IACxD;AAEA,QAAI,SAAS,UAAU,SAAS,SAAS;AACvC,YAAM,UAAU;AAAA,QACd,sBAAsB,IAAI;AAAA,MAC5B;AAAA,IACF;AAEA,QAAI,CAAC,mBAAmB,CAAC,SAAS;AAChC,YAAM,UAAU,cAAc,uCAAuC;AAAA,IACvE;AAEA,QAAI,CAAC,UAAU,eAAe,GAAG;AAC/B,YAAM,UAAU,cAAc,iBAAiB;AAAA,IACjD;AAEA,QAAI,CAAC,SAAS,KAAK,OAAO,GAAG;AAC3B,YAAM,UAAU,cAAc,iBAAiB;AAAA,IACjD;AAGA,QAAI;AACF,YAAM,UAAU,MAAM,KAAK;AAAA,QACzB;AAAA,QACA;AAAA,QACA;AAAA,QACA,EAAE,gBAAgB;AAAA,MACpB;AACA,UAAI,CAAC,SAAS;AACZ,cAAM,UAAU;AAAA,UACd;AAAA,QACF;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AAEd,UAAI,iBAAiB,OAAO;AAC1B,cAAM,UAAU,oBAAoB,MAAM,OAAO;AAAA,MACnD;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA,EAIQ,kBAAkB;AAAA,IACxB;AAAA,EACF,GAEG;AACD,QAAI,iBAAiB;AACnB,aAAO,KAAK,qBAAqB,eAAe,EAAE,cAAc;AAAA,IAClE;AACA,WAAO,KAAK,OAAO;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBA,MAAM,SACJ,OACA,MACA,QACA;AAAA,IACE;AAAA,IACA,cAAc,KAAK,OAAO;AAAA,EAC5B,IAGI;AAAA,IACF,aAAa,KAAK,OAAO;AAAA,EAC3B,GACA;AACA,UAAM,KAAK,iBAAiB,OAAO,MAAM,WAAW;AAEpD,UAAM,cAAc,MAAM,KAAK;AAAA,MAC7B,MAAM;AAAA,MACN,MAAM;AAAA,MACN;AAAA,IACF;AAEA,QAAI,YAAY,YAAY,YAAY,aAAa,MAAM;AACzD,YAAM,UAAU;AAAA,QACd,yBAAyB,YAAY,QAAQ,iCAAiC,IAAI;AAAA,MACpF;AAAA,IACF;AAEA,UAAM,mBAAqC;AAAA,MACzC,OAAO,EAAE,GAAG,OAAO,GAAG,YAAY;AAAA,MAClC;AAAA,MACA,IAAI,OAAO;AAAA,MACX,MAAM,KAAK,IAAI;AAAA,MACf,oBAAoB;AAAA,MACpB;AAAA,IACF;AACA,UAAM,KAAK,iBAAiB,gBAAgB;AAC5C,UAAM,EAAE,SAAS,QAAQ,IAAI;AAC7B,UAAM,EAAE,MAAM,UAAU,aAAa,MAAM,IAAI;AAE/C,UAAM,KAAK,OAAO,SAAS,SAAS;AAAA,MAClC,aAAa;AAAA,QACX,MAAM,QAAQ;AAAA,QACd,aAAa,eAAe;AAAA,QAC5B,OAAO,SAAS;AAAA,QAChB,UAAU,YAAY;AAAA,MACxB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,UAAU,eAAuB;AAC/B,SAAK,gBAAgB;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,MAAM,WACJ,cACA,YACA,SACA;AAAA,IACE;AAAA,EACF,IAEI,CAAC,GACa;AAElB,QAAI;AACF,YAAM,QAAQ,MAAM,KAAK;AAAA,QACvB;AAAA,QACA;AAAA,QACA;AAAA,MACF;AACA,aAAO,aAAa,YAAY,MAAM,MAAM,YAAY;AAAA,IAE1D,QAAQ;AAAA,IAER;AAGA,QAAI;AACF,YAAM,UAAU,MAAM,KAAK;AAAA,QACzB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AACA,aAAO,CAAC,QAAQ,OAAO;AAAA,IAEzB,QAAQ;AAAA,IAER;AAEA,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,MAAM,sBACJ,SACA,SACA;AAAA,IACE,cAAc,KAAK,OAAO;AAAA,IAC1B;AAAA,IACA;AAAA,EACF,IAII;AAAA,IACF,aAAa,KAAK,OAAO;AAAA,EAC3B,GACA;AACA,QACE,CAAE,MAAM,KAAK,WAAW,aAAa,SAAS,SAAS;AAAA,MACrD;AAAA,IACF,CAAC,GACD;AACA,YAAM,IAAI,MAAM,mCAAmC;AAAA,IACrD;AACA,UAAM,KAAK,OAAO,SAAS,SAAS;AAAA,MAClC;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,MAAM,OACJ,cACA,SACA;AAAA,IACE;AAAA,IACA,cAAc,KAAK,OAAO;AAAA,IAC1B;AAAA,IACA;AAAA,EACF,IAKI,EAAE,aAAa,KAAK,OAAO,gBAAgB,GAC/C;AACA,mBAAe,qBAAqB,YAAY;AAEhD,UAAM,UAAU,KAAK,kBAAkB,EAAE,gBAAgB,CAAC;AAE1D,kBACE,eACC,MAAM,KAAK,kBAAkB,cAAc,SAAS,eAAe;AAEtE,UAAM,kBAAkB,MAAM,KAAK,eAAe;AAAA,MAChD;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAGD,UAAM,cAAc,gBAAgB;AAAA,MAClC,CAAC,aACC,SAAS,QAAQ,YAAY,MAAM,aAAa,YAAY;AAAA,IAChE;AAGA,QAAI,aAAa;AACf,YAAM,KAAK;AAAA,QACT;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,kBAAkB;AAAA,IACtB;AAAA,IACA,cAAc,KAAK,OAAO;AAAA,IAC1B;AAAA,EACF,GAIG;AACD,UAAM,UAAU,KAAK,kBAAkB,EAAE,gBAAgB,CAAC;AAE1D,UAAM,sBAAsB,KAAK,IAAI,CAAC,QAAQ;AAC5C,aAAO;AAAA,QACL,GAAG;AAAA,QACH,SAAS,qBAAqB,IAAI,OAAO;AAAA,MAC3C;AAAA,IACF,CAAC;AACD,UAAM,qBAAqB,MAAM,QAAQ;AAAA,MACvC,oBAAoB,IAAI,OAAO,QAAQ;AACrC,cAAM,cAAc,MAAM,KAAK;AAAA,UAC7B,IAAI;AAAA,UACJ,IAAI;AAAA,UACJ;AAAA,QACF;AACA,eAAO;AAAA,UACL;AAAA,UACA,aAAa;AAAA,QACf;AAAA,MACF,CAAC;AAAA,IACH;AACA,UAAM,2BAA2B,mBAAmB;AAAA,MAClD,CAAC,WACC,OAAO,WAAW;AAAA,IACtB;AAEA,UAAM,4BAAiE,CAAC;AACxE,UAAM,EAAE,QAAQ,IAAI,KAAK;AACzB,UAAM,YAAY,QAAQ,WAAW,IAAI,OAAO,KAAK,CAAC;AAEtD,6BAAyB,QAAQ,CAAC,cAAc;AAC9C,YAAM,gBAAiC,UAAU;AAAA,QAC/C,CAAC,QACC,IAAI,QAAQ,YAAY,MACtB,UAAU,MAAM,IAAI,QAAQ,YAAY,KAC1C,IAAI,YAAY,UAAU,MAAM,IAAI;AAAA,MACxC;AAEA,UAAI,eAAe;AACjB,cAAM,oBAAoB;AAAA,UACxB,UAAU,MAAM;AAAA,UAChB;AAAA,QACF;AAEA,YAAI,mBAAmB;AACrB,oCAA0B,KAAK,SAAS;AAAA,QAC1C;AAAA,MACF;AAAA,IACF,CAAC;AAED,QAAI,0BAA0B,WAAW,GAAG;AAC1C,gCAA0B;AAAA,QAAQ,CAAC,QACjC,KAAK;AAAA,UACH,IAAI,MAAM;AAAA,UACV,IAAI,MAAM;AAAA,UACV;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,UACE,SACA,SACA;AAAA,IACE;AAAA,IACA,cAAc,KAAK,OAAO;AAAA,EAC5B,IAAiE;AAAA,IAC/D,aAAa,KAAK,OAAO;AAAA,EAC3B,GACA;AACA,UAAM,UAAU,KAAK,kBAAkB,EAAE,gBAAgB,CAAC;AAC1D,cAAU,qBAAqB,OAAO;AACtC,SAAK,oBAAoB,SAAS,SAAS,EAAE,SAAS,YAAY,CAAC;AACnE,UAAM,EAAE,QAAQ,IAAI,KAAK;AACzB,UAAM,OAAO,QAAQ,WAAW,IAAI,OAAO,KAAK,CAAC;AACjD,UAAM,eAAe,KAAK;AAAA,MACxB,CAAC,QAAQ,IAAI,QAAQ,YAAY,MAAM,QAAQ,YAAY;AAAA,IAC7D;AAEA,QAAI,CAAC,cAAc;AACjB,WAAK,kBAAkB,SAAS,EAAE,SAAS,YAAY,CAAC;AAAA,IAC1D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,mBACE,SACA,SACA;AAAA,IACE;AAAA,IACA,cAAc,KAAK,OAAO;AAAA,EAC5B,IAAiE;AAAA,IAC/D,aAAa,KAAK,OAAO;AAAA,EAC3B,GACA;AACA,UAAM,UAAU,KAAK,kBAAkB,EAAE,gBAAgB,CAAC;AAC1D,cAAU,qBAAqB,OAAO;AACtC,SAAK,6BAA6B,SAAS,SAAS;AAAA,MAClD;AAAA,MACA;AAAA,IACF,CAAC;AACD,UAAM,EAAE,QAAQ,IAAI,KAAK;AACzB,UAAM,OAAO,QAAQ,WAAW,IAAI,OAAO,KAAK,CAAC;AACjD,UAAM,eAAe,KAAK;AAAA,MACxB,CAAC,QAAQ,IAAI,QAAQ,YAAY,MAAM,QAAQ,YAAY;AAAA,IAC7D;AACA,QAAI,CAAC,cAAc;AACjB,WAAK,kBAAkB,SAAS,EAAE,SAAS,YAAY,CAAC;AAAA,IAC1D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,mBAAmB;AACjB,SAAK,OAAO,EAAE,aAAa,CAAC,EAAE,CAAC;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,MAAM,uCACJ,KACA,OACA;AAAA,IACE,cAAc,KAAK,OAAO;AAAA,IAC1B;AAAA,EACF,IAAiE;AAAA,IAC/D,aAAa,KAAK,OAAO;AAAA,EAC3B,GACA;AACA,UAAM,UAAU,KAAK,kBAAkB,EAAE,gBAAgB,CAAC;AAC1D,UAAM,EAAE,SAAS,QAAQ,IAAI;AAC7B,QAAI,UAAU,IAAI;AAClB,QAAI;AACF,gBAAU,MAAM,KAAK,WAAW,aAAa,SAAS,SAAS;AAAA,QAC7D;AAAA,MACF,CAAC;AAAA,IACH,QAAQ;AAAA,IAIR;AAEA,QAAI,mBAAmB;AAEvB,QAAI,OAAO;AACT,aAAO;AAAA,IACT;AAGA,UAAM,EAAE,QAAQ,IAAI,KAAK;AACzB,UAAM,OAAO,QAAQ,WAAW,IAAI,OAAO,KAAK,CAAC;AACjD,UAAM,cAAc,KAAK;AAAA,MACvB,CAAC,SACC,KAAK,YAAY,WACjB,KAAK,QAAQ,YAAY,MAAM,QAAQ,YAAY;AAAA,IACvD;AACA,QAAI,aAAa;AACf,kBAAY,mBAAmB;AAC/B,WAAK,qBAAqB,MAAM,oBAAoB;AAAA,QAClD;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,qCACJ;AAAA,IACE;AAAA,IACA,cAAc,KAAK,OAAO;AAAA,EAC5B,IAAiE;AAAA,IAC/D,aAAa,KAAK,OAAO;AAAA,EAC3B,GACA;AACA,UAAM,UAAU,KAAK,kBAAkB,EAAE,gBAAgB,CAAC;AAC1D,UAAM,EAAE,QAAQ,IAAI,KAAK;AACzB,UAAM,OAAO,QAAQ,WAAW,IAAI,OAAO,KAAK,CAAC;AACjD,UAAM,cAAc,MAAM,QAAQ;AAAA,MAChC,KAAK,IAAI,OAAO,QAAQ;AACtB,eACG,MAAM,KAAK,uCAAuC,KAAK,MAAM;AAAA,UAC5D;AAAA,UACA;AAAA,QACF,CAAC,KAAM;AAAA,MAEX,CAAC;AAAA,IACH;AAEA,SAAK,qBAAqB,aAAa,oBAAoB;AAAA,MACzD;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,wBACE,SACA,SACA,UACA;AAAA,IACE;AAAA,IACA,cAAc,KAAK,OAAO;AAAA,EAC5B,IAGI;AAAA,IACF,aAAa,KAAK,OAAO;AAAA,EAC3B,GACA;AACA,UAAM,UAAU,KAAK,kBAAkB,EAAE,gBAAgB,CAAC;AAC1D,UAAM,EAAE,QAAQ,IAAI,KAAK;AACzB,UAAM,OAAO,QAAQ,WAAW,IAAI,OAAO,KAAK,CAAC;AACjD,UAAM,QAAgB,KAAK;AAAA,MACzB,CAAC,QAAQ,IAAI,YAAY,WAAW,IAAI,YAAY;AAAA,IACtD;AAEA,QAAI,UAAU,IAAI;AAChB;AAAA,IACF;AAEA,UAAM,aAAkB;AAAA,MACtB,GAAG,KAAK,KAAK;AAAA,MACb;AAAA,IACF;AAGA,SAAK,KAAK,IAAI;AAEd,SAAK,qBAAqB,MAAM,oBAAoB;AAAA,MAClD;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,2BACE,SACA,SACA,iBACA,SACoC;AACpC,UAAM,EAAE,QAAQ,IAAI,KAAK;AACzB,UAAM,OAAO,QAAQ,eAAe,IAAI,OAAO,KAAK,CAAC;AACrD,UAAM,QAAgB,KAAK;AAAA,MACzB,CAAC,QACC,IAAI,QAAQ,YAAY,MAAM,QAAQ,YAAY,KAClD,IAAI,YAAY;AAAA,IACpB;AAEA,QAAI,UAAU,IAAI;AAChB,aAAO;AAAA,IACT;AAEA,WAAO,EAAE,KAAK,KAAK,KAAK,GAAG,MAAM;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,UACE,KACA,SACA,iBACA,SACA;AACA,UAAM,EAAE,QAAQ,IAAI,KAAK;AACzB,UAAM,OAAO,QAAQ,eAAe,IAAI,OAAO,KAAK,CAAC;AACrD,UAAM,UAAU,KAAK;AAAA,MACnB,IAAI;AAAA,MACJ,IAAI;AAAA,MACJ;AAAA,MACA;AAAA,IACF;AAEA,QAAI,CAAC,SAAS;AACZ;AAAA,IACF;AAEA,UAAM,aAAkB;AAAA,MACtB,GAAG;AAAA,MACH,GAAG;AAAA,IACL;AAEA,UAAM,UAAU;AAAA,MACd,GAAG,KAAK,MAAM,GAAG,QAAQ,KAAK;AAAA,MAC9B;AAAA,MACA,GAAG,KAAK,MAAM,QAAQ,QAAQ,CAAC;AAAA,IACjC;AACA,SAAK,qBAAqB,SAAS,oBAAoB;AAAA,MACrD;AAAA,MACA,aAAa;AAAA,IACf,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,yCACE,eACA,iBACA,SACS;AACT,UAAM,EAAE,QAAQ,IAAI,KAAK;AACzB,UAAM,OAAO,QAAQ,eAAe,IAAI,OAAO,KAAK,CAAC;AACrD,UAAM,QAAgB,KAAK;AAAA,MACzB,CAAC,QAAQ,IAAI,kBAAkB;AAAA,IACjC;AAEA,QAAI,UAAU,IAAI;AAChB,aAAO;AAAA,IACT;AACA,UAAM,aAAkB;AAAA,MACtB,GAAG,KAAK,KAAK;AAAA,MACb,eAAe;AAAA,IACjB;AAEA,UAAM,UAAU;AAAA,MACd,GAAG,KAAK,MAAM,GAAG,KAAK;AAAA,MACtB;AAAA,MACA,GAAG,KAAK,MAAM,QAAQ,CAAC;AAAA,IACzB;AAEA,SAAK,qBAAqB,SAAS,oBAAoB;AAAA,MACrD;AAAA,MACA,aAAa;AAAA,IACf,CAAC;AAED,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,iBAAiB,kBAAoC;AACzD,WAAO,KAAK,gBAAgB;AAAA,MAC1B;AAAA,MACA;AAAA,QACE,IAAI,iBAAiB;AAAA,QACrB,QAAQ,iBAAiB;AAAA,QACzB,MAAM,aAAa;AAAA,QACnB,aAAa;AAAA,UACX,IAAI,iBAAiB;AAAA,UACrB,oBAAoB,iBAAiB;AAAA,UACrC,OAAO;AAAA,YACL,SAAS,iBAAiB,MAAM;AAAA,YAChC,SAAS,iBAAiB,MAAM;AAAA,YAChC,MAAM,iBAAiB,MAAM;AAAA,YAC7B,aAAa,iBAAiB,MAAM;AAAA,YACpC,OAAO,iBAAiB,MAAM;AAAA,YAC9B,UAAU,iBAAiB,MAAM;AAAA,UACnC;AAAA,QACF;AAAA,MACF;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;AAEA,IAAO,wBAAQ;","names":[]}
\ No newline at end of file
diff --git a/dist/chunk-OSEZFHQ3.mjs b/dist/chunk-OSEZFHQ3.mjs
deleted file mode 100644
index 55c15584ccfeddde346edd75e9dd1ab406d98aba..0000000000000000000000000000000000000000
--- a/dist/chunk-OSEZFHQ3.mjs
+++ /dev/null
@@ -1,343 +0,0 @@
-import {
-  __privateAdd,
-  __privateGet,
-  __privateSet
-} from "./chunk-XUI43LEZ.mjs";
-
-// src/token-prices-service/codefi-v2.ts
-import { handleFetch } from "@metamask/controller-utils";
-import { hexToNumber } from "@metamask/utils";
-import {
-  circuitBreaker,
-  ConsecutiveBreaker,
-  ExponentialBackoff,
-  handleAll,
-  retry,
-  wrap,
-  CircuitState
-} from "cockatiel";
-var SUPPORTED_CURRENCIES = [
-  // Bitcoin
-  "btc",
-  // Ether
-  "eth",
-  // Litecoin
-  "ltc",
-  // Bitcoin Cash
-  "bch",
-  // Binance Coin
-  "bnb",
-  // EOS
-  "eos",
-  // XRP
-  "xrp",
-  // Lumens
-  "xlm",
-  // Chainlink
-  "link",
-  // Polkadot
-  "dot",
-  // Yearn.finance
-  "yfi",
-  // US Dollar
-  "usd",
-  // United Arab Emirates Dirham
-  "aed",
-  // Argentine Peso
-  "ars",
-  // Australian Dollar
-  "aud",
-  // Bangladeshi Taka
-  "bdt",
-  // Bahraini Dinar
-  "bhd",
-  // Bermudian Dollar
-  "bmd",
-  // Brazil Real
-  "brl",
-  // Canadian Dollar
-  "cad",
-  // Swiss Franc
-  "chf",
-  // Chilean Peso
-  "clp",
-  // Chinese Yuan
-  "cny",
-  // Czech Koruna
-  "czk",
-  // Danish Krone
-  "dkk",
-  // Euro
-  "eur",
-  // British Pound Sterling
-  "gbp",
-  // Hong Kong Dollar
-  "hkd",
-  // Hungarian Forint
-  "huf",
-  // Indonesian Rupiah
-  "idr",
-  // Israeli New Shekel
-  "ils",
-  // Indian Rupee
-  "inr",
-  // Japanese Yen
-  "jpy",
-  // South Korean Won
-  "krw",
-  // Kuwaiti Dinar
-  "kwd",
-  // Sri Lankan Rupee
-  "lkr",
-  // Burmese Kyat
-  "mmk",
-  // Mexican Peso
-  "mxn",
-  // Malaysian Ringgit
-  "myr",
-  // Nigerian Naira
-  "ngn",
-  // Norwegian Krone
-  "nok",
-  // New Zealand Dollar
-  "nzd",
-  // Philippine Peso
-  "php",
-  // Pakistani Rupee
-  "pkr",
-  // Polish Zloty
-  "pln",
-  // Russian Ruble
-  "rub",
-  // Saudi Riyal
-  "sar",
-  // Swedish Krona
-  "sek",
-  // Singapore Dollar
-  "sgd",
-  // Thai Baht
-  "thb",
-  // Turkish Lira
-  "try",
-  // New Taiwan Dollar
-  "twd",
-  // Ukrainian hryvnia
-  "uah",
-  // Venezuelan bolívar fuerte
-  "vef",
-  // Vietnamese đồng
-  "vnd",
-  // South African Rand
-  "zar",
-  // IMF Special Drawing Rights
-  "xdr",
-  // Silver - Troy Ounce
-  "xag",
-  // Gold - Troy Ounce
-  "xau",
-  // Bits
-  "bits",
-  // Satoshi
-  "sats"
-];
-var SUPPORTED_CHAIN_IDS = [
-  // Ethereum Mainnet
-  "0x1",
-  // OP Mainnet
-  "0xa",
-  // Cronos Mainnet
-  "0x19",
-  // BNB Smart Chain Mainnet
-  "0x38",
-  // Syscoin Mainnet
-  "0x39",
-  // OKXChain Mainnet
-  "0x42",
-  // Hoo Smart Chain
-  "0x46",
-  // Meter Mainnet
-  "0x52",
-  // TomoChain
-  "0x58",
-  // Gnosis
-  "0x64",
-  // Velas EVM Mainnet
-  "0x6a",
-  // Fuse Mainnet
-  "0x7a",
-  // Huobi ECO Chain Mainnet
-  "0x80",
-  // Polygon Mainnet
-  "0x89",
-  // Fantom Opera
-  "0xfa",
-  // Boba Network
-  "0x120",
-  // KCC Mainnet
-  "0x141",
-  // zkSync Era Mainnet
-  "0x144",
-  // Theta Mainnet
-  "0x169",
-  // Metis Andromeda Mainnet
-  "0x440",
-  // Moonbeam
-  "0x504",
-  // Moonriver
-  "0x505",
-  // Base
-  "0x2105",
-  // Shiden
-  "0x150",
-  // Smart Bitcoin Cash
-  "0x2710",
-  // Arbitrum One
-  "0xa4b1",
-  // Celo Mainnet
-  "0xa4ec",
-  // Oasis Emerald
-  "0xa516",
-  // Avalanche C-Chain
-  "0xa86a",
-  // Polis Mainnet
-  "0x518af",
-  // Aurora Mainnet
-  "0x4e454152",
-  // Harmony Mainnet Shard 0
-  "0x63564c40",
-  // Linea Mainnet
-  "0xe708"
-];
-var BASE_URL = "https://price-api.metafi.codefi.network/v2";
-var DEFAULT_TOKEN_PRICE_RETRIES = 3;
-var DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES = (1 + DEFAULT_TOKEN_PRICE_RETRIES) * 3;
-var DEFAULT_DEGRADED_THRESHOLD = 5e3;
-var _tokenPricePolicy;
-var CodefiTokenPricesServiceV2 = class {
-  /**
-   * Construct a Codefi Token Price Service.
-   *
-   * @param options - Constructor options
-   * @param options.degradedThreshold - The threshold between "normal" and "degrated" service,
-   * in milliseconds.
-   * @param options.retries - Number of retry attempts for each token price update.
-   * @param options.maximumConsecutiveFailures - The maximum number of consecutive failures
-   * allowed before breaking the circuit and pausing further updates.
-   * @param options.onBreak - An event handler for when the circuit breaks, useful for capturing
-   * metrics about network failures.
-   * @param options.onDegraded - An event handler for when the circuit remains closed, but requests
-   * are failing or resolving too slowly (i.e. resolving more slowly than the `degradedThreshold).
-   * @param options.circuitBreakDuration - The amount of time to wait when the circuit breaks
-   * from too many consecutive failures.
-   */
-  constructor({
-    degradedThreshold = DEFAULT_DEGRADED_THRESHOLD,
-    retries = DEFAULT_TOKEN_PRICE_RETRIES,
-    maximumConsecutiveFailures = DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES,
-    onBreak,
-    onDegraded,
-    circuitBreakDuration = 30 * 60 * 1e3
-  } = {}) {
-    __privateAdd(this, _tokenPricePolicy, void 0);
-    const retryPolicy = retry(handleAll, {
-      maxAttempts: retries,
-      backoff: new ExponentialBackoff()
-    });
-    const circuitBreakerPolicy = circuitBreaker(handleAll, {
-      halfOpenAfter: circuitBreakDuration,
-      breaker: new ConsecutiveBreaker(maximumConsecutiveFailures)
-    });
-    if (onBreak) {
-      circuitBreakerPolicy.onBreak(onBreak);
-    }
-    if (onDegraded) {
-      retryPolicy.onGiveUp(() => {
-        if (circuitBreakerPolicy.state === CircuitState.Closed) {
-          onDegraded();
-        }
-      });
-      retryPolicy.onSuccess(({ duration }) => {
-        if (circuitBreakerPolicy.state === CircuitState.Closed && duration > degradedThreshold) {
-          onDegraded();
-        }
-      });
-    }
-    __privateSet(this, _tokenPricePolicy, wrap(retryPolicy, circuitBreakerPolicy));
-  }
-  /**
-   * Retrieves prices in the given currency for the tokens identified by the
-   * given addresses which are expected to live on the given chain.
-   *
-   * @param args - The arguments to function.
-   * @param args.chainId - An EIP-155 chain ID.
-   * @param args.tokenAddresses - Addresses for tokens that live on the chain.
-   * @param args.currency - The desired currency of the token prices.
-   * @returns The prices for the requested tokens.
-   */
-  async fetchTokenPrices({
-    chainId,
-    tokenAddresses,
-    currency
-  }) {
-    const chainIdAsNumber = hexToNumber(chainId);
-    const url = new URL(`${BASE_URL}/chains/${chainIdAsNumber}/spot-prices`);
-    url.searchParams.append("tokenAddresses", tokenAddresses.join(","));
-    url.searchParams.append("vsCurrency", currency);
-    const pricesByCurrencyByTokenAddress = await __privateGet(this, _tokenPricePolicy).execute(
-      () => handleFetch(url, { headers: { "Cache-Control": "no-cache" } })
-    );
-    return tokenAddresses.reduce(
-      (obj, tokenAddress) => {
-        const lowercasedTokenAddress = tokenAddress.toLowerCase();
-        const lowercasedCurrency = currency.toLowerCase();
-        const price = pricesByCurrencyByTokenAddress[lowercasedTokenAddress]?.[lowercasedCurrency];
-        if (!price) {
-          console.error(
-            `Could not find price for "${tokenAddress}" in "${currency}"`
-          );
-        }
-        const tokenPrice = {
-          tokenAddress,
-          value: price,
-          currency
-        };
-        return {
-          ...obj,
-          ...tokenPrice.value !== void 0 ? { [tokenAddress]: tokenPrice } : {}
-        };
-      },
-      {}
-    );
-  }
-  /**
-   * Type guard for whether the API can return token prices for the given chain
-   * ID.
-   *
-   * @param chainId - The chain ID to check.
-   * @returns True if the API supports the chain ID, false otherwise.
-   */
-  validateChainIdSupported(chainId) {
-    const supportedChainIds = SUPPORTED_CHAIN_IDS;
-    return typeof chainId === "string" && supportedChainIds.includes(chainId);
-  }
-  /**
-   * Type guard for whether the API can return token prices in the given
-   * currency.
-   *
-   * @param currency - The currency to check. If a string, can be either
-   * lowercase or uppercase.
-   * @returns True if the API supports the currency, false otherwise.
-   */
-  validateCurrencySupported(currency) {
-    const supportedCurrencies = SUPPORTED_CURRENCIES;
-    return typeof currency === "string" && supportedCurrencies.includes(currency.toLowerCase());
-  }
-};
-_tokenPricePolicy = new WeakMap();
-
-export {
-  SUPPORTED_CURRENCIES,
-  SUPPORTED_CHAIN_IDS,
-  CodefiTokenPricesServiceV2
-};
-//# sourceMappingURL=chunk-OSEZFHQ3.mjs.map
\ No newline at end of file
diff --git a/dist/chunk-OSEZFHQ3.mjs.map b/dist/chunk-OSEZFHQ3.mjs.map
deleted file mode 100644
index 047eeadba53ae8a3ba858edd07db96cb99d3db5f..0000000000000000000000000000000000000000
--- a/dist/chunk-OSEZFHQ3.mjs.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["../src/token-prices-service/codefi-v2.ts"],"sourcesContent":["import { handleFetch } from '@metamask/controller-utils';\nimport type { Hex } from '@metamask/utils';\nimport { hexToNumber } from '@metamask/utils';\nimport {\n  circuitBreaker,\n  ConsecutiveBreaker,\n  ExponentialBackoff,\n  handleAll,\n  type IPolicy,\n  retry,\n  wrap,\n  CircuitState,\n} from 'cockatiel';\n\nimport type {\n  AbstractTokenPricesService,\n  TokenPrice,\n  TokenPricesByTokenAddress,\n} from './abstract-token-prices-service';\n\n/**\n * The shape of the data that the /spot-prices endpoint returns.\n */\ntype SpotPricesEndpointData<\n  TokenAddress extends Hex,\n  Currency extends string,\n> = Record<TokenAddress, Record<Currency, number>>;\n\n/**\n * The list of currencies that can be supplied as the `vsCurrency` parameter to\n * the `/spot-prices` endpoint, in lowercase form.\n */\nexport const SUPPORTED_CURRENCIES = [\n  // Bitcoin\n  'btc',\n  // Ether\n  'eth',\n  // Litecoin\n  'ltc',\n  // Bitcoin Cash\n  'bch',\n  // Binance Coin\n  'bnb',\n  // EOS\n  'eos',\n  // XRP\n  'xrp',\n  // Lumens\n  'xlm',\n  // Chainlink\n  'link',\n  // Polkadot\n  'dot',\n  // Yearn.finance\n  'yfi',\n  // US Dollar\n  'usd',\n  // United Arab Emirates Dirham\n  'aed',\n  // Argentine Peso\n  'ars',\n  // Australian Dollar\n  'aud',\n  // Bangladeshi Taka\n  'bdt',\n  // Bahraini Dinar\n  'bhd',\n  // Bermudian Dollar\n  'bmd',\n  // Brazil Real\n  'brl',\n  // Canadian Dollar\n  'cad',\n  // Swiss Franc\n  'chf',\n  // Chilean Peso\n  'clp',\n  // Chinese Yuan\n  'cny',\n  // Czech Koruna\n  'czk',\n  // Danish Krone\n  'dkk',\n  // Euro\n  'eur',\n  // British Pound Sterling\n  'gbp',\n  // Hong Kong Dollar\n  'hkd',\n  // Hungarian Forint\n  'huf',\n  // Indonesian Rupiah\n  'idr',\n  // Israeli New Shekel\n  'ils',\n  // Indian Rupee\n  'inr',\n  // Japanese Yen\n  'jpy',\n  // South Korean Won\n  'krw',\n  // Kuwaiti Dinar\n  'kwd',\n  // Sri Lankan Rupee\n  'lkr',\n  // Burmese Kyat\n  'mmk',\n  // Mexican Peso\n  'mxn',\n  // Malaysian Ringgit\n  'myr',\n  // Nigerian Naira\n  'ngn',\n  // Norwegian Krone\n  'nok',\n  // New Zealand Dollar\n  'nzd',\n  // Philippine Peso\n  'php',\n  // Pakistani Rupee\n  'pkr',\n  // Polish Zloty\n  'pln',\n  // Russian Ruble\n  'rub',\n  // Saudi Riyal\n  'sar',\n  // Swedish Krona\n  'sek',\n  // Singapore Dollar\n  'sgd',\n  // Thai Baht\n  'thb',\n  // Turkish Lira\n  'try',\n  // New Taiwan Dollar\n  'twd',\n  // Ukrainian hryvnia\n  'uah',\n  // Venezuelan bolívar fuerte\n  'vef',\n  // Vietnamese đồng\n  'vnd',\n  // South African Rand\n  'zar',\n  // IMF Special Drawing Rights\n  'xdr',\n  // Silver - Troy Ounce\n  'xag',\n  // Gold - Troy Ounce\n  'xau',\n  // Bits\n  'bits',\n  // Satoshi\n  'sats',\n] as const;\n\n/**\n * A currency that can be supplied as the `vsCurrency` parameter to\n * the `/spot-prices` endpoint. Covers both uppercase and lowercase versions.\n */\ntype SupportedCurrency =\n  | (typeof SUPPORTED_CURRENCIES)[number]\n  | Uppercase<(typeof SUPPORTED_CURRENCIES)[number]>;\n\n/**\n * The list of chain IDs that can be supplied in the URL for the `/spot-prices`\n * endpoint, but in hexadecimal form (for consistency with how we represent\n * chain IDs in other places).\n * @see Used by {@link CodefiTokenPricesServiceV2} to validate that a given chain ID is supported by V2 of the Codefi Price API.\n */\nexport const SUPPORTED_CHAIN_IDS = [\n  // Ethereum Mainnet\n  '0x1',\n  // OP Mainnet\n  '0xa',\n  // Cronos Mainnet\n  '0x19',\n  // BNB Smart Chain Mainnet\n  '0x38',\n  // Syscoin Mainnet\n  '0x39',\n  // OKXChain Mainnet\n  '0x42',\n  // Hoo Smart Chain\n  '0x46',\n  // Meter Mainnet\n  '0x52',\n  // TomoChain\n  '0x58',\n  // Gnosis\n  '0x64',\n  // Velas EVM Mainnet\n  '0x6a',\n  // Fuse Mainnet\n  '0x7a',\n  // Huobi ECO Chain Mainnet\n  '0x80',\n  // Polygon Mainnet\n  '0x89',\n  // Fantom Opera\n  '0xfa',\n  // Boba Network\n  '0x120',\n  // KCC Mainnet\n  '0x141',\n  // zkSync Era Mainnet\n  '0x144',\n  // Theta Mainnet\n  '0x169',\n  // Metis Andromeda Mainnet\n  '0x440',\n  // Moonbeam\n  '0x504',\n  // Moonriver\n  '0x505',\n  // Base\n  '0x2105',\n  // Shiden\n  '0x150',\n  // Smart Bitcoin Cash\n  '0x2710',\n  // Arbitrum One\n  '0xa4b1',\n  // Celo Mainnet\n  '0xa4ec',\n  // Oasis Emerald\n  '0xa516',\n  // Avalanche C-Chain\n  '0xa86a',\n  // Polis Mainnet\n  '0x518af',\n  // Aurora Mainnet\n  '0x4e454152',\n  // Harmony Mainnet Shard 0\n  '0x63564c40',\n  // Linea Mainnet\n  '0xe708',\n] as const;\n\n/**\n * A chain ID that can be supplied in the URL for the `/spot-prices` endpoint,\n * but in hexadecimal form (for consistency with how we represent chain IDs in\n * other places).\n */\ntype SupportedChainId = (typeof SUPPORTED_CHAIN_IDS)[number];\n\n/**\n * All requests to V2 of the Price API start with this.\n */\nconst BASE_URL = 'https://price-api.metafi.codefi.network/v2';\n\nconst DEFAULT_TOKEN_PRICE_RETRIES = 3;\n// Each update attempt will result (1 + retries) calls if the server is down\nconst DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES =\n  (1 + DEFAULT_TOKEN_PRICE_RETRIES) * 3;\n\nconst DEFAULT_DEGRADED_THRESHOLD = 5_000;\n\n/**\n * This version of the token prices service uses V2 of the Codefi Price API to\n * fetch token prices.\n */\nexport class CodefiTokenPricesServiceV2\n  implements\n    AbstractTokenPricesService<SupportedChainId, Hex, SupportedCurrency>\n{\n  #tokenPricePolicy: IPolicy;\n\n  /**\n   * Construct a Codefi Token Price Service.\n   *\n   * @param options - Constructor options\n   * @param options.degradedThreshold - The threshold between \"normal\" and \"degrated\" service,\n   * in milliseconds.\n   * @param options.retries - Number of retry attempts for each token price update.\n   * @param options.maximumConsecutiveFailures - The maximum number of consecutive failures\n   * allowed before breaking the circuit and pausing further updates.\n   * @param options.onBreak - An event handler for when the circuit breaks, useful for capturing\n   * metrics about network failures.\n   * @param options.onDegraded - An event handler for when the circuit remains closed, but requests\n   * are failing or resolving too slowly (i.e. resolving more slowly than the `degradedThreshold).\n   * @param options.circuitBreakDuration - The amount of time to wait when the circuit breaks\n   * from too many consecutive failures.\n   */\n  constructor({\n    degradedThreshold = DEFAULT_DEGRADED_THRESHOLD,\n    retries = DEFAULT_TOKEN_PRICE_RETRIES,\n    maximumConsecutiveFailures = DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES,\n    onBreak,\n    onDegraded,\n    circuitBreakDuration = 30 * 60 * 1000,\n  }: {\n    degradedThreshold?: number;\n    retries?: number;\n    maximumConsecutiveFailures?: number;\n    onBreak?: () => void;\n    onDegraded?: () => void;\n    circuitBreakDuration?: number;\n  } = {}) {\n    // Construct a policy that will retry each update, and halt further updates\n    // for a certain period after too many consecutive failures.\n    const retryPolicy = retry(handleAll, {\n      maxAttempts: retries,\n      backoff: new ExponentialBackoff(),\n    });\n    const circuitBreakerPolicy = circuitBreaker(handleAll, {\n      halfOpenAfter: circuitBreakDuration,\n      breaker: new ConsecutiveBreaker(maximumConsecutiveFailures),\n    });\n    if (onBreak) {\n      circuitBreakerPolicy.onBreak(onBreak);\n    }\n    if (onDegraded) {\n      retryPolicy.onGiveUp(() => {\n        if (circuitBreakerPolicy.state === CircuitState.Closed) {\n          onDegraded();\n        }\n      });\n      retryPolicy.onSuccess(({ duration }) => {\n        if (\n          circuitBreakerPolicy.state === CircuitState.Closed &&\n          duration > degradedThreshold\n        ) {\n          onDegraded();\n        }\n      });\n    }\n    this.#tokenPricePolicy = wrap(retryPolicy, circuitBreakerPolicy);\n  }\n\n  /**\n   * Retrieves prices in the given currency for the tokens identified by the\n   * given addresses which are expected to live on the given chain.\n   *\n   * @param args - The arguments to function.\n   * @param args.chainId - An EIP-155 chain ID.\n   * @param args.tokenAddresses - Addresses for tokens that live on the chain.\n   * @param args.currency - The desired currency of the token prices.\n   * @returns The prices for the requested tokens.\n   */\n  async fetchTokenPrices({\n    chainId,\n    tokenAddresses,\n    currency,\n  }: {\n    chainId: SupportedChainId;\n    tokenAddresses: Hex[];\n    currency: SupportedCurrency;\n  }): Promise<Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>> {\n    const chainIdAsNumber = hexToNumber(chainId);\n\n    const url = new URL(`${BASE_URL}/chains/${chainIdAsNumber}/spot-prices`);\n    url.searchParams.append('tokenAddresses', tokenAddresses.join(','));\n    url.searchParams.append('vsCurrency', currency);\n\n    const pricesByCurrencyByTokenAddress: SpotPricesEndpointData<\n      Lowercase<Hex>,\n      Lowercase<SupportedCurrency>\n    > = await this.#tokenPricePolicy.execute(() =>\n      handleFetch(url, { headers: { 'Cache-Control': 'no-cache' } }),\n    );\n\n    return tokenAddresses.reduce(\n      (\n        obj: Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>,\n        tokenAddress,\n      ) => {\n        // The Price API lowercases both currency and token addresses, so we have\n        // to keep track of them and make sure we return the original versions.\n        const lowercasedTokenAddress =\n          tokenAddress.toLowerCase() as Lowercase<Hex>;\n        const lowercasedCurrency =\n          currency.toLowerCase() as Lowercase<SupportedCurrency>;\n\n        const price =\n          pricesByCurrencyByTokenAddress[lowercasedTokenAddress]?.[\n            lowercasedCurrency\n          ];\n\n        if (!price) {\n          // console error instead of throwing to not interrupt the fetching of other tokens in case just one fails\n          console.error(\n            `Could not find price for \"${tokenAddress}\" in \"${currency}\"`,\n          );\n        }\n\n        const tokenPrice: TokenPrice<Hex, SupportedCurrency> = {\n          tokenAddress,\n          value: price,\n          currency,\n        };\n\n        return {\n          ...obj,\n          ...(tokenPrice.value !== undefined\n            ? { [tokenAddress]: tokenPrice }\n            : {}),\n        };\n      },\n      {},\n    ) as Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>;\n  }\n\n  /**\n   * Type guard for whether the API can return token prices for the given chain\n   * ID.\n   *\n   * @param chainId - The chain ID to check.\n   * @returns True if the API supports the chain ID, false otherwise.\n   */\n  validateChainIdSupported(chainId: unknown): chainId is SupportedChainId {\n    const supportedChainIds: readonly string[] = SUPPORTED_CHAIN_IDS;\n    return typeof chainId === 'string' && supportedChainIds.includes(chainId);\n  }\n\n  /**\n   * Type guard for whether the API can return token prices in the given\n   * currency.\n   *\n   * @param currency - The currency to check. If a string, can be either\n   * lowercase or uppercase.\n   * @returns True if the API supports the currency, false otherwise.\n   */\n  validateCurrencySupported(currency: unknown): currency is SupportedCurrency {\n    const supportedCurrencies: readonly string[] = SUPPORTED_CURRENCIES;\n    return (\n      typeof currency === 'string' &&\n      supportedCurrencies.includes(currency.toLowerCase())\n    );\n  }\n}\n"],"mappings":"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","names":[]}
\ No newline at end of file
diff --git a/dist/chunk-OWTCG2N3.mjs b/dist/chunk-OWTCG2N3.mjs
deleted file mode 100644
index 9a31f72285f62ddd981dd41a0498c3110f59d737..0000000000000000000000000000000000000000
--- a/dist/chunk-OWTCG2N3.mjs
+++ /dev/null
@@ -1,418 +0,0 @@
-import {
-  fetchExchangeRate
-} from "./chunk-PWZE6KJV.mjs";
-import {
-  TOKEN_PRICES_BATCH_SIZE,
-  reduceInBatchesSerially
-} from "./chunk-X5PLVMOQ.mjs";
-import {
-  __privateAdd,
-  __privateGet,
-  __privateMethod,
-  __privateSet
-} from "./chunk-XUI43LEZ.mjs";
-
-// src/TokenRatesController.ts
-import {
-  safelyExecute,
-  toChecksumHexAddress,
-  FALL_BACK_VS_CURRENCY,
-  toHex
-} from "@metamask/controller-utils";
-import { StaticIntervalPollingControllerV1 } from "@metamask/polling-controller";
-import { createDeferredPromise } from "@metamask/utils";
-import { isEqual } from "lodash";
-async function getCurrencyConversionRate({
-  from,
-  to
-}) {
-  const includeUSDRate = false;
-  try {
-    const result = await fetchExchangeRate(
-      to,
-      from,
-      includeUSDRate
-    );
-    return result.conversionRate;
-  } catch (error) {
-    if (error instanceof Error && error.message.includes("market does not exist for this coin pair")) {
-      return null;
-    }
-    throw error;
-  }
-}
-var _pollState, _tokenPricesService, _inProcessExchangeRateUpdates, _getTokenAddresses, getTokenAddresses_fn, _stopPoll, stopPoll_fn, _poll, poll_fn, _fetchAndMapExchangeRates, fetchAndMapExchangeRates_fn, _fetchAndMapExchangeRatesForSupportedNativeCurrency, fetchAndMapExchangeRatesForSupportedNativeCurrency_fn, _fetchAndMapExchangeRatesForUnsupportedNativeCurrency, fetchAndMapExchangeRatesForUnsupportedNativeCurrency_fn;
-var TokenRatesController = class extends StaticIntervalPollingControllerV1 {
-  /**
-   * Creates a TokenRatesController instance.
-   *
-   * @param options - The controller options.
-   * @param options.interval - The polling interval in ms
-   * @param options.threshold - The duration in ms before metadata fetched from CoinGecko is considered stale
-   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.
-   * @param options.chainId - The chain ID of the current network.
-   * @param options.ticker - The ticker for the current network.
-   * @param options.selectedAddress - The current selected address.
-   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
-   * @param options.onTokensStateChange - Allows subscribing to token controller state changes.
-   * @param options.onNetworkStateChange - Allows subscribing to network state changes.
-   * @param options.tokenPricesService - An object in charge of retrieving token prices.
-   * @param config - Initial options used to configure this controller.
-   * @param state - Initial state to set on this controller.
-   */
-  constructor({
-    interval = 3 * 60 * 1e3,
-    threshold = 6 * 60 * 60 * 1e3,
-    getNetworkClientById,
-    chainId: initialChainId,
-    ticker: initialTicker,
-    selectedAddress: initialSelectedAddress,
-    onPreferencesStateChange,
-    onTokensStateChange,
-    onNetworkStateChange,
-    tokenPricesService
-  }, config, state) {
-    super(config, state);
-    /**
-     * Get the user's tokens for the given chain.
-     *
-     * @param chainId - The chain ID.
-     * @returns The list of tokens addresses for the current chain
-     */
-    __privateAdd(this, _getTokenAddresses);
-    /**
-     * Clear the active polling timer, if present.
-     */
-    __privateAdd(this, _stopPoll);
-    /**
-     * Poll for exchange rate updates.
-     */
-    __privateAdd(this, _poll);
-    /**
-     * Uses the token prices service to retrieve exchange rates for tokens in a
-     * particular currency.
-     *
-     * If the price API does not support the given chain ID, returns an empty
-     * object.
-     *
-     * If the price API does not support the given currency, retrieves exchange
-     * rates in a known currency instead, then converts those rates using the
-     * exchange rate between the known currency and desired currency.
-     *
-     * @param args - The arguments to this function.
-     * @param args.tokenAddresses - Addresses for tokens.
-     * @param args.chainId - The EIP-155 ID of the chain where the tokens live.
-     * @param args.nativeCurrency - The native currency in which to request
-     * exchange rates.
-     * @returns A map from token address to its exchange rate in the native
-     * currency, or an empty map if no exchange rates can be obtained for the
-     * chain ID.
-     */
-    __privateAdd(this, _fetchAndMapExchangeRates);
-    /**
-     * Retrieves prices in the given currency for the given tokens on the given
-     * chain. Ensures that token addresses are checksum addresses.
-     *
-     * @param args - The arguments to this function.
-     * @param args.tokenAddresses - Addresses for tokens.
-     * @param args.chainId - The EIP-155 ID of the chain where the tokens live.
-     * @param args.nativeCurrency - The native currency in which to request
-     * prices.
-     * @returns A map of the token addresses (as checksums) to their prices in the
-     * native currency.
-     */
-    __privateAdd(this, _fetchAndMapExchangeRatesForSupportedNativeCurrency);
-    /**
-     * If the price API does not support a given native currency, then we need to
-     * convert it to a fallback currency and feed that currency into the price
-     * API, then convert the prices to our desired native currency.
-     *
-     * @param args - The arguments to this function.
-     * @param args.tokenAddresses - Addresses for tokens.
-     * @param args.nativeCurrency - The native currency in which to request
-     * prices.
-     * @returns A map of the token addresses (as checksums) to their prices in the
-     * native currency.
-     */
-    __privateAdd(this, _fetchAndMapExchangeRatesForUnsupportedNativeCurrency);
-    __privateAdd(this, _pollState, "Inactive" /* Inactive */);
-    __privateAdd(this, _tokenPricesService, void 0);
-    __privateAdd(this, _inProcessExchangeRateUpdates, {});
-    /**
-     * Name of this controller used during composition
-     */
-    this.name = "TokenRatesController";
-    this.defaultConfig = {
-      interval,
-      threshold,
-      disabled: false,
-      nativeCurrency: initialTicker,
-      chainId: initialChainId,
-      selectedAddress: initialSelectedAddress,
-      allTokens: {},
-      // TODO: initialize these correctly, maybe as part of BaseControllerV2 migration
-      allDetectedTokens: {}
-    };
-    this.defaultState = {
-      contractExchangeRates: {},
-      contractExchangeRatesByChainId: {}
-    };
-    this.initialize();
-    this.setIntervalLength(interval);
-    this.getNetworkClientById = getNetworkClientById;
-    __privateSet(this, _tokenPricesService, tokenPricesService);
-    if (config?.disabled) {
-      this.configure({ disabled: true }, false, false);
-    }
-    onPreferencesStateChange(async ({ selectedAddress }) => {
-      if (this.config.selectedAddress !== selectedAddress) {
-        this.configure({ selectedAddress });
-        if (__privateGet(this, _pollState) === "Active" /* Active */) {
-          await this.updateExchangeRates();
-        }
-      }
-    });
-    onTokensStateChange(async ({ allTokens, allDetectedTokens }) => {
-      const previousTokenAddresses = __privateMethod(this, _getTokenAddresses, getTokenAddresses_fn).call(this, this.config.chainId);
-      this.configure({ allTokens, allDetectedTokens });
-      const newTokenAddresses = __privateMethod(this, _getTokenAddresses, getTokenAddresses_fn).call(this, this.config.chainId);
-      if (!isEqual(previousTokenAddresses, newTokenAddresses) && __privateGet(this, _pollState) === "Active" /* Active */) {
-        await this.updateExchangeRates();
-      }
-    });
-    onNetworkStateChange(async ({ providerConfig }) => {
-      const { chainId, ticker } = providerConfig;
-      if (this.config.chainId !== chainId || this.config.nativeCurrency !== ticker) {
-        this.update({ contractExchangeRates: {} });
-        this.configure({ chainId, nativeCurrency: ticker });
-        if (__privateGet(this, _pollState) === "Active" /* Active */) {
-          await this.updateExchangeRates();
-        }
-      }
-    });
-  }
-  /**
-   * Start (or restart) polling.
-   */
-  async start() {
-    __privateMethod(this, _stopPoll, stopPoll_fn).call(this);
-    __privateSet(this, _pollState, "Active" /* Active */);
-    await __privateMethod(this, _poll, poll_fn).call(this);
-  }
-  /**
-   * Stop polling.
-   */
-  stop() {
-    __privateMethod(this, _stopPoll, stopPoll_fn).call(this);
-    __privateSet(this, _pollState, "Inactive" /* Inactive */);
-  }
-  /**
-   * Updates exchange rates for all tokens.
-   */
-  async updateExchangeRates() {
-    const { chainId, nativeCurrency } = this.config;
-    await this.updateExchangeRatesByChainId({
-      chainId,
-      nativeCurrency
-    });
-  }
-  /**
-   * Updates exchange rates for all tokens.
-   *
-   * @param options - The options to fetch exchange rates.
-   * @param options.chainId - The chain ID.
-   * @param options.nativeCurrency - The ticker for the chain.
-   */
-  async updateExchangeRatesByChainId({
-    chainId,
-    nativeCurrency
-  }) {
-    if (this.disabled) {
-      return;
-    }
-    const tokenAddresses = __privateMethod(this, _getTokenAddresses, getTokenAddresses_fn).call(this, chainId);
-    if (tokenAddresses.length === 0) {
-      return;
-    }
-    const updateKey = `${chainId}:${nativeCurrency}`;
-    if (updateKey in __privateGet(this, _inProcessExchangeRateUpdates)) {
-      await __privateGet(this, _inProcessExchangeRateUpdates)[updateKey];
-      return;
-    }
-    const {
-      promise: inProgressUpdate,
-      resolve: updateSucceeded,
-      reject: updateFailed
-    } = createDeferredPromise({ suppressUnhandledRejection: true });
-    __privateGet(this, _inProcessExchangeRateUpdates)[updateKey] = inProgressUpdate;
-    try {
-      const newContractExchangeRates = await __privateMethod(this, _fetchAndMapExchangeRates, fetchAndMapExchangeRates_fn).call(this, {
-        tokenAddresses,
-        chainId,
-        nativeCurrency
-      });
-      const existingContractExchangeRates = this.state.contractExchangeRates;
-      const updatedContractExchangeRates = chainId === this.config.chainId && nativeCurrency === this.config.nativeCurrency ? newContractExchangeRates : existingContractExchangeRates;
-      const existingContractExchangeRatesForChainId = this.state.contractExchangeRatesByChainId[chainId] ?? {};
-      const updatedContractExchangeRatesForChainId = {
-        ...this.state.contractExchangeRatesByChainId,
-        [chainId]: {
-          ...existingContractExchangeRatesForChainId,
-          [nativeCurrency]: {
-            ...existingContractExchangeRatesForChainId[nativeCurrency],
-            ...newContractExchangeRates
-          }
-        }
-      };
-      this.update({
-        contractExchangeRates: updatedContractExchangeRates,
-        contractExchangeRatesByChainId: updatedContractExchangeRatesForChainId
-      });
-      updateSucceeded();
-    } catch (error) {
-      updateFailed(error);
-      throw error;
-    } finally {
-      delete __privateGet(this, _inProcessExchangeRateUpdates)[updateKey];
-    }
-  }
-  /**
-   * Updates token rates for the given networkClientId
-   *
-   * @param networkClientId - The network client ID used to get a ticker value.
-   * @returns The controller state.
-   */
-  async _executePoll(networkClientId) {
-    const networkClient = this.getNetworkClientById(networkClientId);
-    await this.updateExchangeRatesByChainId({
-      chainId: networkClient.configuration.chainId,
-      nativeCurrency: networkClient.configuration.ticker
-    });
-  }
-};
-_pollState = new WeakMap();
-_tokenPricesService = new WeakMap();
-_inProcessExchangeRateUpdates = new WeakMap();
-_getTokenAddresses = new WeakSet();
-getTokenAddresses_fn = function(chainId) {
-  const { allTokens, allDetectedTokens } = this.config;
-  const tokens = allTokens[chainId]?.[this.config.selectedAddress] || [];
-  const detectedTokens = allDetectedTokens[chainId]?.[this.config.selectedAddress] || [];
-  return [
-    ...new Set(
-      [...tokens, ...detectedTokens].map(
-        (token) => toHex(toChecksumHexAddress(token.address))
-      )
-    )
-  ].sort();
-};
-_stopPoll = new WeakSet();
-stopPoll_fn = function() {
-  if (this.handle) {
-    clearTimeout(this.handle);
-  }
-};
-_poll = new WeakSet();
-poll_fn = async function() {
-  await safelyExecute(() => this.updateExchangeRates());
-  this.handle = setTimeout(() => {
-    __privateMethod(this, _poll, poll_fn).call(this);
-  }, this.config.interval);
-};
-_fetchAndMapExchangeRates = new WeakSet();
-fetchAndMapExchangeRates_fn = async function({
-  tokenAddresses,
-  chainId,
-  nativeCurrency
-}) {
-  if (!__privateGet(this, _tokenPricesService).validateChainIdSupported(chainId)) {
-    return tokenAddresses.reduce((obj, tokenAddress) => {
-      return {
-        ...obj,
-        [tokenAddress]: void 0
-      };
-    }, {});
-  }
-  if (__privateGet(this, _tokenPricesService).validateCurrencySupported(nativeCurrency)) {
-    return await __privateMethod(this, _fetchAndMapExchangeRatesForSupportedNativeCurrency, fetchAndMapExchangeRatesForSupportedNativeCurrency_fn).call(this, {
-      tokenAddresses,
-      chainId,
-      nativeCurrency
-    });
-  }
-  return await __privateMethod(this, _fetchAndMapExchangeRatesForUnsupportedNativeCurrency, fetchAndMapExchangeRatesForUnsupportedNativeCurrency_fn).call(this, {
-    tokenAddresses,
-    nativeCurrency
-  });
-};
-_fetchAndMapExchangeRatesForSupportedNativeCurrency = new WeakSet();
-fetchAndMapExchangeRatesForSupportedNativeCurrency_fn = async function({
-  tokenAddresses,
-  chainId,
-  nativeCurrency
-}) {
-  const tokenPricesByTokenAddress = await reduceInBatchesSerially({
-    values: [...tokenAddresses].sort(),
-    batchSize: TOKEN_PRICES_BATCH_SIZE,
-    eachBatch: async (allTokenPricesByTokenAddress, batch) => {
-      const tokenPricesByTokenAddressForBatch = await __privateGet(this, _tokenPricesService).fetchTokenPrices({
-        tokenAddresses: batch,
-        chainId,
-        currency: nativeCurrency
-      });
-      return {
-        ...allTokenPricesByTokenAddress,
-        ...tokenPricesByTokenAddressForBatch
-      };
-    },
-    initialResult: {}
-  });
-  return Object.entries(tokenPricesByTokenAddress).reduce(
-    (obj, [tokenAddress, tokenPrice]) => {
-      return {
-        ...obj,
-        [tokenAddress]: tokenPrice?.value
-      };
-    },
-    {}
-  );
-};
-_fetchAndMapExchangeRatesForUnsupportedNativeCurrency = new WeakSet();
-fetchAndMapExchangeRatesForUnsupportedNativeCurrency_fn = async function({
-  tokenAddresses,
-  nativeCurrency
-}) {
-  const [
-    contractExchangeRates,
-    fallbackCurrencyToNativeCurrencyConversionRate
-  ] = await Promise.all([
-    __privateMethod(this, _fetchAndMapExchangeRatesForSupportedNativeCurrency, fetchAndMapExchangeRatesForSupportedNativeCurrency_fn).call(this, {
-      tokenAddresses,
-      chainId: this.config.chainId,
-      nativeCurrency: FALL_BACK_VS_CURRENCY
-    }),
-    getCurrencyConversionRate({
-      from: FALL_BACK_VS_CURRENCY,
-      to: nativeCurrency
-    })
-  ]);
-  if (fallbackCurrencyToNativeCurrencyConversionRate === null) {
-    return {};
-  }
-  return Object.entries(contractExchangeRates).reduce(
-    (obj, [tokenAddress, tokenValue]) => {
-      return {
-        ...obj,
-        [tokenAddress]: tokenValue ? tokenValue * fallbackCurrencyToNativeCurrencyConversionRate : void 0
-      };
-    },
-    {}
-  );
-};
-var TokenRatesController_default = TokenRatesController;
-
-export {
-  TokenRatesController,
-  TokenRatesController_default
-};
-//# sourceMappingURL=chunk-OWTCG2N3.mjs.map
\ No newline at end of file
diff --git a/dist/chunk-OWTCG2N3.mjs.map b/dist/chunk-OWTCG2N3.mjs.map
deleted file mode 100644
index 235d04dbdece248de674c16a6c7b9d4a99ab1a92..0000000000000000000000000000000000000000
--- a/dist/chunk-OWTCG2N3.mjs.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["../src/TokenRatesController.ts"],"sourcesContent":["import type { BaseConfig, BaseState } from '@metamask/base-controller';\nimport {\n  safelyExecute,\n  toChecksumHexAddress,\n  FALL_BACK_VS_CURRENCY,\n  toHex,\n} from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkState,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingControllerV1 } from '@metamask/polling-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { createDeferredPromise, type Hex } from '@metamask/utils';\nimport { isEqual } from 'lodash';\n\nimport { reduceInBatchesSerially, TOKEN_PRICES_BATCH_SIZE } from './assetsUtil';\nimport { fetchExchangeRate as fetchNativeCurrencyExchangeRate } from './crypto-compare';\nimport type { AbstractTokenPricesService } from './token-prices-service/abstract-token-prices-service';\nimport type { TokensState } from './TokensController';\n\n/**\n * @type Token\n *\n * Token representation\n * @property address - Hex address of the token contract\n * @property decimals - Number of decimals the token uses\n * @property symbol - Symbol of the token\n * @property image - Image of the token, url or bit32 image\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface Token {\n  address: string;\n  decimals: number;\n  symbol: string;\n  aggregators?: string[];\n  image?: string;\n  balanceError?: unknown;\n  isERC721?: boolean;\n  name?: string;\n}\n\n/**\n * @type TokenRatesConfig\n *\n * Token rates controller configuration\n * @property interval - Polling interval used to fetch new token rates\n * @property nativeCurrency - Current native currency selected to use base of rates\n * @property chainId - Current network chainId\n * @property tokens - List of tokens to track exchange rates for\n * @property threshold - Threshold to invalidate the supportedChains\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface TokenRatesConfig extends BaseConfig {\n  interval: number;\n  nativeCurrency: string;\n  chainId: Hex;\n  selectedAddress: string;\n  allTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  allDetectedTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  threshold: number;\n}\n\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface ContractExchangeRates {\n  [address: string]: number | undefined;\n}\n\nenum PollState {\n  Active = 'Active',\n  Inactive = 'Inactive',\n}\n\n/**\n * @type TokenRatesState\n *\n * Token rates controller state\n * @property contractExchangeRates - Hash of token contract addresses to exchange rates (single globally selected chain, will be deprecated soon)\n * @property contractExchangeRatesByChainId - Hash of token contract addresses to exchange rates keyed by chain ID and native currency (ticker)\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface TokenRatesState extends BaseState {\n  contractExchangeRates: ContractExchangeRates;\n  contractExchangeRatesByChainId: Record<\n    Hex,\n    Record<string, ContractExchangeRates>\n  >;\n}\n\n/**\n * Uses the CryptoCompare API to fetch the exchange rate between one currency\n * and another, i.e., the multiplier to apply the amount of one currency in\n * order to convert it to another.\n *\n * @param args - The arguments to this function.\n * @param args.from - The currency to convert from.\n * @param args.to - The currency to convert to.\n * @returns The exchange rate between `fromCurrency` to `toCurrency` if one\n * exists, or null if one does not.\n */\nasync function getCurrencyConversionRate({\n  from,\n  to,\n}: {\n  from: string;\n  to: string;\n}) {\n  const includeUSDRate = false;\n  try {\n    const result = await fetchNativeCurrencyExchangeRate(\n      to,\n      from,\n      includeUSDRate,\n    );\n    return result.conversionRate;\n  } catch (error) {\n    if (\n      error instanceof Error &&\n      error.message.includes('market does not exist for this coin pair')\n    ) {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n * Controller that passively polls on a set interval for token-to-fiat exchange rates\n * for tokens stored in the TokensController\n */\nexport class TokenRatesController extends StaticIntervalPollingControllerV1<\n  TokenRatesConfig,\n  TokenRatesState\n> {\n  private handle?: ReturnType<typeof setTimeout>;\n\n  #pollState = PollState.Inactive;\n\n  #tokenPricesService: AbstractTokenPricesService;\n\n  #inProcessExchangeRateUpdates: Record<`${Hex}:${string}`, Promise<void>> = {};\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokenRatesController';\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  /**\n   * Creates a TokenRatesController instance.\n   *\n   * @param options - The controller options.\n   * @param options.interval - The polling interval in ms\n   * @param options.threshold - The duration in ms before metadata fetched from CoinGecko is considered stale\n   * @param options.getNetworkClientById - Gets the network client with the given id from the NetworkController.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.ticker - The ticker for the current network.\n   * @param options.selectedAddress - The current selected address.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onTokensStateChange - Allows subscribing to token controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network state changes.\n   * @param options.tokenPricesService - An object in charge of retrieving token prices.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      interval = 3 * 60 * 1000,\n      threshold = 6 * 60 * 60 * 1000,\n      getNetworkClientById,\n      chainId: initialChainId,\n      ticker: initialTicker,\n      selectedAddress: initialSelectedAddress,\n      onPreferencesStateChange,\n      onTokensStateChange,\n      onNetworkStateChange,\n      tokenPricesService,\n    }: {\n      interval?: number;\n      threshold?: number;\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n      chainId: Hex;\n      ticker: string;\n      selectedAddress: string;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onTokensStateChange: (\n        listener: (tokensState: TokensState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      tokenPricesService: AbstractTokenPricesService;\n    },\n    config?: Partial<TokenRatesConfig>,\n    state?: Partial<TokenRatesState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval,\n      threshold,\n      disabled: false,\n      nativeCurrency: initialTicker,\n      chainId: initialChainId,\n      selectedAddress: initialSelectedAddress,\n      allTokens: {}, // TODO: initialize these correctly, maybe as part of BaseControllerV2 migration\n      allDetectedTokens: {},\n    };\n\n    this.defaultState = {\n      contractExchangeRates: {},\n      contractExchangeRatesByChainId: {},\n    };\n    this.initialize();\n    this.setIntervalLength(interval);\n    this.getNetworkClientById = getNetworkClientById;\n    this.#tokenPricesService = tokenPricesService;\n\n    if (config?.disabled) {\n      this.configure({ disabled: true }, false, false);\n    }\n\n    onPreferencesStateChange(async ({ selectedAddress }) => {\n      if (this.config.selectedAddress !== selectedAddress) {\n        this.configure({ selectedAddress });\n        if (this.#pollState === PollState.Active) {\n          await this.updateExchangeRates();\n        }\n      }\n    });\n\n    onTokensStateChange(async ({ allTokens, allDetectedTokens }) => {\n      const previousTokenAddresses = this.#getTokenAddresses(\n        this.config.chainId,\n      );\n      this.configure({ allTokens, allDetectedTokens });\n      const newTokenAddresses = this.#getTokenAddresses(this.config.chainId);\n      if (\n        !isEqual(previousTokenAddresses, newTokenAddresses) &&\n        this.#pollState === PollState.Active\n      ) {\n        await this.updateExchangeRates();\n      }\n    });\n\n    onNetworkStateChange(async ({ providerConfig }) => {\n      const { chainId, ticker } = providerConfig;\n      if (\n        this.config.chainId !== chainId ||\n        this.config.nativeCurrency !== ticker\n      ) {\n        this.update({ contractExchangeRates: {} });\n        this.configure({ chainId, nativeCurrency: ticker });\n        if (this.#pollState === PollState.Active) {\n          await this.updateExchangeRates();\n        }\n      }\n    });\n  }\n\n  /**\n   * Get the user's tokens for the given chain.\n   *\n   * @param chainId - The chain ID.\n   * @returns The list of tokens addresses for the current chain\n   */\n  #getTokenAddresses(chainId: Hex): Hex[] {\n    const { allTokens, allDetectedTokens } = this.config;\n    const tokens = allTokens[chainId]?.[this.config.selectedAddress] || [];\n    const detectedTokens =\n      allDetectedTokens[chainId]?.[this.config.selectedAddress] || [];\n\n    return [\n      ...new Set(\n        [...tokens, ...detectedTokens].map((token) =>\n          toHex(toChecksumHexAddress(token.address)),\n        ),\n      ),\n    ].sort();\n  }\n\n  /**\n   * Start (or restart) polling.\n   */\n  async start() {\n    this.#stopPoll();\n    this.#pollState = PollState.Active;\n    await this.#poll();\n  }\n\n  /**\n   * Stop polling.\n   */\n  stop() {\n    this.#stopPoll();\n    this.#pollState = PollState.Inactive;\n  }\n\n  /**\n   * Clear the active polling timer, if present.\n   */\n  #stopPoll() {\n    if (this.handle) {\n      clearTimeout(this.handle);\n    }\n  }\n\n  /**\n   * Poll for exchange rate updates.\n   */\n  async #poll() {\n    await safelyExecute(() => this.updateExchangeRates());\n\n    // Poll using recursive `setTimeout` instead of `setInterval` so that\n    // requests don't stack if they take longer than the polling interval\n    this.handle = setTimeout(() => {\n      this.#poll();\n    }, this.config.interval);\n  }\n\n  /**\n   * Updates exchange rates for all tokens.\n   */\n  async updateExchangeRates() {\n    const { chainId, nativeCurrency } = this.config;\n    await this.updateExchangeRatesByChainId({\n      chainId,\n      nativeCurrency,\n    });\n  }\n\n  /**\n   * Updates exchange rates for all tokens.\n   *\n   * @param options - The options to fetch exchange rates.\n   * @param options.chainId - The chain ID.\n   * @param options.nativeCurrency - The ticker for the chain.\n   */\n  async updateExchangeRatesByChainId({\n    chainId,\n    nativeCurrency,\n  }: {\n    chainId: Hex;\n    nativeCurrency: string;\n  }) {\n    if (this.disabled) {\n      return;\n    }\n\n    const tokenAddresses = this.#getTokenAddresses(chainId);\n    if (tokenAddresses.length === 0) {\n      return;\n    }\n\n    const updateKey: `${Hex}:${string}` = `${chainId}:${nativeCurrency}`;\n    if (updateKey in this.#inProcessExchangeRateUpdates) {\n      // This prevents redundant updates\n      // This promise is resolved after the in-progress update has finished,\n      // and state has been updated.\n      await this.#inProcessExchangeRateUpdates[updateKey];\n      return;\n    }\n\n    const {\n      promise: inProgressUpdate,\n      resolve: updateSucceeded,\n      reject: updateFailed,\n    } = createDeferredPromise({ suppressUnhandledRejection: true });\n    this.#inProcessExchangeRateUpdates[updateKey] = inProgressUpdate;\n\n    try {\n      const newContractExchangeRates = await this.#fetchAndMapExchangeRates({\n        tokenAddresses,\n        chainId,\n        nativeCurrency,\n      });\n\n      const existingContractExchangeRates = this.state.contractExchangeRates;\n      const updatedContractExchangeRates =\n        chainId === this.config.chainId &&\n        nativeCurrency === this.config.nativeCurrency\n          ? newContractExchangeRates\n          : existingContractExchangeRates;\n\n      const existingContractExchangeRatesForChainId =\n        this.state.contractExchangeRatesByChainId[chainId] ?? {};\n      const updatedContractExchangeRatesForChainId = {\n        ...this.state.contractExchangeRatesByChainId,\n        [chainId]: {\n          ...existingContractExchangeRatesForChainId,\n          [nativeCurrency]: {\n            ...existingContractExchangeRatesForChainId[nativeCurrency],\n            ...newContractExchangeRates,\n          },\n        },\n      };\n\n      this.update({\n        contractExchangeRates: updatedContractExchangeRates,\n        contractExchangeRatesByChainId: updatedContractExchangeRatesForChainId,\n      });\n      updateSucceeded();\n    } catch (error: unknown) {\n      updateFailed(error);\n      throw error;\n    } finally {\n      delete this.#inProcessExchangeRateUpdates[updateKey];\n    }\n  }\n\n  /**\n   * Uses the token prices service to retrieve exchange rates for tokens in a\n   * particular currency.\n   *\n   * If the price API does not support the given chain ID, returns an empty\n   * object.\n   *\n   * If the price API does not support the given currency, retrieves exchange\n   * rates in a known currency instead, then converts those rates using the\n   * exchange rate between the known currency and desired currency.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.chainId - The EIP-155 ID of the chain where the tokens live.\n   * @param args.nativeCurrency - The native currency in which to request\n   * exchange rates.\n   * @returns A map from token address to its exchange rate in the native\n   * currency, or an empty map if no exchange rates can be obtained for the\n   * chain ID.\n   */\n  async #fetchAndMapExchangeRates({\n    tokenAddresses,\n    chainId,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    chainId: Hex;\n    nativeCurrency: string;\n  }): Promise<ContractExchangeRates> {\n    if (!this.#tokenPricesService.validateChainIdSupported(chainId)) {\n      return tokenAddresses.reduce((obj, tokenAddress) => {\n        return {\n          ...obj,\n          [tokenAddress]: undefined,\n        };\n      }, {});\n    }\n\n    if (this.#tokenPricesService.validateCurrencySupported(nativeCurrency)) {\n      return await this.#fetchAndMapExchangeRatesForSupportedNativeCurrency({\n        tokenAddresses,\n        chainId,\n        nativeCurrency,\n      });\n    }\n\n    return await this.#fetchAndMapExchangeRatesForUnsupportedNativeCurrency({\n      tokenAddresses,\n      nativeCurrency,\n    });\n  }\n\n  /**\n   * Updates token rates for the given networkClientId\n   *\n   * @param networkClientId - The network client ID used to get a ticker value.\n   * @returns The controller state.\n   */\n  async _executePoll(networkClientId: NetworkClientId): Promise<void> {\n    const networkClient = this.getNetworkClientById(networkClientId);\n    await this.updateExchangeRatesByChainId({\n      chainId: networkClient.configuration.chainId,\n      nativeCurrency: networkClient.configuration.ticker,\n    });\n  }\n\n  /**\n   * Retrieves prices in the given currency for the given tokens on the given\n   * chain. Ensures that token addresses are checksum addresses.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.chainId - The EIP-155 ID of the chain where the tokens live.\n   * @param args.nativeCurrency - The native currency in which to request\n   * prices.\n   * @returns A map of the token addresses (as checksums) to their prices in the\n   * native currency.\n   */\n  async #fetchAndMapExchangeRatesForSupportedNativeCurrency({\n    tokenAddresses,\n    chainId,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    chainId: Hex;\n    nativeCurrency: string;\n  }): Promise<ContractExchangeRates> {\n    const tokenPricesByTokenAddress = await reduceInBatchesSerially<\n      Hex,\n      Awaited<ReturnType<AbstractTokenPricesService['fetchTokenPrices']>>\n    >({\n      values: [...tokenAddresses].sort(),\n      batchSize: TOKEN_PRICES_BATCH_SIZE,\n      eachBatch: async (allTokenPricesByTokenAddress, batch) => {\n        const tokenPricesByTokenAddressForBatch =\n          await this.#tokenPricesService.fetchTokenPrices({\n            tokenAddresses: batch,\n            chainId,\n            currency: nativeCurrency,\n          });\n\n        return {\n          ...allTokenPricesByTokenAddress,\n          ...tokenPricesByTokenAddressForBatch,\n        };\n      },\n      initialResult: {},\n    });\n\n    return Object.entries(tokenPricesByTokenAddress).reduce(\n      (obj, [tokenAddress, tokenPrice]) => {\n        return {\n          ...obj,\n          [tokenAddress]: tokenPrice?.value,\n        };\n      },\n      {},\n    );\n  }\n\n  /**\n   * If the price API does not support a given native currency, then we need to\n   * convert it to a fallback currency and feed that currency into the price\n   * API, then convert the prices to our desired native currency.\n   *\n   * @param args - The arguments to this function.\n   * @param args.tokenAddresses - Addresses for tokens.\n   * @param args.nativeCurrency - The native currency in which to request\n   * prices.\n   * @returns A map of the token addresses (as checksums) to their prices in the\n   * native currency.\n   */\n  async #fetchAndMapExchangeRatesForUnsupportedNativeCurrency({\n    tokenAddresses,\n    nativeCurrency,\n  }: {\n    tokenAddresses: Hex[];\n    nativeCurrency: string;\n  }): Promise<ContractExchangeRates> {\n    const [\n      contractExchangeRates,\n      fallbackCurrencyToNativeCurrencyConversionRate,\n    ] = await Promise.all([\n      this.#fetchAndMapExchangeRatesForSupportedNativeCurrency({\n        tokenAddresses,\n        chainId: this.config.chainId,\n        nativeCurrency: FALL_BACK_VS_CURRENCY,\n      }),\n      getCurrencyConversionRate({\n        from: FALL_BACK_VS_CURRENCY,\n        to: nativeCurrency,\n      }),\n    ]);\n\n    if (fallbackCurrencyToNativeCurrencyConversionRate === null) {\n      return {};\n    }\n\n    return Object.entries(contractExchangeRates).reduce(\n      (obj, [tokenAddress, tokenValue]) => {\n        return {\n          ...obj,\n          [tokenAddress]: tokenValue\n            ? tokenValue * fallbackCurrencyToNativeCurrencyConversionRate\n            : undefined,\n        };\n      },\n      {},\n    );\n  }\n}\n\nexport default TokenRatesController;\n"],"mappings":"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","names":[]}
\ No newline at end of file
diff --git a/dist/chunk-RUE635TV.mjs b/dist/chunk-RUE635TV.mjs
deleted file mode 100644
index 4da7dafdea847ba3c6acb707c2dda3b1a5629d0d..0000000000000000000000000000000000000000
--- a/dist/chunk-RUE635TV.mjs
+++ /dev/null
@@ -1,284 +0,0 @@
-import {
-  fetchTokenListByChainId
-} from "./chunk-NXGX7LZJ.mjs";
-import {
-  formatAggregatorNames,
-  formatIconUrlWithProxy,
-  isTokenListSupportedForNetwork
-} from "./chunk-X5PLVMOQ.mjs";
-import {
-  __privateAdd,
-  __privateMethod
-} from "./chunk-XUI43LEZ.mjs";
-
-// src/TokenListController.ts
-import { safelyExecute } from "@metamask/controller-utils";
-import { StaticIntervalPollingController } from "@metamask/polling-controller";
-import { Mutex } from "async-mutex";
-var DEFAULT_INTERVAL = 24 * 60 * 60 * 1e3;
-var DEFAULT_THRESHOLD = 24 * 60 * 60 * 1e3;
-var name = "TokenListController";
-var metadata = {
-  tokenList: { persist: true, anonymous: true },
-  tokensChainsCache: { persist: true, anonymous: true },
-  preventPollingOnNetworkRestart: { persist: true, anonymous: true }
-};
-var getDefaultTokenListState = () => {
-  return {
-    tokenList: {},
-    tokensChainsCache: {},
-    preventPollingOnNetworkRestart: false
-  };
-};
-var _onNetworkControllerStateChange, onNetworkControllerStateChange_fn, _fetchFromCache, fetchFromCache_fn;
-var TokenListController = class extends StaticIntervalPollingController {
-  /**
-   * Creates a TokenListController instance.
-   *
-   * @param options - The controller options.
-   * @param options.chainId - The chain ID of the current network.
-   * @param options.onNetworkStateChange - A function for registering an event handler for network state changes.
-   * @param options.interval - The polling interval, in milliseconds.
-   * @param options.cacheRefreshThreshold - The token cache expiry time, in milliseconds.
-   * @param options.messenger - A restricted controller messenger.
-   * @param options.state - Initial state to set on this controller.
-   * @param options.preventPollingOnNetworkRestart - Determines whether to prevent poilling on network restart in extension.
-   */
-  constructor({
-    chainId,
-    preventPollingOnNetworkRestart = false,
-    onNetworkStateChange,
-    interval = DEFAULT_INTERVAL,
-    cacheRefreshThreshold = DEFAULT_THRESHOLD,
-    messenger,
-    state
-  }) {
-    super({
-      name,
-      metadata,
-      messenger,
-      state: { ...getDefaultTokenListState(), ...state }
-    });
-    /**
-     * Updates state and restarts polling on changes to the network controller
-     * state.
-     *
-     * @param networkControllerState - The updated network controller state.
-     */
-    __privateAdd(this, _onNetworkControllerStateChange);
-    /**
-     * Checks if the Cache timestamp is valid,
-     * if yes data in cache will be returned
-     * otherwise null will be returned.
-     * @param chainId - The chain ID of the network for which to fetch the cache.
-     * @returns The cached data, or `null` if the cache was expired.
-     */
-    __privateAdd(this, _fetchFromCache);
-    this.mutex = new Mutex();
-    this.intervalDelay = interval;
-    this.cacheRefreshThreshold = cacheRefreshThreshold;
-    this.chainId = chainId;
-    this.updatePreventPollingOnNetworkRestart(preventPollingOnNetworkRestart);
-    this.abortController = new AbortController();
-    if (onNetworkStateChange) {
-      onNetworkStateChange(async (networkControllerState) => {
-        await __privateMethod(this, _onNetworkControllerStateChange, onNetworkControllerStateChange_fn).call(this, networkControllerState);
-      });
-    } else {
-      this.messagingSystem.subscribe(
-        "NetworkController:stateChange",
-        async (networkControllerState) => {
-          await __privateMethod(this, _onNetworkControllerStateChange, onNetworkControllerStateChange_fn).call(this, networkControllerState);
-        }
-      );
-    }
-  }
-  /**
-   * Start polling for the token list.
-   */
-  async start() {
-    if (!isTokenListSupportedForNetwork(this.chainId)) {
-      return;
-    }
-    await this.startPolling();
-  }
-  /**
-   * Restart polling for the token list.
-   */
-  async restart() {
-    this.stopPolling();
-    await this.startPolling();
-  }
-  /**
-   * Stop polling for the token list.
-   */
-  stop() {
-    this.stopPolling();
-  }
-  /**
-   * Prepare to discard this controller.
-   *
-   * This stops any active polling.
-   */
-  destroy() {
-    super.destroy();
-    this.stopPolling();
-  }
-  stopPolling() {
-    if (this.intervalId) {
-      clearInterval(this.intervalId);
-    }
-  }
-  /**
-   * Starts a new polling interval.
-   */
-  async startPolling() {
-    await safelyExecute(() => this.fetchTokenList());
-    this.intervalId = setInterval(async () => {
-      await safelyExecute(() => this.fetchTokenList());
-    }, this.intervalDelay);
-  }
-  /**
-   * Fetching token list from the Token Service API.
-   *
-   * @private
-   * @param networkClientId - The ID of the network client triggering the fetch.
-   * @returns A promise that resolves when this operation completes.
-   */
-  async _executePoll(networkClientId) {
-    return this.fetchTokenList(networkClientId);
-  }
-  /**
-   * Fetching token list from the Token Service API.
-   *
-   * @param networkClientId - The ID of the network client triggering the fetch.
-   */
-  async fetchTokenList(networkClientId) {
-    const releaseLock = await this.mutex.acquire();
-    let networkClient;
-    if (networkClientId) {
-      networkClient = this.messagingSystem.call(
-        "NetworkController:getNetworkClientById",
-        networkClientId
-      );
-    }
-    const chainId = networkClient?.configuration.chainId ?? this.chainId;
-    try {
-      const { tokensChainsCache } = this.state;
-      let tokenList = {};
-      const cachedTokens = await safelyExecute(
-        () => __privateMethod(this, _fetchFromCache, fetchFromCache_fn).call(this, chainId)
-      );
-      if (cachedTokens) {
-        tokenList = { ...cachedTokens };
-      } else {
-        const tokensFromAPI = await safelyExecute(
-          () => fetchTokenListByChainId(
-            chainId,
-            this.abortController.signal
-          )
-        );
-        if (!tokensFromAPI) {
-          tokenList = { ...tokensChainsCache[chainId]?.data || {} };
-          this.update(() => {
-            return {
-              ...this.state,
-              tokenList,
-              tokensChainsCache
-            };
-          });
-          return;
-        }
-        for (const token of tokensFromAPI) {
-          const formattedToken = {
-            ...token,
-            aggregators: formatAggregatorNames(token.aggregators),
-            iconUrl: formatIconUrlWithProxy({
-              chainId,
-              tokenAddress: token.address
-            })
-          };
-          tokenList[token.address] = formattedToken;
-        }
-      }
-      const updatedTokensChainsCache = {
-        ...tokensChainsCache,
-        [chainId]: {
-          timestamp: Date.now(),
-          data: tokenList
-        }
-      };
-      this.update(() => {
-        return {
-          ...this.state,
-          tokenList,
-          tokensChainsCache: updatedTokensChainsCache
-        };
-      });
-    } finally {
-      releaseLock();
-    }
-  }
-  /**
-   * Clearing tokenList and tokensChainsCache explicitly.
-   */
-  clearingTokenListData() {
-    this.update(() => {
-      return {
-        ...this.state,
-        tokenList: {},
-        tokensChainsCache: {}
-      };
-    });
-  }
-  /**
-   * Updates preventPollingOnNetworkRestart from extension.
-   *
-   * @param shouldPreventPolling - Determine whether to prevent polling on network change
-   */
-  updatePreventPollingOnNetworkRestart(shouldPreventPolling) {
-    this.update(() => {
-      return {
-        ...this.state,
-        preventPollingOnNetworkRestart: shouldPreventPolling
-      };
-    });
-  }
-};
-_onNetworkControllerStateChange = new WeakSet();
-onNetworkControllerStateChange_fn = async function(networkControllerState) {
-  if (this.chainId !== networkControllerState.providerConfig.chainId) {
-    this.abortController.abort();
-    this.abortController = new AbortController();
-    this.chainId = networkControllerState.providerConfig.chainId;
-    if (this.state.preventPollingOnNetworkRestart) {
-      this.clearingTokenListData();
-    } else {
-      this.update(() => {
-        return {
-          ...this.state,
-          tokenList: this.state.tokensChainsCache[this.chainId]?.data || {}
-        };
-      });
-      await this.restart();
-    }
-  }
-};
-_fetchFromCache = new WeakSet();
-fetchFromCache_fn = async function(chainId) {
-  const { tokensChainsCache } = this.state;
-  const dataCache = tokensChainsCache[chainId];
-  const now = Date.now();
-  if (dataCache?.data && now - dataCache?.timestamp < this.cacheRefreshThreshold) {
-    return dataCache.data;
-  }
-  return null;
-};
-var TokenListController_default = TokenListController;
-
-export {
-  getDefaultTokenListState,
-  TokenListController,
-  TokenListController_default
-};
-//# sourceMappingURL=chunk-RUE635TV.mjs.map
\ No newline at end of file
diff --git a/dist/chunk-RUE635TV.mjs.map b/dist/chunk-RUE635TV.mjs.map
deleted file mode 100644
index a05d2fc634a092464a4ec07bd751c914337ce7e6..0000000000000000000000000000000000000000
--- a/dist/chunk-RUE635TV.mjs.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["../src/TokenListController.ts"],"sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { safelyExecute } from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkControllerStateChangeEvent,\n  NetworkState,\n  NetworkControllerGetNetworkClientByIdAction,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingController } from '@metamask/polling-controller';\nimport type { Hex } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\n\nimport {\n  isTokenListSupportedForNetwork,\n  formatAggregatorNames,\n  formatIconUrlWithProxy,\n} from './assetsUtil';\nimport { fetchTokenListByChainId } from './token-service';\n\nconst DEFAULT_INTERVAL = 24 * 60 * 60 * 1000;\nconst DEFAULT_THRESHOLD = 24 * 60 * 60 * 1000;\n\nconst name = 'TokenListController';\n\nexport type TokenListToken = {\n  name: string;\n  symbol: string;\n  decimals: number;\n  address: string;\n  occurrences: number;\n  aggregators: string[];\n  iconUrl: string;\n};\n\nexport type TokenListMap = Record<string, TokenListToken>;\n\ntype DataCache = {\n  timestamp: number;\n  data: TokenListMap;\n};\ntype TokensChainsCache = {\n  [chainId: Hex]: DataCache;\n};\n\nexport type TokenListState = {\n  tokenList: TokenListMap;\n  tokensChainsCache: TokensChainsCache;\n  preventPollingOnNetworkRestart: boolean;\n};\n\nexport type TokenListStateChange = ControllerStateChangeEvent<\n  typeof name,\n  TokenListState\n>;\n\nexport type TokenListControllerEvents = TokenListStateChange;\n\nexport type GetTokenListState = ControllerGetStateAction<\n  typeof name,\n  TokenListState\n>;\n\nexport type TokenListControllerActions = GetTokenListState;\n\ntype AllowedActions = NetworkControllerGetNetworkClientByIdAction;\n\ntype AllowedEvents = NetworkControllerStateChangeEvent;\n\nexport type TokenListControllerMessenger = RestrictedControllerMessenger<\n  typeof name,\n  TokenListControllerActions | AllowedActions,\n  TokenListControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\nconst metadata = {\n  tokenList: { persist: true, anonymous: true },\n  tokensChainsCache: { persist: true, anonymous: true },\n  preventPollingOnNetworkRestart: { persist: true, anonymous: true },\n};\n\nexport const getDefaultTokenListState = (): TokenListState => {\n  return {\n    tokenList: {},\n    tokensChainsCache: {},\n    preventPollingOnNetworkRestart: false,\n  };\n};\n\n/**\n * Controller that passively polls on a set interval for the list of tokens from metaswaps api\n */\nexport class TokenListController extends StaticIntervalPollingController<\n  typeof name,\n  TokenListState,\n  TokenListControllerMessenger\n> {\n  private readonly mutex = new Mutex();\n\n  private intervalId?: ReturnType<typeof setTimeout>;\n\n  private readonly intervalDelay: number;\n\n  private readonly cacheRefreshThreshold: number;\n\n  private chainId: Hex;\n\n  private abortController: AbortController;\n\n  /**\n   * Creates a TokenListController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onNetworkStateChange - A function for registering an event handler for network state changes.\n   * @param options.interval - The polling interval, in milliseconds.\n   * @param options.cacheRefreshThreshold - The token cache expiry time, in milliseconds.\n   * @param options.messenger - A restricted controller messenger.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.preventPollingOnNetworkRestart - Determines whether to prevent poilling on network restart in extension.\n   */\n  constructor({\n    chainId,\n    preventPollingOnNetworkRestart = false,\n    onNetworkStateChange,\n    interval = DEFAULT_INTERVAL,\n    cacheRefreshThreshold = DEFAULT_THRESHOLD,\n    messenger,\n    state,\n  }: {\n    chainId: Hex;\n    preventPollingOnNetworkRestart?: boolean;\n    onNetworkStateChange?: (\n      listener: (networkState: NetworkState) => void,\n    ) => void;\n    interval?: number;\n    cacheRefreshThreshold?: number;\n    messenger: TokenListControllerMessenger;\n    state?: Partial<TokenListState>;\n  }) {\n    super({\n      name,\n      metadata,\n      messenger,\n      state: { ...getDefaultTokenListState(), ...state },\n    });\n    this.intervalDelay = interval;\n    this.cacheRefreshThreshold = cacheRefreshThreshold;\n    this.chainId = chainId;\n    this.updatePreventPollingOnNetworkRestart(preventPollingOnNetworkRestart);\n    this.abortController = new AbortController();\n    if (onNetworkStateChange) {\n      onNetworkStateChange(async (networkControllerState) => {\n        await this.#onNetworkControllerStateChange(networkControllerState);\n      });\n    } else {\n      this.messagingSystem.subscribe(\n        'NetworkController:stateChange',\n        async (networkControllerState) => {\n          await this.#onNetworkControllerStateChange(networkControllerState);\n        },\n      );\n    }\n  }\n\n  /**\n   * Updates state and restarts polling on changes to the network controller\n   * state.\n   *\n   * @param networkControllerState - The updated network controller state.\n   */\n  async #onNetworkControllerStateChange(networkControllerState: NetworkState) {\n    if (this.chainId !== networkControllerState.providerConfig.chainId) {\n      this.abortController.abort();\n      this.abortController = new AbortController();\n      this.chainId = networkControllerState.providerConfig.chainId;\n      if (this.state.preventPollingOnNetworkRestart) {\n        this.clearingTokenListData();\n      } else {\n        // Ensure tokenList is referencing data from correct network\n        this.update(() => {\n          return {\n            ...this.state,\n            tokenList: this.state.tokensChainsCache[this.chainId]?.data || {},\n          };\n        });\n        await this.restart();\n      }\n    }\n  }\n\n  /**\n   * Start polling for the token list.\n   */\n  async start() {\n    if (!isTokenListSupportedForNetwork(this.chainId)) {\n      return;\n    }\n    await this.startPolling();\n  }\n\n  /**\n   * Restart polling for the token list.\n   */\n  async restart() {\n    this.stopPolling();\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for the token list.\n   */\n  stop() {\n    this.stopPolling();\n  }\n\n  /**\n   * Prepare to discard this controller.\n   *\n   * This stops any active polling.\n   */\n  override destroy() {\n    super.destroy();\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   */\n  private async startPolling(): Promise<void> {\n    await safelyExecute(() => this.fetchTokenList());\n    this.intervalId = setInterval(async () => {\n      await safelyExecute(() => this.fetchTokenList());\n    }, this.intervalDelay);\n  }\n\n  /**\n   * Fetching token list from the Token Service API.\n   *\n   * @private\n   * @param networkClientId - The ID of the network client triggering the fetch.\n   * @returns A promise that resolves when this operation completes.\n   */\n  async _executePoll(networkClientId: string): Promise<void> {\n    return this.fetchTokenList(networkClientId);\n  }\n\n  /**\n   * Fetching token list from the Token Service API.\n   *\n   * @param networkClientId - The ID of the network client triggering the fetch.\n   */\n  async fetchTokenList(networkClientId?: NetworkClientId): Promise<void> {\n    const releaseLock = await this.mutex.acquire();\n    let networkClient;\n    if (networkClientId) {\n      networkClient = this.messagingSystem.call(\n        'NetworkController:getNetworkClientById',\n        networkClientId,\n      );\n    }\n    const chainId = networkClient?.configuration.chainId ?? this.chainId;\n    try {\n      const { tokensChainsCache } = this.state;\n      let tokenList: TokenListMap = {};\n      const cachedTokens = await safelyExecute(() =>\n        this.#fetchFromCache(chainId),\n      );\n      if (cachedTokens) {\n        // Use non-expired cached tokens\n        tokenList = { ...cachedTokens };\n      } else {\n        // Fetch fresh token list\n        const tokensFromAPI = await safelyExecute(\n          () =>\n            fetchTokenListByChainId(\n              chainId,\n              this.abortController.signal,\n            ) as Promise<TokenListToken[]>,\n        );\n\n        if (!tokensFromAPI) {\n          // Fallback to expired cached tokens\n          tokenList = { ...(tokensChainsCache[chainId]?.data || {}) };\n          this.update(() => {\n            return {\n              ...this.state,\n              tokenList,\n              tokensChainsCache,\n            };\n          });\n          return;\n        }\n        for (const token of tokensFromAPI) {\n          const formattedToken: TokenListToken = {\n            ...token,\n            aggregators: formatAggregatorNames(token.aggregators),\n            iconUrl: formatIconUrlWithProxy({\n              chainId,\n              tokenAddress: token.address,\n            }),\n          };\n          tokenList[token.address] = formattedToken;\n        }\n      }\n      const updatedTokensChainsCache: TokensChainsCache = {\n        ...tokensChainsCache,\n        [chainId]: {\n          timestamp: Date.now(),\n          data: tokenList,\n        },\n      };\n      this.update(() => {\n        return {\n          ...this.state,\n          tokenList,\n          tokensChainsCache: updatedTokensChainsCache,\n        };\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Checks if the Cache timestamp is valid,\n   * if yes data in cache will be returned\n   * otherwise null will be returned.\n   * @param chainId - The chain ID of the network for which to fetch the cache.\n   * @returns The cached data, or `null` if the cache was expired.\n   */\n  async #fetchFromCache(chainId: Hex): Promise<TokenListMap | null> {\n    const { tokensChainsCache }: TokenListState = this.state;\n    const dataCache = tokensChainsCache[chainId];\n    const now = Date.now();\n    if (\n      dataCache?.data &&\n      now - dataCache?.timestamp < this.cacheRefreshThreshold\n    ) {\n      return dataCache.data;\n    }\n    return null;\n  }\n\n  /**\n   * Clearing tokenList and tokensChainsCache explicitly.\n   */\n  clearingTokenListData(): void {\n    this.update(() => {\n      return {\n        ...this.state,\n        tokenList: {},\n        tokensChainsCache: {},\n      };\n    });\n  }\n\n  /**\n   * Updates preventPollingOnNetworkRestart from extension.\n   *\n   * @param shouldPreventPolling - Determine whether to prevent polling on network change\n   */\n  updatePreventPollingOnNetworkRestart(shouldPreventPolling: boolean): void {\n    this.update(() => {\n      return {\n        ...this.state,\n        preventPollingOnNetworkRestart: shouldPreventPolling,\n      };\n    });\n  }\n}\n\nexport default TokenListController;\n"],"mappings":";;;;;;;;;;;;;;AAKA,SAAS,qBAAqB;AAO9B,SAAS,uCAAuC;AAEhD,SAAS,aAAa;AAStB,IAAM,mBAAmB,KAAK,KAAK,KAAK;AACxC,IAAM,oBAAoB,KAAK,KAAK,KAAK;AAEzC,IAAM,OAAO;AAsDb,IAAM,WAAW;AAAA,EACf,WAAW,EAAE,SAAS,MAAM,WAAW,KAAK;AAAA,EAC5C,mBAAmB,EAAE,SAAS,MAAM,WAAW,KAAK;AAAA,EACpD,gCAAgC,EAAE,SAAS,MAAM,WAAW,KAAK;AACnE;AAEO,IAAM,2BAA2B,MAAsB;AAC5D,SAAO;AAAA,IACL,WAAW,CAAC;AAAA,IACZ,mBAAmB,CAAC;AAAA,IACpB,gCAAgC;AAAA,EAClC;AACF;AA5FA;AAiGO,IAAM,sBAAN,cAAkC,gCAIvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAyBA,YAAY;AAAA,IACV;AAAA,IACA,iCAAiC;AAAA,IACjC;AAAA,IACA,WAAW;AAAA,IACX,wBAAwB;AAAA,IACxB;AAAA,IACA;AAAA,EACF,GAUG;AACD,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,MACA,OAAO,EAAE,GAAG,yBAAyB,GAAG,GAAG,MAAM;AAAA,IACnD,CAAC;AA0BH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AAsKN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AAhPN,SAAiB,QAAQ,IAAI,MAAM;AAiDjC,SAAK,gBAAgB;AACrB,SAAK,wBAAwB;AAC7B,SAAK,UAAU;AACf,SAAK,qCAAqC,8BAA8B;AACxE,SAAK,kBAAkB,IAAI,gBAAgB;AAC3C,QAAI,sBAAsB;AACxB,2BAAqB,OAAO,2BAA2B;AACrD,cAAM,sBAAK,oEAAL,WAAqC;AAAA,MAC7C,CAAC;AAAA,IACH,OAAO;AACL,WAAK,gBAAgB;AAAA,QACnB;AAAA,QACA,OAAO,2BAA2B;AAChC,gBAAM,sBAAK,oEAAL,WAAqC;AAAA,QAC7C;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EA+BA,MAAM,QAAQ;AACZ,QAAI,CAAC,+BAA+B,KAAK,OAAO,GAAG;AACjD;AAAA,IACF;AACA,UAAM,KAAK,aAAa;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,UAAU;AACd,SAAK,YAAY;AACjB,UAAM,KAAK,aAAa;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO;AACL,SAAK,YAAY;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOS,UAAU;AACjB,UAAM,QAAQ;AACd,SAAK,YAAY;AAAA,EACnB;AAAA,EAEQ,cAAc;AACpB,QAAI,KAAK,YAAY;AACnB,oBAAc,KAAK,UAAU;AAAA,IAC/B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,eAA8B;AAC1C,UAAM,cAAc,MAAM,KAAK,eAAe,CAAC;AAC/C,SAAK,aAAa,YAAY,YAAY;AACxC,YAAM,cAAc,MAAM,KAAK,eAAe,CAAC;AAAA,IACjD,GAAG,KAAK,aAAa;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,aAAa,iBAAwC;AACzD,WAAO,KAAK,eAAe,eAAe;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,eAAe,iBAAkD;AACrE,UAAM,cAAc,MAAM,KAAK,MAAM,QAAQ;AAC7C,QAAI;AACJ,QAAI,iBAAiB;AACnB,sBAAgB,KAAK,gBAAgB;AAAA,QACnC;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,UAAM,UAAU,eAAe,cAAc,WAAW,KAAK;AAC7D,QAAI;AACF,YAAM,EAAE,kBAAkB,IAAI,KAAK;AACnC,UAAI,YAA0B,CAAC;AAC/B,YAAM,eAAe,MAAM;AAAA,QAAc,MACvC,sBAAK,oCAAL,WAAqB;AAAA,MACvB;AACA,UAAI,cAAc;AAEhB,oBAAY,EAAE,GAAG,aAAa;AAAA,MAChC,OAAO;AAEL,cAAM,gBAAgB,MAAM;AAAA,UAC1B,MACE;AAAA,YACE;AAAA,YACA,KAAK,gBAAgB;AAAA,UACvB;AAAA,QACJ;AAEA,YAAI,CAAC,eAAe;AAElB,sBAAY,EAAE,GAAI,kBAAkB,OAAO,GAAG,QAAQ,CAAC,EAAG;AAC1D,eAAK,OAAO,MAAM;AAChB,mBAAO;AAAA,cACL,GAAG,KAAK;AAAA,cACR;AAAA,cACA;AAAA,YACF;AAAA,UACF,CAAC;AACD;AAAA,QACF;AACA,mBAAW,SAAS,eAAe;AACjC,gBAAM,iBAAiC;AAAA,YACrC,GAAG;AAAA,YACH,aAAa,sBAAsB,MAAM,WAAW;AAAA,YACpD,SAAS,uBAAuB;AAAA,cAC9B;AAAA,cACA,cAAc,MAAM;AAAA,YACtB,CAAC;AAAA,UACH;AACA,oBAAU,MAAM,OAAO,IAAI;AAAA,QAC7B;AAAA,MACF;AACA,YAAM,2BAA8C;AAAA,QAClD,GAAG;AAAA,QACH,CAAC,OAAO,GAAG;AAAA,UACT,WAAW,KAAK,IAAI;AAAA,UACpB,MAAM;AAAA,QACR;AAAA,MACF;AACA,WAAK,OAAO,MAAM;AAChB,eAAO;AAAA,UACL,GAAG,KAAK;AAAA,UACR;AAAA,UACA,mBAAmB;AAAA,QACrB;AAAA,MACF,CAAC;AAAA,IACH,UAAE;AACA,kBAAY;AAAA,IACd;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAyBA,wBAA8B;AAC5B,SAAK,OAAO,MAAM;AAChB,aAAO;AAAA,QACL,GAAG,KAAK;AAAA,QACR,WAAW,CAAC;AAAA,QACZ,mBAAmB,CAAC;AAAA,MACtB;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,qCAAqC,sBAAqC;AACxE,SAAK,OAAO,MAAM;AAChB,aAAO;AAAA,QACL,GAAG,KAAK;AAAA,QACR,gCAAgC;AAAA,MAClC;AAAA,IACF,CAAC;AAAA,EACH;AACF;AA7MQ;AAAA,oCAA+B,eAAC,wBAAsC;AAC1E,MAAI,KAAK,YAAY,uBAAuB,eAAe,SAAS;AAClE,SAAK,gBAAgB,MAAM;AAC3B,SAAK,kBAAkB,IAAI,gBAAgB;AAC3C,SAAK,UAAU,uBAAuB,eAAe;AACrD,QAAI,KAAK,MAAM,gCAAgC;AAC7C,WAAK,sBAAsB;AAAA,IAC7B,OAAO;AAEL,WAAK,OAAO,MAAM;AAChB,eAAO;AAAA,UACL,GAAG,KAAK;AAAA,UACR,WAAW,KAAK,MAAM,kBAAkB,KAAK,OAAO,GAAG,QAAQ,CAAC;AAAA,QAClE;AAAA,MACF,CAAC;AACD,YAAM,KAAK,QAAQ;AAAA,IACrB;AAAA,EACF;AACF;AAoJM;AAAA,oBAAe,eAAC,SAA4C;AAChE,QAAM,EAAE,kBAAkB,IAAoB,KAAK;AACnD,QAAM,YAAY,kBAAkB,OAAO;AAC3C,QAAM,MAAM,KAAK,IAAI;AACrB,MACE,WAAW,QACX,MAAM,WAAW,YAAY,KAAK,uBAClC;AACA,WAAO,UAAU;AAAA,EACnB;AACA,SAAO;AACT;AA8BF,IAAO,8BAAQ;","names":[]}
\ No newline at end of file
diff --git a/dist/chunk-S6CZP74C.mjs b/dist/chunk-S6CZP74C.mjs
deleted file mode 100644
index 6f4abd20076a2b7e701660cc7ae06e23b21d4ea4..0000000000000000000000000000000000000000
--- a/dist/chunk-S6CZP74C.mjs
+++ /dev/null
@@ -1,1182 +0,0 @@
-import {
-  compareNftMetadata,
-  getFormattedIpfsUrl
-} from "./chunk-X5PLVMOQ.mjs";
-
-// src/NftController.ts
-import { isAddress } from "@ethersproject/address";
-import { BaseControllerV1 } from "@metamask/base-controller";
-import {
-  safelyExecute,
-  handleFetch,
-  toChecksumHexAddress,
-  BNToHex,
-  fetchWithErrorHandling,
-  IPFS_DEFAULT_GATEWAY_URL,
-  ERC721,
-  ERC1155,
-  ApprovalType,
-  NFT_API_BASE_URL
-} from "@metamask/controller-utils";
-import { rpcErrors } from "@metamask/rpc-errors";
-import { remove0x } from "@metamask/utils";
-import { Mutex } from "async-mutex";
-import BN from "bn.js";
-import { EventEmitter } from "events";
-import { v4 as random } from "uuid";
-var ALL_NFTS_STATE_KEY = "allNfts";
-var ALL_NFTS_CONTRACTS_STATE_KEY = "allNftContracts";
-var getDefaultNftState = () => {
-  return {
-    allNftContracts: {},
-    allNfts: {},
-    ignoredNfts: []
-  };
-};
-var NftController = class extends BaseControllerV1 {
-  /**
-   * Creates an NftController instance.
-   *
-   * @param options - The controller options.
-   * @param options.chainId - The chain ID of the current network.
-   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
-   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
-   * @param options.getERC721AssetName - Gets the name of the asset at the given address.
-   * @param options.getERC721AssetSymbol - Gets the symbol of the asset at the given address.
-   * @param options.getERC721TokenURI - Gets the URI of the ERC721 token at the given address, with the given ID.
-   * @param options.getERC721OwnerOf - Get the owner of a ERC-721 NFT.
-   * @param options.getERC1155BalanceOf - Gets balance of a ERC-1155 NFT.
-   * @param options.getERC1155TokenURI - Gets the URI of the ERC1155 token at the given address, with the given ID.
-   * @param options.getNetworkClientById - Gets the network client for the given networkClientId.
-   * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data
-   * for tracking the NFT added event.
-   * @param options.messenger - The controller messenger.
-   * @param config - Initial options used to configure this controller.
-   * @param state - Initial state to set on this controller.
-   */
-  constructor({
-    chainId: initialChainId,
-    onPreferencesStateChange,
-    onNetworkStateChange,
-    getERC721AssetName,
-    getERC721AssetSymbol,
-    getERC721TokenURI,
-    getERC721OwnerOf,
-    getERC1155BalanceOf,
-    getERC1155TokenURI,
-    getNetworkClientById,
-    onNftAdded,
-    messenger
-  }, config, state) {
-    super(config, state);
-    this.mutex = new Mutex();
-    /**
-     * EventEmitter instance used to listen to specific EIP747 events
-     */
-    this.hub = new EventEmitter();
-    /**
-     * Name of this controller used during composition
-     */
-    this.name = "NftController";
-    this.defaultConfig = {
-      selectedAddress: "",
-      chainId: initialChainId,
-      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,
-      openSeaEnabled: false,
-      useIPFSSubdomains: true,
-      isIpfsGatewayEnabled: true
-    };
-    this.defaultState = getDefaultNftState();
-    this.initialize();
-    this.getERC721AssetName = getERC721AssetName;
-    this.getERC721AssetSymbol = getERC721AssetSymbol;
-    this.getERC721TokenURI = getERC721TokenURI;
-    this.getERC721OwnerOf = getERC721OwnerOf;
-    this.getERC1155BalanceOf = getERC1155BalanceOf;
-    this.getERC1155TokenURI = getERC1155TokenURI;
-    this.getNetworkClientById = getNetworkClientById;
-    this.onNftAdded = onNftAdded;
-    this.messagingSystem = messenger;
-    onPreferencesStateChange(
-      async ({
-        selectedAddress,
-        ipfsGateway,
-        openSeaEnabled,
-        isIpfsGatewayEnabled
-      }) => {
-        this.configure({
-          selectedAddress,
-          ipfsGateway,
-          openSeaEnabled,
-          isIpfsGatewayEnabled
-        });
-        const needsUpdateNftMetadata = isIpfsGatewayEnabled && ipfsGateway !== "" || openSeaEnabled;
-        if (needsUpdateNftMetadata) {
-          const { chainId } = this.config;
-          const nfts = this.state.allNfts[selectedAddress]?.[chainId] ?? [];
-          const nftsToUpdate = nfts.filter(
-            (singleNft) => !singleNft.name && !singleNft.description && !singleNft.image
-          );
-          if (nftsToUpdate.length !== 0) {
-            await this.updateNftMetadata({
-              nfts: nftsToUpdate,
-              userAddress: selectedAddress
-            });
-          }
-        }
-      }
-    );
-    onNetworkStateChange(({ providerConfig }) => {
-      const { chainId } = providerConfig;
-      this.configure({ chainId });
-    });
-  }
-  getNftApi() {
-    return `${NFT_API_BASE_URL}/tokens`;
-  }
-  /**
-   * Helper method to update nested state for allNfts and allNftContracts.
-   *
-   * @param newCollection - the modified piece of state to update in the controller's store
-   * @param baseStateKey - The root key in the store to update.
-   * @param passedConfig - An object containing the selectedAddress and chainId that are passed through the auto-detection flow.
-   * @param passedConfig.userAddress - the address passed through the NFT detection flow to ensure assets are stored to the correct account
-   * @param passedConfig.chainId - the chainId passed through the NFT detection flow to ensure assets are stored to the correct account
-   */
-  updateNestedNftState(newCollection, baseStateKey, { userAddress, chainId }) {
-    const { [baseStateKey]: oldState } = this.state;
-    const addressState = oldState[userAddress];
-    const newAddressState = {
-      ...addressState,
-      ...{ [chainId]: newCollection }
-    };
-    const newState = {
-      ...oldState,
-      ...{ [userAddress]: newAddressState }
-    };
-    this.update({
-      [baseStateKey]: newState
-    });
-  }
-  /**
-   * Request individual NFT information from NFT API.
-   *
-   * @param contractAddress - Hex address of the NFT contract.
-   * @param tokenId - The NFT identifier.
-   * @returns Promise resolving to the current NFT name and image.
-   */
-  async getNftInformationFromApi(contractAddress, tokenId) {
-    const urlParams = new URLSearchParams({
-      chainIds: "1",
-      tokens: `${contractAddress}:${tokenId}`,
-      includeTopBid: "true",
-      includeAttributes: "true",
-      includeLastSale: "true"
-    }).toString();
-    const nftInformation = await fetchWithErrorHandling({
-      url: `${this.getNftApi()}?${urlParams}`,
-      options: {
-        headers: {
-          Version: "1"
-        }
-      }
-    });
-    if (!nftInformation?.tokens?.[0]?.token) {
-      return {
-        name: null,
-        description: null,
-        image: null,
-        standard: null
-      };
-    }
-    const {
-      image,
-      metadata: { imageOriginal } = {},
-      name,
-      description,
-      collection,
-      kind,
-      rarityRank,
-      rarity,
-      attributes,
-      lastSale,
-      imageSmall
-    } = nftInformation.tokens[0].token;
-    const nftMetadata = Object.assign(
-      {},
-      { name: name || null },
-      { description: description || null },
-      { image: image || null },
-      collection?.creator && { creator: collection.creator },
-      imageOriginal && { imageOriginal },
-      imageSmall && { imageThumbnail: imageSmall },
-      kind && { standard: kind.toUpperCase() },
-      lastSale && { lastSale },
-      attributes && { attributes },
-      nftInformation.tokens[0].market?.topBid && {
-        topBid: nftInformation.tokens[0].market?.topBid
-      },
-      rarityRank && { rarityRank },
-      rarity && { rarity },
-      collection && { collection }
-    );
-    return nftMetadata;
-  }
-  /**
-   * Request individual NFT information from contracts that follows Metadata Interface.
-   *
-   * @param contractAddress - Hex address of the NFT contract.
-   * @param tokenId - The NFT identifier.
-   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @returns Promise resolving to the current NFT name and image.
-   */
-  async getNftInformationFromTokenURI(contractAddress, tokenId, networkClientId) {
-    const { ipfsGateway, useIPFSSubdomains, isIpfsGatewayEnabled } = this.config;
-    const result = await this.getNftURIAndStandard(
-      contractAddress,
-      tokenId,
-      networkClientId
-    );
-    let tokenURI = result[0];
-    const standard = result[1];
-    const hasIpfsTokenURI = tokenURI.startsWith("ipfs://");
-    if (hasIpfsTokenURI && !isIpfsGatewayEnabled) {
-      return {
-        image: null,
-        name: null,
-        description: null,
-        standard: standard || null,
-        favorite: false,
-        tokenURI: tokenURI ?? null
-      };
-    }
-    const isDisplayNFTMediaToggleEnabled = this.config.openSeaEnabled;
-    if (!hasIpfsTokenURI && !isDisplayNFTMediaToggleEnabled) {
-      return {
-        image: null,
-        name: null,
-        description: null,
-        standard: standard || null,
-        favorite: false,
-        tokenURI: tokenURI ?? null
-      };
-    }
-    if (hasIpfsTokenURI) {
-      tokenURI = getFormattedIpfsUrl(ipfsGateway, tokenURI, useIPFSSubdomains);
-    }
-    try {
-      const object = await handleFetch(tokenURI);
-      const image = Object.prototype.hasOwnProperty.call(object, "image") ? "image" : (
-        /* istanbul ignore next */
-        "image_url"
-      );
-      return {
-        image: object[image],
-        name: object.name,
-        description: object.description,
-        standard,
-        favorite: false,
-        tokenURI: tokenURI ?? null
-      };
-    } catch {
-      return {
-        image: null,
-        name: null,
-        description: null,
-        standard: standard || null,
-        favorite: false,
-        tokenURI: tokenURI ?? null
-      };
-    }
-  }
-  /**
-   * Retrieve NFT uri with  metadata. TODO Update method to use IPFS.
-   *
-   * @param contractAddress - NFT contract address.
-   * @param tokenId - NFT token id.
-   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @returns Promise resolving NFT uri and token standard.
-   */
-  async getNftURIAndStandard(contractAddress, tokenId, networkClientId) {
-    try {
-      const uri = await this.getERC721TokenURI(
-        contractAddress,
-        tokenId,
-        networkClientId
-      );
-      return [uri, ERC721];
-    } catch {
-    }
-    try {
-      const tokenURI = await this.getERC1155TokenURI(
-        contractAddress,
-        tokenId,
-        networkClientId
-      );
-      if (!tokenURI.includes("{id}")) {
-        return [tokenURI, ERC1155];
-      }
-      const hexTokenId = remove0x(BNToHex(new BN(tokenId))).padStart(64, "0").toLowerCase();
-      return [tokenURI.replace("{id}", hexTokenId), ERC1155];
-    } catch {
-    }
-    return ["", ""];
-  }
-  /**
-   * Request individual NFT information (name, image url and description).
-   *
-   * @param contractAddress - Hex address of the NFT contract.
-   * @param tokenId - The NFT identifier.
-   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @returns Promise resolving to the current NFT name and image.
-   */
-  async getNftInformation(contractAddress, tokenId, networkClientId) {
-    const chainId = this.getCorrectChainId({
-      networkClientId
-    });
-    const [blockchainMetadata, nftApiMetadata] = await Promise.all([
-      safelyExecute(
-        () => this.getNftInformationFromTokenURI(
-          contractAddress,
-          tokenId,
-          networkClientId
-        )
-      ),
-      this.config.openSeaEnabled && chainId === "0x1" ? safelyExecute(
-        () => this.getNftInformationFromApi(contractAddress, tokenId)
-      ) : void 0
-    ]);
-    return {
-      ...nftApiMetadata,
-      name: blockchainMetadata?.name ?? nftApiMetadata?.name ?? null,
-      description: blockchainMetadata?.description ?? nftApiMetadata?.description ?? null,
-      image: blockchainMetadata?.image ?? nftApiMetadata?.image ?? null,
-      standard: blockchainMetadata?.standard ?? nftApiMetadata?.standard ?? null,
-      tokenURI: blockchainMetadata?.tokenURI ?? null
-    };
-  }
-  /**
-   * Request NFT contract information from the contract itself.
-   *
-   * @param contractAddress - Hex address of the NFT contract.
-   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @returns Promise resolving to the current NFT name and image.
-   */
-  async getNftContractInformationFromContract(contractAddress, networkClientId) {
-    const [name, symbol] = await Promise.all([
-      this.getERC721AssetName(contractAddress, networkClientId),
-      this.getERC721AssetSymbol(contractAddress, networkClientId)
-    ]);
-    return {
-      collection: { name },
-      symbol,
-      address: contractAddress
-    };
-  }
-  /**
-   * Request NFT contract information from Blockchain and aggregate with received data from NFTMetadata.
-   *
-   * @param contractAddress - Hex address of the NFT contract.
-   * @param nftMetadataFromApi - Received NFT information to be aggregated with blockchain contract information.
-   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @returns Promise resolving to the NFT contract name, image and description.
-   */
-  async getNftContractInformation(contractAddress, nftMetadataFromApi, networkClientId) {
-    const blockchainContractData = await safelyExecute(
-      () => this.getNftContractInformationFromContract(
-        contractAddress,
-        networkClientId
-      )
-    );
-    if (blockchainContractData || !Object.values(nftMetadataFromApi).every((value) => value === null)) {
-      return {
-        address: contractAddress,
-        ...blockchainContractData,
-        schema_name: nftMetadataFromApi?.standard ?? null,
-        collection: {
-          name: null,
-          image_url: nftMetadataFromApi?.collection?.image ?? nftMetadataFromApi?.collection?.imageUrl ?? null,
-          tokenCount: nftMetadataFromApi?.collection?.tokenCount ?? null,
-          ...nftMetadataFromApi?.collection,
-          ...blockchainContractData?.collection
-        }
-      };
-    }
-    return {
-      address: contractAddress,
-      asset_contract_type: null,
-      created_date: null,
-      schema_name: null,
-      symbol: null,
-      total_supply: null,
-      description: null,
-      external_link: null,
-      collection: { name: null, image_url: null }
-    };
-  }
-  /**
-   * Adds an individual NFT to the stored NFT list.
-   *
-   * @param tokenAddress - Hex address of the NFT contract.
-   * @param tokenId - The NFT identifier.
-   * @param nftMetadata - NFT optional information (name, image and description).
-   * @param nftContract - An object containing contract data of the NFT being added.
-   * @param chainId - The chainId of the network where the NFT is being added.
-   * @param userAddress - The address of the account where the NFT is being added.
-   * @param source - Whether the NFT was detected, added manually or suggested by a dapp.
-   * @returns Promise resolving to the current NFT list.
-   */
-  async addIndividualNft(tokenAddress, tokenId, nftMetadata, nftContract, chainId, userAddress, source) {
-    const releaseLock = await this.mutex.acquire();
-    try {
-      tokenAddress = toChecksumHexAddress(tokenAddress);
-      const { allNfts } = this.state;
-      const nfts = allNfts[userAddress]?.[chainId] || [];
-      const existingEntry = nfts.find(
-        (nft) => nft.address.toLowerCase() === tokenAddress.toLowerCase() && nft.tokenId === tokenId
-      );
-      if (existingEntry) {
-        const differentMetadata = compareNftMetadata(
-          nftMetadata,
-          existingEntry
-        );
-        if (differentMetadata || !existingEntry.isCurrentlyOwned) {
-          const indexToRemove = nfts.findIndex(
-            (nft) => nft.address.toLowerCase() === tokenAddress.toLowerCase() && nft.tokenId === tokenId
-          );
-          if (indexToRemove !== -1) {
-            nfts.splice(indexToRemove, 1);
-          }
-        } else {
-          return nfts;
-        }
-      }
-      const newEntry = {
-        address: tokenAddress,
-        tokenId,
-        favorite: existingEntry?.favorite || false,
-        isCurrentlyOwned: true,
-        ...nftMetadata
-      };
-      const newNfts = [...nfts, newEntry];
-      this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
-        chainId,
-        userAddress
-      });
-      if (this.onNftAdded) {
-        this.onNftAdded({
-          address: tokenAddress,
-          symbol: nftContract.symbol,
-          tokenId: tokenId.toString(),
-          standard: nftMetadata.standard,
-          source
-        });
-      }
-      return newNfts;
-    } finally {
-      releaseLock();
-    }
-  }
-  /**
-   * Adds an NFT contract to the stored NFT contracts list.
-   *
-   * @param options - options.
-   * @param options.tokenAddress - Hex address of the NFT contract.
-   * @param options.userAddress - The address of the account where the NFT is being added.
-   * @param options.nftMetadata - The retrieved NFTMetadata from API.
-   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
-   * @returns Promise resolving to the current NFT contracts list.
-   */
-  async addNftContract({
-    tokenAddress,
-    userAddress,
-    networkClientId,
-    source,
-    nftMetadata
-  }) {
-    const releaseLock = await this.mutex.acquire();
-    try {
-      tokenAddress = toChecksumHexAddress(tokenAddress);
-      const { allNftContracts } = this.state;
-      const chainId = this.getCorrectChainId({
-        networkClientId
-      });
-      const nftContracts = allNftContracts[userAddress]?.[chainId] || [];
-      const existingEntry = nftContracts.find(
-        (nftContract) => nftContract.address.toLowerCase() === tokenAddress.toLowerCase()
-      );
-      if (existingEntry) {
-        return nftContracts;
-      }
-      const contractInformation = await this.getNftContractInformation(
-        tokenAddress,
-        nftMetadata,
-        networkClientId
-      );
-      const {
-        asset_contract_type,
-        created_date,
-        symbol,
-        description,
-        external_link,
-        schema_name,
-        collection: { name, image_url, tokenCount }
-      } = contractInformation;
-      if (source === "detected" /* Detected */ && "address" in contractInformation && typeof contractInformation.address === "string" && "collection" in contractInformation && contractInformation.collection.name === null && "image_url" in contractInformation.collection && contractInformation.collection.image_url === null && Object.entries(contractInformation).every(([key, value]) => {
-        return key === "address" || key === "collection" || !value;
-      })) {
-        return nftContracts;
-      }
-      const newEntry = Object.assign(
-        {},
-        { address: tokenAddress },
-        description && { description },
-        name && { name },
-        image_url && { logo: image_url },
-        symbol && { symbol },
-        tokenCount !== null && typeof tokenCount !== "undefined" && { totalSupply: tokenCount },
-        asset_contract_type && { assetContractType: asset_contract_type },
-        created_date && { createdDate: created_date },
-        schema_name && { schemaName: schema_name },
-        external_link && { externalLink: external_link }
-      );
-      const newNftContracts = [...nftContracts, newEntry];
-      this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {
-        chainId,
-        userAddress
-      });
-      return newNftContracts;
-    } finally {
-      releaseLock();
-    }
-  }
-  /**
-   * Removes an individual NFT from the stored token list and saves it in ignored NFTs list.
-   *
-   * @param address - Hex address of the NFT contract.
-   * @param tokenId - Token identifier of the NFT.
-   * @param options - options.
-   * @param options.chainId - The chainId of the network where the NFT is being removed.
-   * @param options.userAddress - The address of the account where the NFT is being removed.
-   */
-  removeAndIgnoreIndividualNft(address, tokenId, {
-    chainId,
-    userAddress
-  }) {
-    address = toChecksumHexAddress(address);
-    const { allNfts, ignoredNfts } = this.state;
-    const newIgnoredNfts = [...ignoredNfts];
-    const nfts = allNfts[userAddress]?.[chainId] || [];
-    const newNfts = nfts.filter((nft) => {
-      if (nft.address.toLowerCase() === address.toLowerCase() && nft.tokenId === tokenId) {
-        const alreadyIgnored = newIgnoredNfts.find(
-          (c) => c.address === address && c.tokenId === tokenId
-        );
-        !alreadyIgnored && newIgnoredNfts.push(nft);
-        return false;
-      }
-      return true;
-    });
-    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
-      userAddress,
-      chainId
-    });
-    this.update({
-      ignoredNfts: newIgnoredNfts
-    });
-  }
-  /**
-   * Removes an individual NFT from the stored token list.
-   *
-   * @param address - Hex address of the NFT contract.
-   * @param tokenId - Token identifier of the NFT.
-   * @param options - options.
-   * @param options.chainId - The chainId of the network where the NFT is being removed.
-   * @param options.userAddress - The address of the account where the NFT is being removed.
-   */
-  removeIndividualNft(address, tokenId, { chainId, userAddress }) {
-    address = toChecksumHexAddress(address);
-    const { allNfts } = this.state;
-    const nfts = allNfts[userAddress]?.[chainId] || [];
-    const newNfts = nfts.filter(
-      (nft) => !(nft.address.toLowerCase() === address.toLowerCase() && nft.tokenId === tokenId)
-    );
-    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
-      userAddress,
-      chainId
-    });
-  }
-  /**
-   * Removes an NFT contract to the stored NFT contracts list.
-   *
-   * @param address - Hex address of the NFT contract.
-   * @param options - options.
-   * @param options.chainId - The chainId of the network where the NFT is being removed.
-   * @param options.userAddress - The address of the account where the NFT is being removed.
-   * @returns Promise resolving to the current NFT contracts list.
-   */
-  removeNftContract(address, { chainId, userAddress }) {
-    address = toChecksumHexAddress(address);
-    const { allNftContracts } = this.state;
-    const nftContracts = allNftContracts[userAddress]?.[chainId] || [];
-    const newNftContracts = nftContracts.filter(
-      (nftContract) => !(nftContract.address.toLowerCase() === address.toLowerCase())
-    );
-    this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {
-      chainId,
-      userAddress
-    });
-    return newNftContracts;
-  }
-  async validateWatchNft(asset, type, userAddress, { networkClientId } = {}) {
-    const { address: contractAddress, tokenId } = asset;
-    if (!type) {
-      throw rpcErrors.invalidParams("Asset type is required");
-    }
-    if (type !== ERC721 && type !== ERC1155) {
-      throw rpcErrors.invalidParams(
-        `Non NFT asset type ${type} not supported by watchNft`
-      );
-    }
-    if (!contractAddress || !tokenId) {
-      throw rpcErrors.invalidParams("Both address and tokenId are required");
-    }
-    if (!isAddress(contractAddress)) {
-      throw rpcErrors.invalidParams("Invalid address");
-    }
-    if (!/^\d+$/u.test(tokenId)) {
-      throw rpcErrors.invalidParams("Invalid tokenId");
-    }
-    try {
-      const isOwner = await this.isNftOwner(
-        userAddress,
-        contractAddress,
-        tokenId,
-        { networkClientId }
-      );
-      if (!isOwner) {
-        throw rpcErrors.invalidInput(
-          "Suggested NFT is not owned by the selected account"
-        );
-      }
-    } catch (error) {
-      if (error instanceof Error) {
-        throw rpcErrors.resourceUnavailable(error.message);
-      }
-      throw error;
-    }
-  }
-  // temporary method to get the correct chainId until we remove chainId from the config & the chainId arg from the detection logic
-  // Just a helper method to prefer the networkClient chainId first then the chainId argument and then finally the config chainId
-  getCorrectChainId({
-    networkClientId
-  }) {
-    if (networkClientId) {
-      return this.getNetworkClientById(networkClientId).configuration.chainId;
-    }
-    return this.config.chainId;
-  }
-  /**
-   * Adds a new suggestedAsset to state. Parameters will be validated according to
-   * asset type being watched. A `<suggestedNftMeta.id>:pending` hub event will be emitted once added.
-   *
-   * @param asset - The asset to be watched. For now ERC721 and ERC1155 tokens are accepted.
-   * @param asset.address - The address of the asset contract.
-   * @param asset.tokenId - The ID of the asset.
-   * @param type - The asset type.
-   * @param origin - Domain origin to register the asset from.
-   * @param options - Options bag.
-   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @param options.userAddress - The address of the account where the NFT is being added.
-   * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.
-   */
-  async watchNft(asset, type, origin, {
-    networkClientId,
-    userAddress = this.config.selectedAddress
-  } = {
-    userAddress: this.config.selectedAddress
-  }) {
-    await this.validateWatchNft(asset, type, userAddress);
-    const nftMetadata = await this.getNftInformation(
-      asset.address,
-      asset.tokenId,
-      networkClientId
-    );
-    if (nftMetadata.standard && nftMetadata.standard !== type) {
-      throw rpcErrors.invalidInput(
-        `Suggested NFT of type ${nftMetadata.standard} does not match received type ${type}`
-      );
-    }
-    const suggestedNftMeta = {
-      asset: { ...asset, ...nftMetadata },
-      type,
-      id: random(),
-      time: Date.now(),
-      interactingAddress: userAddress,
-      origin
-    };
-    await this._requestApproval(suggestedNftMeta);
-    const { address, tokenId } = asset;
-    const { name, standard, description, image } = nftMetadata;
-    await this.addNft(address, tokenId, {
-      nftMetadata: {
-        name: name ?? null,
-        description: description ?? null,
-        image: image ?? null,
-        standard: standard ?? null
-      },
-      userAddress,
-      source: "dapp" /* Dapp */,
-      networkClientId
-    });
-  }
-  /**
-   * Sets an OpenSea API key to retrieve NFT information.
-   *
-   * @param openSeaApiKey - OpenSea API key.
-   */
-  setApiKey(openSeaApiKey) {
-    this.openSeaApiKey = openSeaApiKey;
-  }
-  /**
-   * Checks the ownership of a ERC-721 or ERC-1155 NFT for a given address.
-   *
-   * @param ownerAddress - User public address.
-   * @param nftAddress - NFT contract address.
-   * @param tokenId - NFT token ID.
-   * @param options - Options bag.
-   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @returns Promise resolving the NFT ownership.
-   */
-  async isNftOwner(ownerAddress, nftAddress, tokenId, {
-    networkClientId
-  } = {}) {
-    try {
-      const owner = await this.getERC721OwnerOf(
-        nftAddress,
-        tokenId,
-        networkClientId
-      );
-      return ownerAddress.toLowerCase() === owner.toLowerCase();
-    } catch {
-    }
-    try {
-      const balance = await this.getERC1155BalanceOf(
-        ownerAddress,
-        nftAddress,
-        tokenId,
-        networkClientId
-      );
-      return !balance.isZero();
-    } catch {
-    }
-    throw new Error(
-      `Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.`
-    );
-  }
-  /**
-   * Verifies currently selected address owns entered NFT address/tokenId combo and
-   * adds the NFT and respective NFT contract to the stored NFT and NFT contracts lists.
-   *
-   * @param address - Hex address of the NFT contract.
-   * @param tokenId - The NFT identifier.
-   * @param options - an object of arguments
-   * @param options.userAddress - The address of the current user.
-   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
-   */
-  async addNftVerifyOwnership(address, tokenId, {
-    userAddress = this.config.selectedAddress,
-    networkClientId,
-    source
-  } = {
-    userAddress: this.config.selectedAddress
-  }) {
-    if (!await this.isNftOwner(userAddress, address, tokenId, {
-      networkClientId
-    })) {
-      throw new Error("This NFT is not owned by the user");
-    }
-    await this.addNft(address, tokenId, {
-      networkClientId,
-      userAddress,
-      source
-    });
-  }
-  /**
-   * Adds an NFT and respective NFT contract to the stored NFT and NFT contracts lists.
-   *
-   * @param tokenAddress - Hex address of the NFT contract.
-   * @param tokenId - The NFT identifier.
-   * @param options - an object of arguments
-   * @param options.nftMetadata - NFT optional metadata.
-   * @param options.userAddress - The address of the current user.
-   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.
-   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @returns Promise resolving to the current NFT list.
-   */
-  async addNft(tokenAddress, tokenId, {
-    nftMetadata,
-    userAddress = this.config.selectedAddress,
-    source = "custom" /* Custom */,
-    networkClientId
-  } = { userAddress: this.config.selectedAddress }) {
-    tokenAddress = toChecksumHexAddress(tokenAddress);
-    const chainId = this.getCorrectChainId({ networkClientId });
-    nftMetadata = nftMetadata || await this.getNftInformation(tokenAddress, tokenId, networkClientId);
-    const newNftContracts = await this.addNftContract({
-      tokenAddress,
-      userAddress,
-      networkClientId,
-      source,
-      nftMetadata
-    });
-    const nftContract = newNftContracts.find(
-      (contract) => contract.address.toLowerCase() === tokenAddress.toLowerCase()
-    );
-    if (nftContract) {
-      await this.addIndividualNft(
-        tokenAddress,
-        tokenId,
-        nftMetadata,
-        nftContract,
-        chainId,
-        userAddress,
-        source
-      );
-    }
-  }
-  /**
-   * Refetches NFT metadata and updates the state
-   *
-   * @param options - Options for refetching NFT metadata
-   * @param options.nfts - nfts to update metadata for.
-   * @param options.userAddress - The current user address
-   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   */
-  async updateNftMetadata({
-    nfts,
-    userAddress = this.config.selectedAddress,
-    networkClientId
-  }) {
-    const chainId = this.getCorrectChainId({ networkClientId });
-    const nftsWithChecksumAdr = nfts.map((nft) => {
-      return {
-        ...nft,
-        address: toChecksumHexAddress(nft.address)
-      };
-    });
-    const nftMetadataResults = await Promise.allSettled(
-      nftsWithChecksumAdr.map(async (nft) => {
-        const resMetadata = await this.getNftInformation(
-          nft.address,
-          nft.tokenId,
-          networkClientId
-        );
-        return {
-          nft,
-          newMetadata: resMetadata
-        };
-      })
-    );
-    nftMetadataResults.filter(
-      (result) => result.status === "fulfilled"
-    ).forEach(
-      (elm) => this.updateNft(
-        elm.value.nft,
-        elm.value.newMetadata,
-        userAddress,
-        chainId
-      )
-    );
-  }
-  /**
-   * Removes an NFT from the stored token list.
-   *
-   * @param address - Hex address of the NFT contract.
-   * @param tokenId - Token identifier of the NFT.
-   * @param options - an object of arguments
-   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @param options.userAddress - The address of the account where the NFT is being removed.
-   */
-  removeNft(address, tokenId, {
-    networkClientId,
-    userAddress = this.config.selectedAddress
-  } = {
-    userAddress: this.config.selectedAddress
-  }) {
-    const chainId = this.getCorrectChainId({ networkClientId });
-    address = toChecksumHexAddress(address);
-    this.removeIndividualNft(address, tokenId, { chainId, userAddress });
-    const { allNfts } = this.state;
-    const nfts = allNfts[userAddress]?.[chainId] || [];
-    const remainingNft = nfts.find(
-      (nft) => nft.address.toLowerCase() === address.toLowerCase()
-    );
-    if (!remainingNft) {
-      this.removeNftContract(address, { chainId, userAddress });
-    }
-  }
-  /**
-   * Removes an NFT from the stored token list and saves it in ignored NFTs list.
-   *
-   * @param address - Hex address of the NFT contract.
-   * @param tokenId - Token identifier of the NFT.
-   * @param options - an object of arguments
-   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @param options.userAddress - The address of the account where the NFT is being removed.
-   */
-  removeAndIgnoreNft(address, tokenId, {
-    networkClientId,
-    userAddress = this.config.selectedAddress
-  } = {
-    userAddress: this.config.selectedAddress
-  }) {
-    const chainId = this.getCorrectChainId({ networkClientId });
-    address = toChecksumHexAddress(address);
-    this.removeAndIgnoreIndividualNft(address, tokenId, {
-      chainId,
-      userAddress
-    });
-    const { allNfts } = this.state;
-    const nfts = allNfts[userAddress]?.[chainId] || [];
-    const remainingNft = nfts.find(
-      (nft) => nft.address.toLowerCase() === address.toLowerCase()
-    );
-    if (!remainingNft) {
-      this.removeNftContract(address, { chainId, userAddress });
-    }
-  }
-  /**
-   * Removes all NFTs from the ignored list.
-   */
-  clearIgnoredNfts() {
-    this.update({ ignoredNfts: [] });
-  }
-  /**
-   * Checks whether input NFT is still owned by the user
-   * And updates the isCurrentlyOwned value on the NFT object accordingly.
-   *
-   * @param nft - The NFT object to check and update.
-   * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.
-   * @param accountParams - The userAddress and chainId to check ownership against
-   * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure assets are stored to the correct account
-   * @param accountParams.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @returns the NFT with the updated isCurrentlyOwned value
-   */
-  async checkAndUpdateSingleNftOwnershipStatus(nft, batch, {
-    userAddress = this.config.selectedAddress,
-    networkClientId
-  } = {
-    userAddress: this.config.selectedAddress
-  }) {
-    const chainId = this.getCorrectChainId({ networkClientId });
-    const { address, tokenId } = nft;
-    let isOwned = nft.isCurrentlyOwned;
-    try {
-      isOwned = await this.isNftOwner(userAddress, address, tokenId, {
-        networkClientId
-      });
-    } catch {
-    }
-    nft.isCurrentlyOwned = isOwned;
-    if (batch) {
-      return nft;
-    }
-    const { allNfts } = this.state;
-    const nfts = allNfts[userAddress]?.[chainId] || [];
-    const nftToUpdate = nfts.find(
-      (item) => item.tokenId === tokenId && item.address.toLowerCase() === address.toLowerCase()
-    );
-    if (nftToUpdate) {
-      nftToUpdate.isCurrentlyOwned = isOwned;
-      this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {
-        userAddress,
-        chainId
-      });
-    }
-    return nft;
-  }
-  /**
-   * Checks whether NFTs associated with current selectedAddress/chainId combination are still owned by the user
-   * And updates the isCurrentlyOwned value on each accordingly.
-   * @param options - an object of arguments
-   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @param options.userAddress - The address of the account where the NFT ownership status is checked/updated.
-   */
-  async checkAndUpdateAllNftsOwnershipStatus({
-    networkClientId,
-    userAddress = this.config.selectedAddress
-  } = {
-    userAddress: this.config.selectedAddress
-  }) {
-    const chainId = this.getCorrectChainId({ networkClientId });
-    const { allNfts } = this.state;
-    const nfts = allNfts[userAddress]?.[chainId] || [];
-    const updatedNfts = await Promise.all(
-      nfts.map(async (nft) => {
-        return await this.checkAndUpdateSingleNftOwnershipStatus(nft, true, {
-          networkClientId,
-          userAddress
-        }) ?? nft;
-      })
-    );
-    this.updateNestedNftState(updatedNfts, ALL_NFTS_STATE_KEY, {
-      userAddress,
-      chainId
-    });
-  }
-  /**
-   * Update NFT favorite status.
-   *
-   * @param address - Hex address of the NFT contract.
-   * @param tokenId - Hex address of the NFT contract.
-   * @param favorite - NFT new favorite status.
-   * @param options - an object of arguments
-   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
-   * @param options.userAddress - The address of the account where the NFT is being removed.
-   */
-  updateNftFavoriteStatus(address, tokenId, favorite, {
-    networkClientId,
-    userAddress = this.config.selectedAddress
-  } = {
-    userAddress: this.config.selectedAddress
-  }) {
-    const chainId = this.getCorrectChainId({ networkClientId });
-    const { allNfts } = this.state;
-    const nfts = allNfts[userAddress]?.[chainId] || [];
-    const index = nfts.findIndex(
-      (nft) => nft.address === address && nft.tokenId === tokenId
-    );
-    if (index === -1) {
-      return;
-    }
-    const updatedNft = {
-      ...nfts[index],
-      favorite
-    };
-    nfts[index] = updatedNft;
-    this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {
-      chainId,
-      userAddress
-    });
-  }
-  /**
-   * Returns an NFT by the address and token id.
-   *
-   * @param address - Hex address of the NFT contract.
-   * @param tokenId - Number that represents the id of the token.
-   * @param selectedAddress - Hex address of the user account.
-   * @param chainId - Id of the current network.
-   * @returns Object containing the NFT and its position in the array
-   */
-  findNftByAddressAndTokenId(address, tokenId, selectedAddress, chainId) {
-    const { allNfts } = this.state;
-    const nfts = allNfts[selectedAddress]?.[chainId] || [];
-    const index = nfts.findIndex(
-      (nft) => nft.address.toLowerCase() === address.toLowerCase() && nft.tokenId === tokenId
-    );
-    if (index === -1) {
-      return null;
-    }
-    return { nft: nfts[index], index };
-  }
-  /**
-   * Update NFT data.
-   *
-   * @param nft - NFT object to find the right NFT to updates.
-   * @param updates - NFT partial object to update properties of the NFT.
-   * @param selectedAddress - Hex address of the user account.
-   * @param chainId - Id of the current network.
-   */
-  updateNft(nft, updates, selectedAddress, chainId) {
-    const { allNfts } = this.state;
-    const nfts = allNfts[selectedAddress]?.[chainId] || [];
-    const nftInfo = this.findNftByAddressAndTokenId(
-      nft.address,
-      nft.tokenId,
-      selectedAddress,
-      chainId
-    );
-    if (!nftInfo) {
-      return;
-    }
-    const updatedNft = {
-      ...nft,
-      ...updates
-    };
-    const newNfts = [
-      ...nfts.slice(0, nftInfo.index),
-      updatedNft,
-      ...nfts.slice(nftInfo.index + 1)
-    ];
-    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
-      chainId,
-      userAddress: selectedAddress
-    });
-  }
-  /**
-   * Resets the transaction status of an NFT.
-   *
-   * @param transactionId - NFT transaction id.
-   * @param selectedAddress - Hex address of the user account.
-   * @param chainId - Id of the current network.
-   * @returns a boolean indicating if the reset was well succeeded or not
-   */
-  resetNftTransactionStatusByTransactionId(transactionId, selectedAddress, chainId) {
-    const { allNfts } = this.state;
-    const nfts = allNfts[selectedAddress]?.[chainId] || [];
-    const index = nfts.findIndex(
-      (nft) => nft.transactionId === transactionId
-    );
-    if (index === -1) {
-      return false;
-    }
-    const updatedNft = {
-      ...nfts[index],
-      transactionId: void 0
-    };
-    const newNfts = [
-      ...nfts.slice(0, index),
-      updatedNft,
-      ...nfts.slice(index + 1)
-    ];
-    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {
-      chainId,
-      userAddress: selectedAddress
-    });
-    return true;
-  }
-  async _requestApproval(suggestedNftMeta) {
-    return this.messagingSystem.call(
-      "ApprovalController:addRequest",
-      {
-        id: suggestedNftMeta.id,
-        origin: suggestedNftMeta.origin,
-        type: ApprovalType.WatchAsset,
-        requestData: {
-          id: suggestedNftMeta.id,
-          interactingAddress: suggestedNftMeta.interactingAddress,
-          asset: {
-            address: suggestedNftMeta.asset.address,
-            tokenId: suggestedNftMeta.asset.tokenId,
-            name: suggestedNftMeta.asset.name,
-            description: suggestedNftMeta.asset.description,
-            image: suggestedNftMeta.asset.image,
-            standard: suggestedNftMeta.asset.standard
-          }
-        }
-      },
-      true
-    );
-  }
-};
-var NftController_default = NftController;
-
-export {
-  getDefaultNftState,
-  NftController,
-  NftController_default
-};
-//# sourceMappingURL=chunk-S6CZP74C.mjs.map
\ No newline at end of file
diff --git a/dist/chunk-S6CZP74C.mjs.map b/dist/chunk-S6CZP74C.mjs.map
deleted file mode 100644
index ea50f02ef27cc2e66a447e1b08a2c52acbded0b5..0000000000000000000000000000000000000000
--- a/dist/chunk-S6CZP74C.mjs.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["../src/NftController.ts"],"sourcesContent":["import { isAddress } from '@ethersproject/address';\nimport type { AddApprovalRequest } from '@metamask/approval-controller';\nimport type {\n  BaseConfig,\n  BaseState,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseControllerV1 } from '@metamask/base-controller';\nimport {\n  safelyExecute,\n  handleFetch,\n  toChecksumHexAddress,\n  BNToHex,\n  fetchWithErrorHandling,\n  IPFS_DEFAULT_GATEWAY_URL,\n  ERC721,\n  ERC1155,\n  ApprovalType,\n  NFT_API_BASE_URL,\n} from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkController,\n  NetworkState,\n} from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { Hex } from '@metamask/utils';\nimport { remove0x } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport BN from 'bn.js';\nimport { EventEmitter } from 'events';\nimport { v4 as random } from 'uuid';\n\nimport type { AssetsContractController } from './AssetsContractController';\nimport { compareNftMetadata, getFormattedIpfsUrl } from './assetsUtil';\nimport { Source } from './constants';\nimport type {\n  ApiNftContract,\n  ReservoirResponse,\n  Collection,\n  Attributes,\n  LastSale,\n} from './NftDetectionController';\n\ntype NFTStandardType = 'ERC721' | 'ERC1155';\n\ntype SuggestedNftMeta = {\n  asset: { address: string; tokenId: string } & NftMetadata;\n  id: string;\n  time: number;\n  type: NFTStandardType;\n  interactingAddress: string;\n  origin: string;\n};\n\n/**\n * @type Nft\n *\n * NFT representation\n * @property address - Hex address of a ERC721 contract\n * @property description - The NFT description\n * @property image - URI of custom NFT image associated with this tokenId\n * @property name - Name associated with this tokenId and contract address\n * @property tokenId - The NFT identifier\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property isCurrentlyOwned - Boolean indicating whether the address/chainId combination where it's currently stored currently owns this NFT\n * @property transactionId - Transaction Id associated with the NFT\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface Nft extends NftMetadata {\n  tokenId: string;\n  address: string;\n  isCurrentlyOwned?: boolean;\n}\n\ntype NftUpdate = {\n  nft: Nft;\n  newMetadata: NftMetadata;\n};\n\n/**\n * @type NftContract\n *\n * NFT contract information representation\n * @property name - Contract name\n * @property logo - Contract logo\n * @property address - Contract address\n * @property symbol - Contract symbol\n * @property description - Contract description\n * @property totalSupply - Total supply of NFTs\n * @property assetContractType - The NFT type, it could be `semi-fungible` or `non-fungible`\n * @property createdDate - Creation date\n * @property schemaName - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property externalLink - External link containing additional information\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftContract {\n  name?: string;\n  logo?: string;\n  address: string;\n  symbol?: string;\n  description?: string;\n  totalSupply?: string;\n  assetContractType?: string;\n  createdDate?: string;\n  schemaName?: string;\n  externalLink?: string;\n}\n\n/**\n * @type NftMetadata\n *\n * NFT custom information\n * @property name - NFT custom name\n * @property description - The NFT description\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property image - Image custom image URI\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property standard - NFT standard name for the NFT, e.g., ERC-721 or ERC-1155\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftMetadata {\n  name: string | null;\n  description: string | null;\n  image: string | null;\n  standard: string | null;\n  favorite?: boolean;\n  numberOfSales?: number;\n  backgroundColor?: string;\n  imagePreview?: string;\n  imageThumbnail?: string;\n  imageOriginal?: string;\n  animation?: string;\n  animationOriginal?: string;\n  externalLink?: string;\n  creator?: string;\n  transactionId?: string;\n  tokenURI?: string | null;\n  collection?: Collection;\n  address?: string;\n  attributes?: Attributes;\n  lastSale?: LastSale;\n  rarityRank?: string;\n}\n\n/**\n * @type NftConfig\n *\n * NFT controller configuration\n * @property selectedAddress - Vault selected address\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftConfig extends BaseConfig {\n  selectedAddress: string;\n  chainId: Hex;\n  ipfsGateway: string;\n  openSeaEnabled: boolean;\n  useIPFSSubdomains: boolean;\n  isIpfsGatewayEnabled: boolean;\n}\n\n/**\n * @type NftState\n *\n * NFT controller state\n * @property allNftContracts - Object containing NFT contract information\n * @property allNfts - Object containing NFTs per account and network\n * @property ignoredNfts - List of NFTs that should be ignored\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface NftState extends BaseState {\n  allNftContracts: {\n    [key: string]: { [chainId: Hex]: NftContract[] };\n  };\n  allNfts: { [key: string]: { [chainId: Hex]: Nft[] } };\n  ignoredNfts: Nft[];\n}\n\nconst ALL_NFTS_STATE_KEY = 'allNfts';\nconst ALL_NFTS_CONTRACTS_STATE_KEY = 'allNftContracts';\n\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\ninterface NftAsset {\n  address: string;\n  tokenId: string;\n}\n\n/**\n * The name of the {@link NftController}.\n */\nconst controllerName = 'NftController';\n\n/**\n * The external actions available to the {@link NftController}.\n */\ntype AllowedActions = AddApprovalRequest;\n\n/**\n * The messenger of the {@link NftController}.\n */\nexport type NftControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  AllowedActions,\n  never,\n  AllowedActions['type'],\n  never\n>;\n\nexport const getDefaultNftState = (): NftState => {\n  return {\n    allNftContracts: {},\n    allNfts: {},\n    ignoredNfts: [],\n  };\n};\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class NftController extends BaseControllerV1<NftConfig, NftState> {\n  private readonly mutex = new Mutex();\n\n  private readonly messagingSystem: NftControllerMessenger;\n\n  getNftApi() {\n    return `${NFT_API_BASE_URL}/tokens`;\n  }\n\n  /**\n   * Helper method to update nested state for allNfts and allNftContracts.\n   *\n   * @param newCollection - the modified piece of state to update in the controller's store\n   * @param baseStateKey - The root key in the store to update.\n   * @param passedConfig - An object containing the selectedAddress and chainId that are passed through the auto-detection flow.\n   * @param passedConfig.userAddress - the address passed through the NFT detection flow to ensure assets are stored to the correct account\n   * @param passedConfig.chainId - the chainId passed through the NFT detection flow to ensure assets are stored to the correct account\n   */\n  private updateNestedNftState(\n    newCollection: Nft[] | NftContract[],\n    baseStateKey: 'allNfts' | 'allNftContracts',\n    { userAddress, chainId }: { userAddress: string; chainId: Hex },\n  ) {\n    const { [baseStateKey]: oldState } = this.state;\n\n    const addressState = oldState[userAddress];\n    const newAddressState = {\n      ...addressState,\n      ...{ [chainId]: newCollection },\n    };\n    const newState = {\n      ...oldState,\n      ...{ [userAddress]: newAddressState },\n    };\n    this.update({\n      [baseStateKey]: newState,\n    });\n  }\n\n  /**\n   * Request individual NFT information from NFT API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromApi(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<NftMetadata> {\n    // TODO Parameterize this by chainId for non-mainnet token detection\n    // Attempt to fetch the data with the nft-api\n    const urlParams = new URLSearchParams({\n      chainIds: '1',\n      tokens: `${contractAddress}:${tokenId}`,\n      includeTopBid: 'true',\n      includeAttributes: 'true',\n      includeLastSale: 'true',\n    }).toString();\n    const nftInformation: ReservoirResponse | undefined =\n      await fetchWithErrorHandling({\n        url: `${this.getNftApi()}?${urlParams}`,\n        options: {\n          headers: {\n            Version: '1',\n          },\n        },\n      });\n    // if we were still unable to fetch the data we return out the default/null of `NftMetadata`\n    if (!nftInformation?.tokens?.[0]?.token) {\n      return {\n        name: null,\n        description: null,\n        image: null,\n        standard: null,\n      };\n    }\n\n    // if we've reached this point, we have successfully fetched some data for nftInformation\n    // now we reconfigure the data to conform to the `NftMetadata` type for storage.\n\n    const {\n      image,\n      metadata: { imageOriginal } = {},\n      name,\n      description,\n      collection,\n      kind,\n      rarityRank,\n      rarity,\n      attributes,\n      lastSale,\n      imageSmall,\n    } = nftInformation.tokens[0].token;\n\n    /* istanbul ignore next */\n    const nftMetadata: NftMetadata = Object.assign(\n      {},\n      { name: name || null },\n      { description: description || null },\n      { image: image || null },\n      collection?.creator && { creator: collection.creator },\n      imageOriginal && { imageOriginal },\n      imageSmall && { imageThumbnail: imageSmall },\n      kind && { standard: kind.toUpperCase() },\n      lastSale && { lastSale },\n      attributes && { attributes },\n      nftInformation.tokens[0].market?.topBid && {\n        topBid: nftInformation.tokens[0].market?.topBid,\n      },\n      rarityRank && { rarityRank },\n      rarity && { rarity },\n      collection && { collection },\n    );\n\n    return nftMetadata;\n  }\n\n  /**\n   * Request individual NFT information from contracts that follows Metadata Interface.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromTokenURI(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<NftMetadata> {\n    const { ipfsGateway, useIPFSSubdomains, isIpfsGatewayEnabled } =\n      this.config;\n    const result = await this.getNftURIAndStandard(\n      contractAddress,\n      tokenId,\n      networkClientId,\n    );\n    let tokenURI = result[0];\n    const standard = result[1];\n\n    const hasIpfsTokenURI = tokenURI.startsWith('ipfs://');\n\n    if (hasIpfsTokenURI && !isIpfsGatewayEnabled) {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n\n    const isDisplayNFTMediaToggleEnabled = this.config.openSeaEnabled;\n    if (!hasIpfsTokenURI && !isDisplayNFTMediaToggleEnabled) {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n\n    if (hasIpfsTokenURI) {\n      tokenURI = getFormattedIpfsUrl(ipfsGateway, tokenURI, useIPFSSubdomains);\n    }\n\n    try {\n      const object = await handleFetch(tokenURI);\n      // TODO: Check image_url existence. This is not part of EIP721 nor EIP1155\n      const image = Object.prototype.hasOwnProperty.call(object, 'image')\n        ? 'image'\n        : /* istanbul ignore next */ 'image_url';\n\n      return {\n        image: object[image],\n        name: object.name,\n        description: object.description,\n        standard,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    } catch {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n        tokenURI: tokenURI ?? null,\n      };\n    }\n  }\n\n  /**\n   * Retrieve NFT uri with  metadata. TODO Update method to use IPFS.\n   *\n   * @param contractAddress - NFT contract address.\n   * @param tokenId - NFT token id.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving NFT uri and token standard.\n   */\n  private async getNftURIAndStandard(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<[string, string]> {\n    // try ERC721 uri\n    try {\n      const uri = await this.getERC721TokenURI(\n        contractAddress,\n        tokenId,\n        networkClientId,\n      );\n      return [uri, ERC721];\n    } catch {\n      // Ignore error\n    }\n\n    // try ERC1155 uri\n    try {\n      const tokenURI = await this.getERC1155TokenURI(\n        contractAddress,\n        tokenId,\n        networkClientId,\n      );\n\n      /**\n       * According to EIP1155 the URI value allows for ID substitution\n       * in case the string `{id}` exists.\n       * https://eips.ethereum.org/EIPS/eip-1155#metadata\n       */\n\n      if (!tokenURI.includes('{id}')) {\n        return [tokenURI, ERC1155];\n      }\n\n      const hexTokenId = remove0x(BNToHex(new BN(tokenId)))\n        .padStart(64, '0')\n        .toLowerCase();\n      return [tokenURI.replace('{id}', hexTokenId), ERC1155];\n    } catch {\n      // Ignore error\n    }\n\n    return ['', ''];\n  }\n\n  /**\n   * Request individual NFT information (name, image url and description).\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformation(\n    contractAddress: string,\n    tokenId: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<NftMetadata> {\n    const chainId = this.getCorrectChainId({\n      networkClientId,\n    });\n    const [blockchainMetadata, nftApiMetadata] = await Promise.all([\n      safelyExecute(() =>\n        this.getNftInformationFromTokenURI(\n          contractAddress,\n          tokenId,\n          networkClientId,\n        ),\n      ),\n      this.config.openSeaEnabled && chainId === '0x1'\n        ? safelyExecute(() =>\n            this.getNftInformationFromApi(contractAddress, tokenId),\n          )\n        : undefined,\n    ]);\n    return {\n      ...nftApiMetadata,\n      name: blockchainMetadata?.name ?? nftApiMetadata?.name ?? null,\n      description:\n        blockchainMetadata?.description ?? nftApiMetadata?.description ?? null,\n      image: blockchainMetadata?.image ?? nftApiMetadata?.image ?? null,\n      standard:\n        blockchainMetadata?.standard ?? nftApiMetadata?.standard ?? null,\n      tokenURI: blockchainMetadata?.tokenURI ?? null,\n    };\n  }\n\n  /**\n   * Request NFT contract information from the contract itself.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftContractInformationFromContract(\n    contractAddress: string,\n    networkClientId?: NetworkClientId,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const [name, symbol] = await Promise.all([\n      this.getERC721AssetName(contractAddress, networkClientId),\n      this.getERC721AssetSymbol(contractAddress, networkClientId),\n    ]);\n\n    return {\n      collection: { name },\n      symbol,\n      address: contractAddress,\n    };\n  }\n\n  /**\n   * Request NFT contract information from Blockchain and aggregate with received data from NFTMetadata.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param nftMetadataFromApi - Received NFT information to be aggregated with blockchain contract information.\n   * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the NFT contract name, image and description.\n   */\n  private async getNftContractInformation(\n    contractAddress: string,\n    nftMetadataFromApi: NftMetadata,\n    networkClientId?: NetworkClientId,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const blockchainContractData = await safelyExecute(() =>\n      this.getNftContractInformationFromContract(\n        contractAddress,\n        networkClientId,\n      ),\n    );\n\n    if (\n      blockchainContractData ||\n      !Object.values(nftMetadataFromApi).every((value) => value === null)\n    ) {\n      return {\n        address: contractAddress,\n        ...blockchainContractData,\n        schema_name: nftMetadataFromApi?.standard ?? null,\n        collection: {\n          name: null,\n          image_url:\n            nftMetadataFromApi?.collection?.image ??\n            nftMetadataFromApi?.collection?.imageUrl ??\n            null,\n          tokenCount: nftMetadataFromApi?.collection?.tokenCount ?? null,\n          ...nftMetadataFromApi?.collection,\n          ...blockchainContractData?.collection,\n        },\n      };\n    }\n\n    /* istanbul ignore next */\n    return {\n      address: contractAddress,\n      asset_contract_type: null,\n      created_date: null,\n      schema_name: null,\n      symbol: null,\n      total_supply: null,\n      description: null,\n      external_link: null,\n      collection: { name: null, image_url: null },\n    };\n  }\n\n  /**\n   * Adds an individual NFT to the stored NFT list.\n   *\n   * @param tokenAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param nftMetadata - NFT optional information (name, image and description).\n   * @param nftContract - An object containing contract data of the NFT being added.\n   * @param chainId - The chainId of the network where the NFT is being added.\n   * @param userAddress - The address of the account where the NFT is being added.\n   * @param source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @returns Promise resolving to the current NFT list.\n   */\n  private async addIndividualNft(\n    tokenAddress: string,\n    tokenId: string,\n    nftMetadata: NftMetadata,\n    nftContract: NftContract,\n    chainId: Hex,\n    userAddress: string,\n    source: Source,\n  ): Promise<Nft[]> {\n    // TODO: Remove unused return\n    const releaseLock = await this.mutex.acquire();\n    try {\n      tokenAddress = toChecksumHexAddress(tokenAddress);\n      const { allNfts } = this.state;\n\n      const nfts = allNfts[userAddress]?.[chainId] || [];\n\n      const existingEntry: Nft | undefined = nfts.find(\n        (nft) =>\n          nft.address.toLowerCase() === tokenAddress.toLowerCase() &&\n          nft.tokenId === tokenId,\n      );\n\n      if (existingEntry) {\n        const differentMetadata = compareNftMetadata(\n          nftMetadata,\n          existingEntry,\n        );\n        if (differentMetadata || !existingEntry.isCurrentlyOwned) {\n          // TODO: Switch to indexToUpdate\n          const indexToRemove = nfts.findIndex(\n            (nft) =>\n              nft.address.toLowerCase() === tokenAddress.toLowerCase() &&\n              nft.tokenId === tokenId,\n          );\n          /* istanbul ignore next */\n          if (indexToRemove !== -1) {\n            nfts.splice(indexToRemove, 1);\n          }\n        } else {\n          return nfts;\n        }\n      }\n\n      const newEntry: Nft = {\n        address: tokenAddress,\n        tokenId,\n        favorite: existingEntry?.favorite || false,\n        isCurrentlyOwned: true,\n        ...nftMetadata,\n      };\n\n      const newNfts = [...nfts, newEntry];\n      this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n        chainId,\n        userAddress,\n      });\n\n      if (this.onNftAdded) {\n        this.onNftAdded({\n          address: tokenAddress,\n          symbol: nftContract.symbol,\n          tokenId: tokenId.toString(),\n          standard: nftMetadata.standard,\n          source,\n        });\n      }\n      return newNfts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds an NFT contract to the stored NFT contracts list.\n   *\n   * @param options - options.\n   * @param options.tokenAddress - Hex address of the NFT contract.\n   * @param options.userAddress - The address of the account where the NFT is being added.\n   * @param options.nftMetadata - The retrieved NFTMetadata from API.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private async addNftContract({\n    tokenAddress,\n    userAddress,\n    networkClientId,\n    source,\n    nftMetadata,\n  }: {\n    tokenAddress: string;\n    userAddress: string;\n    nftMetadata: NftMetadata;\n    networkClientId?: NetworkClientId;\n    source?: Source;\n  }): Promise<NftContract[]> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      tokenAddress = toChecksumHexAddress(tokenAddress);\n      const { allNftContracts } = this.state;\n      const chainId = this.getCorrectChainId({\n        networkClientId,\n      });\n\n      const nftContracts = allNftContracts[userAddress]?.[chainId] || [];\n\n      const existingEntry = nftContracts.find(\n        (nftContract) =>\n          nftContract.address.toLowerCase() === tokenAddress.toLowerCase(),\n      );\n      if (existingEntry) {\n        return nftContracts;\n      }\n\n      // this doesn't work currently for detection if the user switches networks while the detection is processing\n      // will be fixed once detection uses networkClientIds\n      // get name and symbol if ERC721 then put together the metadata\n      const contractInformation = await this.getNftContractInformation(\n        tokenAddress,\n        nftMetadata,\n        networkClientId,\n      );\n      const {\n        asset_contract_type,\n        created_date,\n        symbol,\n        description,\n        external_link,\n        schema_name,\n        collection: { name, image_url, tokenCount },\n      } = contractInformation;\n\n      // If the nft is auto-detected we want some valid metadata to be present\n      if (\n        source === Source.Detected &&\n        'address' in contractInformation &&\n        typeof contractInformation.address === 'string' &&\n        'collection' in contractInformation &&\n        contractInformation.collection.name === null &&\n        'image_url' in contractInformation.collection &&\n        contractInformation.collection.image_url === null &&\n        Object.entries(contractInformation).every(([key, value]) => {\n          return key === 'address' || key === 'collection' || !value;\n        })\n      ) {\n        return nftContracts;\n      }\n\n      /* istanbul ignore next */\n      const newEntry: NftContract = Object.assign(\n        {},\n        { address: tokenAddress },\n        description && { description },\n        name && { name },\n        image_url && { logo: image_url },\n        symbol && { symbol },\n        tokenCount !== null &&\n          typeof tokenCount !== 'undefined' && { totalSupply: tokenCount },\n        asset_contract_type && { assetContractType: asset_contract_type },\n        created_date && { createdDate: created_date },\n        schema_name && { schemaName: schema_name },\n        external_link && { externalLink: external_link },\n      );\n      const newNftContracts = [...nftContracts, newEntry];\n      this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {\n        chainId,\n        userAddress,\n      });\n\n      return newNftContracts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - options.\n   * @param options.chainId - The chainId of the network where the NFT is being removed.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  private removeAndIgnoreIndividualNft(\n    address: string,\n    tokenId: string,\n    {\n      chainId,\n      userAddress,\n    }: {\n      chainId: Hex;\n      userAddress: string;\n    },\n  ) {\n    address = toChecksumHexAddress(address);\n    const { allNfts, ignoredNfts } = this.state;\n    const newIgnoredNfts = [...ignoredNfts];\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const newNfts = nfts.filter((nft) => {\n      if (\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId\n      ) {\n        const alreadyIgnored = newIgnoredNfts.find(\n          (c) => c.address === address && c.tokenId === tokenId,\n        );\n        !alreadyIgnored && newIgnoredNfts.push(nft);\n        return false;\n      }\n      return true;\n    });\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      userAddress,\n      chainId,\n    });\n\n    this.update({\n      ignoredNfts: newIgnoredNfts,\n    });\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - options.\n   * @param options.chainId - The chainId of the network where the NFT is being removed.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  private removeIndividualNft(\n    address: string,\n    tokenId: string,\n    { chainId, userAddress }: { chainId: Hex; userAddress: string },\n  ) {\n    address = toChecksumHexAddress(address);\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const newNfts = nfts.filter(\n      (nft) =>\n        !(\n          nft.address.toLowerCase() === address.toLowerCase() &&\n          nft.tokenId === tokenId\n        ),\n    );\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      userAddress,\n      chainId,\n    });\n  }\n\n  /**\n   * Removes an NFT contract to the stored NFT contracts list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param options - options.\n   * @param options.chainId - The chainId of the network where the NFT is being removed.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private removeNftContract(\n    address: string,\n    { chainId, userAddress }: { chainId: Hex; userAddress: string },\n  ): NftContract[] {\n    address = toChecksumHexAddress(address);\n    const { allNftContracts } = this.state;\n    const nftContracts = allNftContracts[userAddress]?.[chainId] || [];\n\n    const newNftContracts = nftContracts.filter(\n      (nftContract) =>\n        !(nftContract.address.toLowerCase() === address.toLowerCase()),\n    );\n    this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {\n      chainId,\n      userAddress,\n    });\n\n    return newNftContracts;\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Optional API key to use with opensea\n   */\n  openSeaApiKey?: string;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'NftController';\n\n  private readonly getERC721AssetName: AssetsContractController['getERC721AssetName'];\n\n  private readonly getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n\n  private readonly getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n\n  private readonly getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n\n  private readonly getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n\n  private readonly getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n\n  private readonly getNetworkClientById: NetworkController['getNetworkClientById'];\n\n  private readonly onNftAdded?: (data: {\n    address: string;\n    symbol: string | undefined;\n    tokenId: string;\n    standard: string | null;\n    source: Source;\n  }) => void;\n\n  /**\n   * Creates an NftController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getERC721AssetName - Gets the name of the asset at the given address.\n   * @param options.getERC721AssetSymbol - Gets the symbol of the asset at the given address.\n   * @param options.getERC721TokenURI - Gets the URI of the ERC721 token at the given address, with the given ID.\n   * @param options.getERC721OwnerOf - Get the owner of a ERC-721 NFT.\n   * @param options.getERC1155BalanceOf - Gets balance of a ERC-1155 NFT.\n   * @param options.getERC1155TokenURI - Gets the URI of the ERC1155 token at the given address, with the given ID.\n   * @param options.getNetworkClientById - Gets the network client for the given networkClientId.\n   * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data\n   * for tracking the NFT added event.\n   * @param options.messenger - The controller messenger.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      chainId: initialChainId,\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getERC721AssetName,\n      getERC721AssetSymbol,\n      getERC721TokenURI,\n      getERC721OwnerOf,\n      getERC1155BalanceOf,\n      getERC1155TokenURI,\n      getNetworkClientById,\n      onNftAdded,\n      messenger,\n    }: {\n      chainId: Hex;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getERC721AssetName: AssetsContractController['getERC721AssetName'];\n      getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n      getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n      getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n      getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n      getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n      getNetworkClientById: NetworkController['getNetworkClientById'];\n      onNftAdded?: (data: {\n        address: string;\n        symbol: string | undefined;\n        tokenId: string;\n        standard: string | null;\n        source: string;\n      }) => void;\n      messenger: NftControllerMessenger;\n    },\n    config?: Partial<BaseConfig>,\n    state?: Partial<NftState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      selectedAddress: '',\n      chainId: initialChainId,\n      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,\n      openSeaEnabled: false,\n      useIPFSSubdomains: true,\n      isIpfsGatewayEnabled: true,\n    };\n\n    this.defaultState = getDefaultNftState();\n    this.initialize();\n    this.getERC721AssetName = getERC721AssetName;\n    this.getERC721AssetSymbol = getERC721AssetSymbol;\n    this.getERC721TokenURI = getERC721TokenURI;\n    this.getERC721OwnerOf = getERC721OwnerOf;\n    this.getERC1155BalanceOf = getERC1155BalanceOf;\n    this.getERC1155TokenURI = getERC1155TokenURI;\n    this.getNetworkClientById = getNetworkClientById;\n    this.onNftAdded = onNftAdded;\n    this.messagingSystem = messenger;\n\n    onPreferencesStateChange(\n      async ({\n        selectedAddress,\n        ipfsGateway,\n        openSeaEnabled,\n        isIpfsGatewayEnabled,\n      }) => {\n        this.configure({\n          selectedAddress,\n          ipfsGateway,\n          openSeaEnabled,\n          isIpfsGatewayEnabled,\n        });\n\n        const needsUpdateNftMetadata =\n          (isIpfsGatewayEnabled && ipfsGateway !== '') || openSeaEnabled;\n\n        if (needsUpdateNftMetadata) {\n          const { chainId } = this.config;\n          const nfts: Nft[] =\n            this.state.allNfts[selectedAddress]?.[chainId] ?? [];\n          // filter only nfts\n          const nftsToUpdate = nfts.filter(\n            (singleNft) =>\n              !singleNft.name && !singleNft.description && !singleNft.image,\n          );\n          if (nftsToUpdate.length !== 0) {\n            await this.updateNftMetadata({\n              nfts: nftsToUpdate,\n              userAddress: selectedAddress,\n            });\n          }\n        }\n      },\n    );\n\n    onNetworkStateChange(({ providerConfig }) => {\n      const { chainId } = providerConfig;\n      this.configure({ chainId });\n    });\n  }\n\n  private async validateWatchNft(\n    asset: NftAsset,\n    type: NFTStandardType,\n    userAddress: string,\n    { networkClientId }: { networkClientId?: NetworkClientId } = {},\n  ) {\n    const { address: contractAddress, tokenId } = asset;\n\n    // Validate parameters\n    if (!type) {\n      throw rpcErrors.invalidParams('Asset type is required');\n    }\n\n    if (type !== ERC721 && type !== ERC1155) {\n      throw rpcErrors.invalidParams(\n        `Non NFT asset type ${type} not supported by watchNft`,\n      );\n    }\n\n    if (!contractAddress || !tokenId) {\n      throw rpcErrors.invalidParams('Both address and tokenId are required');\n    }\n\n    if (!isAddress(contractAddress)) {\n      throw rpcErrors.invalidParams('Invalid address');\n    }\n\n    if (!/^\\d+$/u.test(tokenId)) {\n      throw rpcErrors.invalidParams('Invalid tokenId');\n    }\n\n    // Check if the user owns the suggested NFT\n    try {\n      const isOwner = await this.isNftOwner(\n        userAddress,\n        contractAddress,\n        tokenId,\n        { networkClientId },\n      );\n      if (!isOwner) {\n        throw rpcErrors.invalidInput(\n          'Suggested NFT is not owned by the selected account',\n        );\n      }\n    } catch (error) {\n      // error thrown here: \"Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.\"\n      if (error instanceof Error) {\n        throw rpcErrors.resourceUnavailable(error.message);\n      }\n      throw error;\n    }\n  }\n\n  // temporary method to get the correct chainId until we remove chainId from the config & the chainId arg from the detection logic\n  // Just a helper method to prefer the networkClient chainId first then the chainId argument and then finally the config chainId\n  private getCorrectChainId({\n    networkClientId,\n  }: {\n    networkClientId?: NetworkClientId;\n  }) {\n    if (networkClientId) {\n      return this.getNetworkClientById(networkClientId).configuration.chainId;\n    }\n    return this.config.chainId;\n  }\n\n  /**\n   * Adds a new suggestedAsset to state. Parameters will be validated according to\n   * asset type being watched. A `<suggestedNftMeta.id>:pending` hub event will be emitted once added.\n   *\n   * @param asset - The asset to be watched. For now ERC721 and ERC1155 tokens are accepted.\n   * @param asset.address - The address of the asset contract.\n   * @param asset.tokenId - The ID of the asset.\n   * @param type - The asset type.\n   * @param origin - Domain origin to register the asset from.\n   * @param options - Options bag.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being added.\n   * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.\n   */\n  async watchNft(\n    asset: NftAsset,\n    type: NFTStandardType,\n    origin: string,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: {\n      networkClientId?: NetworkClientId;\n      userAddress?: string;\n    } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    await this.validateWatchNft(asset, type, userAddress);\n\n    const nftMetadata = await this.getNftInformation(\n      asset.address,\n      asset.tokenId,\n      networkClientId,\n    );\n\n    if (nftMetadata.standard && nftMetadata.standard !== type) {\n      throw rpcErrors.invalidInput(\n        `Suggested NFT of type ${nftMetadata.standard} does not match received type ${type}`,\n      );\n    }\n\n    const suggestedNftMeta: SuggestedNftMeta = {\n      asset: { ...asset, ...nftMetadata },\n      type,\n      id: random(),\n      time: Date.now(),\n      interactingAddress: userAddress,\n      origin,\n    };\n    await this._requestApproval(suggestedNftMeta);\n    const { address, tokenId } = asset;\n    const { name, standard, description, image } = nftMetadata;\n\n    await this.addNft(address, tokenId, {\n      nftMetadata: {\n        name: name ?? null,\n        description: description ?? null,\n        image: image ?? null,\n        standard: standard ?? null,\n      },\n      userAddress,\n      source: Source.Dapp,\n      networkClientId,\n    });\n  }\n\n  /**\n   * Sets an OpenSea API key to retrieve NFT information.\n   *\n   * @param openSeaApiKey - OpenSea API key.\n   */\n  setApiKey(openSeaApiKey: string) {\n    this.openSeaApiKey = openSeaApiKey;\n  }\n\n  /**\n   * Checks the ownership of a ERC-721 or ERC-1155 NFT for a given address.\n   *\n   * @param ownerAddress - User public address.\n   * @param nftAddress - NFT contract address.\n   * @param tokenId - NFT token ID.\n   * @param options - Options bag.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving the NFT ownership.\n   */\n  async isNftOwner(\n    ownerAddress: string,\n    nftAddress: string,\n    tokenId: string,\n    {\n      networkClientId,\n    }: {\n      networkClientId?: NetworkClientId;\n    } = {},\n  ): Promise<boolean> {\n    // Checks the ownership for ERC-721.\n    try {\n      const owner = await this.getERC721OwnerOf(\n        nftAddress,\n        tokenId,\n        networkClientId,\n      );\n      return ownerAddress.toLowerCase() === owner.toLowerCase();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-721 contract error\n    }\n\n    // Checks the ownership for ERC-1155.\n    try {\n      const balance = await this.getERC1155BalanceOf(\n        ownerAddress,\n        nftAddress,\n        tokenId,\n        networkClientId,\n      );\n      return !balance.isZero();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-1155 contract error\n    }\n\n    throw new Error(\n      `Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.`,\n    );\n  }\n\n  /**\n   * Verifies currently selected address owns entered NFT address/tokenId combo and\n   * adds the NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param options - an object of arguments\n   * @param options.userAddress - The address of the current user.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   */\n  async addNftVerifyOwnership(\n    address: string,\n    tokenId: string,\n    {\n      userAddress = this.config.selectedAddress,\n      networkClientId,\n      source,\n    }: {\n      userAddress?: string;\n      networkClientId?: NetworkClientId;\n      source?: Source;\n    } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    if (\n      !(await this.isNftOwner(userAddress, address, tokenId, {\n        networkClientId,\n      }))\n    ) {\n      throw new Error('This NFT is not owned by the user');\n    }\n    await this.addNft(address, tokenId, {\n      networkClientId,\n      userAddress,\n      source,\n    });\n  }\n\n  /**\n   * Adds an NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param tokenAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param options - an object of arguments\n   * @param options.nftMetadata - NFT optional metadata.\n   * @param options.userAddress - The address of the current user.\n   * @param options.source - Whether the NFT was detected, added manually or suggested by a dapp.\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns Promise resolving to the current NFT list.\n   */\n  async addNft(\n    tokenAddress: string,\n    tokenId: string,\n    {\n      nftMetadata,\n      userAddress = this.config.selectedAddress,\n      source = Source.Custom,\n      networkClientId,\n    }: {\n      nftMetadata?: NftMetadata;\n      userAddress?: string;\n      source?: Source;\n      networkClientId?: NetworkClientId;\n    } = { userAddress: this.config.selectedAddress },\n  ) {\n    tokenAddress = toChecksumHexAddress(tokenAddress);\n\n    const chainId = this.getCorrectChainId({ networkClientId });\n\n    nftMetadata =\n      nftMetadata ||\n      (await this.getNftInformation(tokenAddress, tokenId, networkClientId));\n\n    const newNftContracts = await this.addNftContract({\n      tokenAddress,\n      userAddress,\n      networkClientId,\n      source,\n      nftMetadata,\n    });\n\n    // If NFT contract was not added, do not add individual NFT\n    const nftContract = newNftContracts.find(\n      (contract) =>\n        contract.address.toLowerCase() === tokenAddress.toLowerCase(),\n    );\n\n    // If NFT contract information, add individual NFT\n    if (nftContract) {\n      await this.addIndividualNft(\n        tokenAddress,\n        tokenId,\n        nftMetadata,\n        nftContract,\n        chainId,\n        userAddress,\n        source,\n      );\n    }\n  }\n\n  /**\n   * Refetches NFT metadata and updates the state\n   *\n   * @param options - Options for refetching NFT metadata\n   * @param options.nfts - nfts to update metadata for.\n   * @param options.userAddress - The current user address\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   */\n  async updateNftMetadata({\n    nfts,\n    userAddress = this.config.selectedAddress,\n    networkClientId,\n  }: {\n    nfts: Nft[];\n    userAddress?: string;\n    networkClientId?: NetworkClientId;\n  }) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n\n    const nftsWithChecksumAdr = nfts.map((nft) => {\n      return {\n        ...nft,\n        address: toChecksumHexAddress(nft.address),\n      };\n    });\n    const nftMetadataResults = await Promise.allSettled(\n      nftsWithChecksumAdr.map(async (nft) => {\n        const resMetadata = await this.getNftInformation(\n          nft.address,\n          nft.tokenId,\n          networkClientId,\n        );\n        return {\n          nft,\n          newMetadata: resMetadata,\n        };\n      }),\n    );\n\n    nftMetadataResults\n      .filter(\n        (result): result is PromiseFulfilledResult<NftUpdate> =>\n          result.status === 'fulfilled',\n      )\n      .forEach((elm) =>\n        this.updateNft(\n          elm.value.nft,\n          elm.value.newMetadata,\n          userAddress,\n          chainId,\n        ),\n      );\n  }\n\n  /**\n   * Removes an NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  removeNft(\n    address: string,\n    tokenId: string,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    address = toChecksumHexAddress(address);\n    this.removeIndividualNft(address, tokenId, { chainId, userAddress });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n\n    if (!remainingNft) {\n      this.removeNftContract(address, { chainId, userAddress });\n    }\n  }\n\n  /**\n   * Removes an NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  removeAndIgnoreNft(\n    address: string,\n    tokenId: string,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    address = toChecksumHexAddress(address);\n    this.removeAndIgnoreIndividualNft(address, tokenId, {\n      chainId,\n      userAddress,\n    });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (!remainingNft) {\n      this.removeNftContract(address, { chainId, userAddress });\n    }\n  }\n\n  /**\n   * Removes all NFTs from the ignored list.\n   */\n  clearIgnoredNfts() {\n    this.update({ ignoredNfts: [] });\n  }\n\n  /**\n   * Checks whether input NFT is still owned by the user\n   * And updates the isCurrentlyOwned value on the NFT object accordingly.\n   *\n   * @param nft - The NFT object to check and update.\n   * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.\n   * @param accountParams - The userAddress and chainId to check ownership against\n   * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure assets are stored to the correct account\n   * @param accountParams.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @returns the NFT with the updated isCurrentlyOwned value\n   */\n  async checkAndUpdateSingleNftOwnershipStatus(\n    nft: Nft,\n    batch: boolean,\n    {\n      userAddress = this.config.selectedAddress,\n      networkClientId,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const { address, tokenId } = nft;\n    let isOwned = nft.isCurrentlyOwned;\n    try {\n      isOwned = await this.isNftOwner(userAddress, address, tokenId, {\n        networkClientId,\n      });\n    } catch {\n      // ignore error\n      // this will only throw an error 'Unable to verify ownership' in which case\n      // we want to keep the current value of isCurrentlyOwned for this flow.\n    }\n\n    nft.isCurrentlyOwned = isOwned;\n\n    if (batch) {\n      return nft;\n    }\n\n    // if this is not part of a batched update we update this one NFT in state\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const nftToUpdate = nfts.find(\n      (item) =>\n        item.tokenId === tokenId &&\n        item.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (nftToUpdate) {\n      nftToUpdate.isCurrentlyOwned = isOwned;\n      this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {\n        userAddress,\n        chainId,\n      });\n    }\n    return nft;\n  }\n\n  /**\n   * Checks whether NFTs associated with current selectedAddress/chainId combination are still owned by the user\n   * And updates the isCurrentlyOwned value on each accordingly.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT ownership status is checked/updated.\n   */\n  async checkAndUpdateAllNftsOwnershipStatus(\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: { networkClientId?: NetworkClientId; userAddress?: string } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const updatedNfts = await Promise.all(\n      nfts.map(async (nft) => {\n        return (\n          (await this.checkAndUpdateSingleNftOwnershipStatus(nft, true, {\n            networkClientId,\n            userAddress,\n          })) ?? nft\n        );\n      }),\n    );\n\n    this.updateNestedNftState(updatedNfts, ALL_NFTS_STATE_KEY, {\n      userAddress,\n      chainId,\n    });\n  }\n\n  /**\n   * Update NFT favorite status.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Hex address of the NFT contract.\n   * @param favorite - NFT new favorite status.\n   * @param options - an object of arguments\n   * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.\n   * @param options.userAddress - The address of the account where the NFT is being removed.\n   */\n  updateNftFavoriteStatus(\n    address: string,\n    tokenId: string,\n    favorite: boolean,\n    {\n      networkClientId,\n      userAddress = this.config.selectedAddress,\n    }: {\n      networkClientId?: NetworkClientId;\n      userAddress?: string;\n    } = {\n      userAddress: this.config.selectedAddress,\n    },\n  ) {\n    const chainId = this.getCorrectChainId({ networkClientId });\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.address === address && nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nfts[index],\n      favorite,\n    };\n\n    // Update Nfts array\n    nfts[index] = updatedNft;\n\n    this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {\n      chainId,\n      userAddress,\n    });\n  }\n\n  /**\n   * Returns an NFT by the address and token id.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Number that represents the id of the token.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns Object containing the NFT and its position in the array\n   */\n  findNftByAddressAndTokenId(\n    address: string,\n    tokenId: string,\n    selectedAddress: string,\n    chainId: Hex,\n  ): { nft: Nft; index: number } | null {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) =>\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return null;\n    }\n\n    return { nft: nfts[index], index };\n  }\n\n  /**\n   * Update NFT data.\n   *\n   * @param nft - NFT object to find the right NFT to updates.\n   * @param updates - NFT partial object to update properties of the NFT.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   */\n  updateNft(\n    nft: Nft,\n    updates: Partial<Nft>,\n    selectedAddress: string,\n    chainId: Hex,\n  ) {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const nftInfo = this.findNftByAddressAndTokenId(\n      nft.address,\n      nft.tokenId,\n      selectedAddress,\n      chainId,\n    );\n\n    if (!nftInfo) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nft,\n      ...updates,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, nftInfo.index),\n      updatedNft,\n      ...nfts.slice(nftInfo.index + 1),\n    ];\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      chainId,\n      userAddress: selectedAddress,\n    });\n  }\n\n  /**\n   * Resets the transaction status of an NFT.\n   *\n   * @param transactionId - NFT transaction id.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns a boolean indicating if the reset was well succeeded or not\n   */\n  resetNftTransactionStatusByTransactionId(\n    transactionId: string,\n    selectedAddress: string,\n    chainId: Hex,\n  ): boolean {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.transactionId === transactionId,\n    );\n\n    if (index === -1) {\n      return false;\n    }\n    const updatedNft: Nft = {\n      ...nfts[index],\n      transactionId: undefined,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, index),\n      updatedNft,\n      ...nfts.slice(index + 1),\n    ];\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n      chainId,\n      userAddress: selectedAddress,\n    });\n\n    return true;\n  }\n\n  async _requestApproval(suggestedNftMeta: SuggestedNftMeta) {\n    return this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        id: suggestedNftMeta.id,\n        origin: suggestedNftMeta.origin,\n        type: ApprovalType.WatchAsset,\n        requestData: {\n          id: suggestedNftMeta.id,\n          interactingAddress: suggestedNftMeta.interactingAddress,\n          asset: {\n            address: suggestedNftMeta.asset.address,\n            tokenId: suggestedNftMeta.asset.tokenId,\n            name: suggestedNftMeta.asset.name,\n            description: suggestedNftMeta.asset.description,\n            image: suggestedNftMeta.asset.image,\n            standard: suggestedNftMeta.asset.standard,\n          },\n        },\n      },\n      true,\n    );\n  }\n}\n\nexport default NftController;\n"],"mappings":"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","names":[]}
\ No newline at end of file
diff --git a/dist/chunk-S6KASB6I.mjs b/dist/chunk-S6KASB6I.mjs
new file mode 100644
index 0000000000000000000000000000000000000000..558f2aa42bbab89bee4075bb4ce3f67d8b6af1ac
--- /dev/null
+++ b/dist/chunk-S6KASB6I.mjs
@@ -0,0 +1,85 @@
+import {
+  isTokenListSupportedForNetwork
+} from "./chunk-X5PLVMOQ.mjs";
+
+// src/token-service.ts
+import {
+  ChainId,
+  convertHexToDecimal,
+  timeoutFetch
+} from "@metamask/controller-utils";
+var TOKEN_END_POINT_API = "https://token-api.metaswap.codefi.network";
+var TOKEN_METADATA_NO_SUPPORT_ERROR = "TokenService Error: Network does not support fetchTokenMetadata";
+function getTokensURL(chainId) {
+  const occurrenceFloor = chainId === ChainId["linea-mainnet"] ? 1 : 3;
+  return `${TOKEN_END_POINT_API}/tokens/${convertHexToDecimal(
+    chainId
+  )}?occurrenceFloor=${occurrenceFloor}&includeNativeAssets=false&includeDuplicateSymbolAssets=false&includeTokenFees=false&includeAssetType=false`;
+}
+function getTokenMetadataURL(chainId, tokenAddress) {
+  return `${TOKEN_END_POINT_API}/token/${convertHexToDecimal(
+    chainId
+  )}?address=${tokenAddress}`;
+}
+var tenSecondsInMilliseconds = 1e4;
+var defaultTimeout = tenSecondsInMilliseconds;
+async function fetchTokenListByChainId(chainId, abortSignal, { timeout = defaultTimeout } = {}) {
+  const tokenURL = getTokensURL(chainId);
+  const response = await queryApi(tokenURL, abortSignal, timeout);
+  if (response) {
+    const result = await parseJsonResponse(response);
+    if (Array.isArray(result) && chainId === ChainId["linea-mainnet"]) {
+      return result.filter(
+        (elm) => elm.aggregators.includes("lineaTeam") || elm.aggregators.length >= 3
+      );
+    }
+    return result;
+  }
+  return void 0;
+}
+async function fetchTokenMetadata(chainId, tokenAddress, abortSignal, { timeout = defaultTimeout } = {}) {
+  if (!isTokenListSupportedForNetwork(chainId)) {
+    throw new Error(TOKEN_METADATA_NO_SUPPORT_ERROR);
+  }
+  const tokenMetadataURL = getTokenMetadataURL(chainId, tokenAddress);
+  const response = await queryApi(tokenMetadataURL, abortSignal, timeout);
+  if (response) {
+    return parseJsonResponse(response);
+  }
+  return void 0;
+}
+async function queryApi(apiURL, abortSignal, timeout) {
+  const fetchOptions = {
+    referrer: apiURL,
+    referrerPolicy: "no-referrer-when-downgrade",
+    method: "GET",
+    mode: "cors",
+    signal: abortSignal,
+    cache: "default"
+  };
+  fetchOptions.headers = new window.Headers();
+  fetchOptions.headers.set("Content-Type", "application/json");
+  try {
+    return await timeoutFetch(apiURL, fetchOptions, timeout);
+  } catch (error) {
+    if (error instanceof Error && error.name === "AbortError") {
+      console.log("Request is aborted");
+    }
+  }
+  return void 0;
+}
+async function parseJsonResponse(apiResponse) {
+  const responseObj = await apiResponse.json();
+  if (responseObj?.error) {
+    throw new Error(`TokenService Error: ${responseObj.error}`);
+  }
+  return responseObj;
+}
+
+export {
+  TOKEN_END_POINT_API,
+  TOKEN_METADATA_NO_SUPPORT_ERROR,
+  fetchTokenListByChainId,
+  fetchTokenMetadata
+};
+//# sourceMappingURL=chunk-S6KASB6I.mjs.map
\ No newline at end of file
diff --git a/dist/chunk-S6KASB6I.mjs.map b/dist/chunk-S6KASB6I.mjs.map
new file mode 100644
index 0000000000000000000000000000000000000000..6e5e45c68442110ff70919dcf40111a7e7592e73
--- /dev/null
+++ b/dist/chunk-S6KASB6I.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/token-service.ts"],"sourcesContent":["import {\n  ChainId,\n  convertHexToDecimal,\n  timeoutFetch,\n} from '@metamask/controller-utils';\nimport type { Hex } from '@metamask/utils';\n\nimport { isTokenListSupportedForNetwork } from './assetsUtil';\n\nexport const TOKEN_END_POINT_API = 'https://token-api.metaswap.codefi.network';\nexport const TOKEN_METADATA_NO_SUPPORT_ERROR =\n  'TokenService Error: Network does not support fetchTokenMetadata';\n\n/**\n * Get the tokens URL for a specific network.\n *\n * @param chainId - The chain ID of the network the tokens requested are on.\n * @returns The tokens URL.\n */\nfunction getTokensURL(chainId: Hex) {\n  const occurrenceFloor = chainId === ChainId['linea-mainnet'] ? 1 : 3;\n  return `${TOKEN_END_POINT_API}/tokens/${convertHexToDecimal(\n    chainId,\n  )}?occurrenceFloor=${occurrenceFloor}&includeNativeAssets=false&includeDuplicateSymbolAssets=false&includeTokenFees=false&includeAssetType=false`;\n}\n\n/**\n * Get the token metadata URL for the given network and token.\n *\n * @param chainId - The chain ID of the network the token is on.\n * @param tokenAddress - The token address.\n * @returns The token metadata URL.\n */\nfunction getTokenMetadataURL(chainId: Hex, tokenAddress: string) {\n  return `${TOKEN_END_POINT_API}/token/${convertHexToDecimal(\n    chainId,\n  )}?address=${tokenAddress}`;\n}\n\nconst tenSecondsInMilliseconds = 10_000;\n\n// Token list averages 1.6 MB in size\n// timeoutFetch by default has a 500ms timeout, which will almost always timeout given the response size.\nconst defaultTimeout = tenSecondsInMilliseconds;\n\n/**\n * Fetch the list of token metadata for a given network. This request is cancellable using the\n * abort signal passed in.\n *\n * @param chainId - The chain ID of the network the requested tokens are on.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param options - Additional fetch options.\n * @param options.timeout - The fetch timeout.\n * @returns The token list, or `undefined` if the request was cancelled.\n */\nexport async function fetchTokenListByChainId(\n  chainId: Hex,\n  abortSignal: AbortSignal,\n  { timeout = defaultTimeout } = {},\n): Promise<unknown> {\n  const tokenURL = getTokensURL(chainId);\n  const response = await queryApi(tokenURL, abortSignal, timeout);\n  if (response) {\n    const result = await parseJsonResponse(response);\n    if (Array.isArray(result) && chainId === ChainId['linea-mainnet']) {\n      return result.filter(\n        (elm) =>\n          elm.aggregators.includes('lineaTeam') || elm.aggregators.length >= 3,\n      );\n    }\n    return result;\n  }\n  return undefined;\n}\n\n/**\n * Fetch metadata for the token address provided for a given network. This request is cancellable\n * using the abort signal passed in.\n *\n * @param chainId - The chain ID of the network the token is on.\n * @param tokenAddress - The address of the token to fetch metadata for.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param options - Additional fetch options.\n * @param options.timeout - The fetch timeout.\n * @returns The token metadata, or `undefined` if the request was either aborted or failed.\n */\nexport async function fetchTokenMetadata<T>(\n  chainId: Hex,\n  tokenAddress: string,\n  abortSignal: AbortSignal,\n  { timeout = defaultTimeout } = {},\n): Promise<T | undefined> {\n  if (!isTokenListSupportedForNetwork(chainId)) {\n    throw new Error(TOKEN_METADATA_NO_SUPPORT_ERROR);\n  }\n  const tokenMetadataURL = getTokenMetadataURL(chainId, tokenAddress);\n  const response = await queryApi(tokenMetadataURL, abortSignal, timeout);\n  if (response) {\n    return parseJsonResponse(response) as Promise<T>;\n  }\n  return undefined;\n}\n\n/**\n * Perform fetch request against the api.\n *\n * @param apiURL - The URL of the API to fetch.\n * @param abortSignal - The abort signal used to cancel the request if necessary.\n * @param timeout - The fetch timeout.\n * @returns Promise resolving request response.\n */\nasync function queryApi(\n  apiURL: string,\n  abortSignal: AbortSignal,\n  timeout: number,\n): Promise<Response | undefined> {\n  const fetchOptions: RequestInit = {\n    referrer: apiURL,\n    referrerPolicy: 'no-referrer-when-downgrade',\n    method: 'GET',\n    mode: 'cors',\n    signal: abortSignal,\n    cache: 'default',\n  };\n  fetchOptions.headers = new window.Headers();\n  fetchOptions.headers.set('Content-Type', 'application/json');\n  try {\n    return await timeoutFetch(apiURL, fetchOptions, timeout);\n  } catch (error) {\n    if (error instanceof Error && error.name === 'AbortError') {\n      console.log('Request is aborted');\n    }\n  }\n  return undefined;\n}\n\n/**\n * Parse an API response and return the response JSON data.\n *\n * @param apiResponse - The API response to parse.\n * @returns The response JSON data.\n * @throws Will throw if the response includes an error.\n */\nasync function parseJsonResponse(apiResponse: Response): Promise<unknown> {\n  const responseObj = await apiResponse.json();\n  // api may return errors as json without setting an error http status code\n  if (responseObj?.error) {\n    throw new Error(`TokenService Error: ${responseObj.error}`);\n  }\n  return responseObj;\n}\n"],"mappings":";;;;;AAAA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAKA,IAAM,sBAAsB;AAC5B,IAAM,kCACX;AAQF,SAAS,aAAa,SAAc;AAClC,QAAM,kBAAkB,YAAY,QAAQ,eAAe,IAAI,IAAI;AACnE,SAAO,GAAG,mBAAmB,WAAW;AAAA,IACtC;AAAA,EACF,CAAC,oBAAoB,eAAe;AACtC;AASA,SAAS,oBAAoB,SAAc,cAAsB;AAC/D,SAAO,GAAG,mBAAmB,UAAU;AAAA,IACrC;AAAA,EACF,CAAC,YAAY,YAAY;AAC3B;AAEA,IAAM,2BAA2B;AAIjC,IAAM,iBAAiB;AAYvB,eAAsB,wBACpB,SACA,aACA,EAAE,UAAU,eAAe,IAAI,CAAC,GACd;AAClB,QAAM,WAAW,aAAa,OAAO;AACrC,QAAM,WAAW,MAAM,SAAS,UAAU,aAAa,OAAO;AAC9D,MAAI,UAAU;AACZ,UAAM,SAAS,MAAM,kBAAkB,QAAQ;AAC/C,QAAI,MAAM,QAAQ,MAAM,KAAK,YAAY,QAAQ,eAAe,GAAG;AACjE,aAAO,OAAO;AAAA,QACZ,CAAC,QACC,IAAI,YAAY,SAAS,WAAW,KAAK,IAAI,YAAY,UAAU;AAAA,MACvE;AAAA,IACF;AACA,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAaA,eAAsB,mBACpB,SACA,cACA,aACA,EAAE,UAAU,eAAe,IAAI,CAAC,GACR;AACxB,MAAI,CAAC,+BAA+B,OAAO,GAAG;AAC5C,UAAM,IAAI,MAAM,+BAA+B;AAAA,EACjD;AACA,QAAM,mBAAmB,oBAAoB,SAAS,YAAY;AAClE,QAAM,WAAW,MAAM,SAAS,kBAAkB,aAAa,OAAO;AACtE,MAAI,UAAU;AACZ,WAAO,kBAAkB,QAAQ;AAAA,EACnC;AACA,SAAO;AACT;AAUA,eAAe,SACb,QACA,aACA,SAC+B;AAC/B,QAAM,eAA4B;AAAA,IAChC,UAAU;AAAA,IACV,gBAAgB;AAAA,IAChB,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,OAAO;AAAA,EACT;AACA,eAAa,UAAU,IAAI,OAAO,QAAQ;AAC1C,eAAa,QAAQ,IAAI,gBAAgB,kBAAkB;AAC3D,MAAI;AACF,WAAO,MAAM,aAAa,QAAQ,cAAc,OAAO;AAAA,EACzD,SAAS,OAAO;AACd,QAAI,iBAAiB,SAAS,MAAM,SAAS,cAAc;AACzD,cAAQ,IAAI,oBAAoB;AAAA,IAClC;AAAA,EACF;AACA,SAAO;AACT;AASA,eAAe,kBAAkB,aAAyC;AACxE,QAAM,cAAc,MAAM,YAAY,KAAK;AAE3C,MAAI,aAAa,OAAO;AACtB,UAAM,IAAI,MAAM,uBAAuB,YAAY,KAAK,EAAE;AAAA,EAC5D;AACA,SAAO;AACT;","names":[]}
\ No newline at end of file
diff --git a/dist/chunk-SOK5YX7I.js b/dist/chunk-SOK5YX7I.js
deleted file mode 100644
index 53b4550603fe954306a187cf08a9cb67a00a6970..0000000000000000000000000000000000000000
--- a/dist/chunk-SOK5YX7I.js
+++ /dev/null
@@ -1,704 +0,0 @@
-"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
-
-var _chunk3ZHN4GFTjs = require('./chunk-3ZHN4GFT.js');
-
-
-var _chunkBO2WZDUMjs = require('./chunk-BO2WZDUM.js');
-
-
-
-var _chunkOHSQRYVLjs = require('./chunk-OHSQRYVL.js');
-
-
-
-var _chunkLS6R3HQLjs = require('./chunk-LS6R3HQL.js');
-
-// src/TokensController.ts
-var _contracts = require('@ethersproject/contracts');
-var _providers = require('@ethersproject/providers');
-var _basecontroller = require('@metamask/base-controller');
-var _contractmetadata = require('@metamask/contract-metadata'); var _contractmetadata2 = _interopRequireDefault(_contractmetadata);
-
-
-
-
-
-
-
-
-
-
-var _controllerutils = require('@metamask/controller-utils');
-var _metamaskethabis = require('@metamask/metamask-eth-abis');
-var _rpcerrors = require('@metamask/rpc-errors');
-var _asyncmutex = require('async-mutex');
-var _events = require('events');
-var _uuid = require('uuid');
-var controllerName = "TokensController";
-var getDefaultTokensState = () => {
-  return {
-    tokens: [],
-    ignoredTokens: [],
-    detectedTokens: [],
-    allTokens: {},
-    allIgnoredTokens: {},
-    allDetectedTokens: {}
-  };
-};
-var TokensController = class extends _basecontroller.BaseControllerV1 {
-  /**
-   * Creates a TokensController instance.
-   *
-   * @param options - The controller options.
-   * @param options.chainId - The chain ID of the current network.
-   * @param options.config - Initial options used to configure this controller.
-   * @param options.state - Initial state to set on this controller.
-   * @param options.messenger - The controller messenger.
-   */
-  constructor({
-    chainId: initialChainId,
-    config,
-    state,
-    messenger
-  }) {
-    super(config, state);
-    this.mutex = new (0, _asyncmutex.Mutex)();
-    /**
-     * EventEmitter instance used to listen to specific EIP747 events
-     */
-    this.hub = new (0, _events.EventEmitter)();
-    /**
-     * Name of this controller used during composition
-     */
-    this.name = "TokensController";
-    this.defaultConfig = {
-      selectedAddress: "",
-      chainId: initialChainId,
-      provider: void 0,
-      ...config
-    };
-    this.defaultState = {
-      ...getDefaultTokensState(),
-      ...state
-    };
-    this.initialize();
-    this.abortController = new AbortController();
-    this.messagingSystem = messenger;
-    this.messagingSystem.registerActionHandler(
-      `${controllerName}:addDetectedTokens`,
-      this.addDetectedTokens.bind(this)
-    );
-    this.messagingSystem.subscribe(
-      "PreferencesController:stateChange",
-      ({ selectedAddress }) => {
-        const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
-        const { chainId } = this.config;
-        this.configure({ selectedAddress });
-        this.update({
-          tokens: allTokens[chainId]?.[selectedAddress] ?? [],
-          ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] ?? [],
-          detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] ?? []
-        });
-      }
-    );
-    this.messagingSystem.subscribe(
-      "NetworkController:networkDidChange",
-      ({ providerConfig }) => {
-        const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
-        const { selectedAddress } = this.config;
-        const { chainId } = providerConfig;
-        this.abortController.abort();
-        this.abortController = new AbortController();
-        this.configure({ chainId });
-        this.update({
-          tokens: allTokens[chainId]?.[selectedAddress] || [],
-          ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] || [],
-          detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] || []
-        });
-      }
-    );
-    this.messagingSystem.subscribe(
-      "TokenListController:stateChange",
-      ({ tokenList }) => {
-        const { tokens } = this.state;
-        if (tokens.length && !tokens[0].name) {
-          this.updateTokensAttribute(tokenList, "name");
-        }
-      }
-    );
-  }
-  /**
-   * Fetch metadata for a token.
-   *
-   * @param tokenAddress - The address of the token.
-   * @returns The token metadata.
-   */
-  async fetchTokenMetadata(tokenAddress) {
-    try {
-      const token = await _chunkOHSQRYVLjs.fetchTokenMetadata.call(void 0, 
-        this.config.chainId,
-        tokenAddress,
-        this.abortController.signal
-      );
-      return token;
-    } catch (error) {
-      if (error instanceof Error && error.message.includes(_chunkOHSQRYVLjs.TOKEN_METADATA_NO_SUPPORT_ERROR)) {
-        return void 0;
-      }
-      throw error;
-    }
-  }
-  /**
-   * Adds a token to the stored token list.
-   *
-   * @param options - The method argument object.
-   * @param options.address - Hex address of the token contract.
-   * @param options.symbol - Symbol of the token.
-   * @param options.decimals - Number of decimals the token uses.
-   * @param options.name - Name of the token.
-   * @param options.image - Image of the token.
-   * @param options.interactingAddress - The address of the account to add a token to.
-   * @param options.networkClientId - Network Client ID.
-   * @returns Current token list.
-   */
-  async addToken({
-    address,
-    symbol,
-    decimals,
-    name,
-    image,
-    interactingAddress,
-    networkClientId
-  }) {
-    const { chainId, selectedAddress } = this.config;
-    const releaseLock = await this.mutex.acquire();
-    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
-    let currentChainId = chainId;
-    if (networkClientId) {
-      currentChainId = this.messagingSystem.call(
-        "NetworkController:getNetworkClientById",
-        networkClientId
-      ).configuration.chainId;
-    }
-    const accountAddress = interactingAddress || selectedAddress;
-    const isInteractingWithWalletAccount = accountAddress === selectedAddress;
-    try {
-      address = _controllerutils.toChecksumHexAddress.call(void 0, address);
-      const tokens = allTokens[currentChainId]?.[accountAddress] || [];
-      const ignoredTokens = allIgnoredTokens[currentChainId]?.[accountAddress] || [];
-      const detectedTokens = allDetectedTokens[currentChainId]?.[accountAddress] || [];
-      const newTokens = [...tokens];
-      const [isERC721, tokenMetadata] = await Promise.all([
-        this._detectIsERC721(address, networkClientId),
-        // TODO parameterize the token metadata fetch by networkClientId
-        this.fetchTokenMetadata(address)
-      ]);
-      if (!networkClientId && currentChainId !== this.config.chainId) {
-        throw new Error(
-          "TokensController Error: Switched networks while adding token"
-        );
-      }
-      const newEntry = {
-        address,
-        symbol,
-        decimals,
-        image: image || _chunkLS6R3HQLjs.formatIconUrlWithProxy.call(void 0, {
-          chainId: currentChainId,
-          tokenAddress: address
-        }),
-        isERC721,
-        aggregators: _chunkLS6R3HQLjs.formatAggregatorNames.call(void 0, tokenMetadata?.aggregators || []),
-        name
-      };
-      const previousIndex = newTokens.findIndex(
-        (token) => token.address.toLowerCase() === address.toLowerCase()
-      );
-      if (previousIndex !== -1) {
-        newTokens[previousIndex] = newEntry;
-      } else {
-        newTokens.push(newEntry);
-      }
-      const newIgnoredTokens = ignoredTokens.filter(
-        (tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase()
-      );
-      const newDetectedTokens = detectedTokens.filter(
-        (token) => token.address.toLowerCase() !== address.toLowerCase()
-      );
-      const { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens } = this._getNewAllTokensState({
-        newTokens,
-        newIgnoredTokens,
-        newDetectedTokens,
-        interactingAddress: accountAddress,
-        interactingChainId: currentChainId
-      });
-      let newState = {
-        allTokens: newAllTokens,
-        allIgnoredTokens: newAllIgnoredTokens,
-        allDetectedTokens: newAllDetectedTokens
-      };
-      if (isInteractingWithWalletAccount) {
-        newState = {
-          ...newState,
-          tokens: newTokens,
-          ignoredTokens: newIgnoredTokens,
-          detectedTokens: newDetectedTokens
-        };
-      }
-      this.update(newState);
-      return newTokens;
-    } finally {
-      releaseLock();
-    }
-  }
-  /**
-   * Add a batch of tokens.
-   *
-   * @param tokensToImport - Array of tokens to import.
-   * @param networkClientId - Optional network client ID used to determine interacting chain ID.
-   */
-  async addTokens(tokensToImport, networkClientId) {
-    const releaseLock = await this.mutex.acquire();
-    const { tokens, detectedTokens, ignoredTokens } = this.state;
-    const importedTokensMap = {};
-    const newTokensMap = tokens.reduce((output, current) => {
-      output[current.address] = current;
-      return output;
-    }, {});
-    try {
-      tokensToImport.forEach((tokenToAdd) => {
-        const { address, symbol, decimals, image, aggregators, name } = tokenToAdd;
-        const checksumAddress = _controllerutils.toChecksumHexAddress.call(void 0, address);
-        const formattedToken = {
-          address: checksumAddress,
-          symbol,
-          decimals,
-          image,
-          aggregators,
-          name
-        };
-        newTokensMap[address] = formattedToken;
-        importedTokensMap[address.toLowerCase()] = true;
-        return formattedToken;
-      });
-      const newTokens = Object.values(newTokensMap);
-      const newDetectedTokens = detectedTokens.filter(
-        (token) => !importedTokensMap[token.address.toLowerCase()]
-      );
-      const newIgnoredTokens = ignoredTokens.filter(
-        (tokenAddress) => !newTokensMap[tokenAddress.toLowerCase()]
-      );
-      let interactingChainId;
-      if (networkClientId) {
-        interactingChainId = this.messagingSystem.call(
-          "NetworkController:getNetworkClientById",
-          networkClientId
-        ).configuration.chainId;
-      }
-      const { newAllTokens, newAllDetectedTokens, newAllIgnoredTokens } = this._getNewAllTokensState({
-        newTokens,
-        newDetectedTokens,
-        newIgnoredTokens,
-        interactingChainId
-      });
-      this.update({
-        tokens: newTokens,
-        allTokens: newAllTokens,
-        detectedTokens: newDetectedTokens,
-        allDetectedTokens: newAllDetectedTokens,
-        ignoredTokens: newIgnoredTokens,
-        allIgnoredTokens: newAllIgnoredTokens
-      });
-    } finally {
-      releaseLock();
-    }
-  }
-  /**
-   * Ignore a batch of tokens.
-   *
-   * @param tokenAddressesToIgnore - Array of token addresses to ignore.
-   */
-  ignoreTokens(tokenAddressesToIgnore) {
-    const { ignoredTokens, detectedTokens, tokens } = this.state;
-    const ignoredTokensMap = {};
-    let newIgnoredTokens = [...ignoredTokens];
-    const checksummedTokenAddresses = tokenAddressesToIgnore.map((address) => {
-      const checksumAddress = _controllerutils.toChecksumHexAddress.call(void 0, address);
-      ignoredTokensMap[address.toLowerCase()] = true;
-      return checksumAddress;
-    });
-    newIgnoredTokens = [...ignoredTokens, ...checksummedTokenAddresses];
-    const newDetectedTokens = detectedTokens.filter(
-      (token) => !ignoredTokensMap[token.address.toLowerCase()]
-    );
-    const newTokens = tokens.filter(
-      (token) => !ignoredTokensMap[token.address.toLowerCase()]
-    );
-    const { newAllIgnoredTokens, newAllDetectedTokens, newAllTokens } = this._getNewAllTokensState({
-      newIgnoredTokens,
-      newDetectedTokens,
-      newTokens
-    });
-    this.update({
-      ignoredTokens: newIgnoredTokens,
-      tokens: newTokens,
-      detectedTokens: newDetectedTokens,
-      allIgnoredTokens: newAllIgnoredTokens,
-      allDetectedTokens: newAllDetectedTokens,
-      allTokens: newAllTokens
-    });
-  }
-  /**
-   * Adds a batch of detected tokens to the stored token list.
-   *
-   * @param incomingDetectedTokens - Array of detected tokens to be added or updated.
-   * @param detectionDetails - An object containing the chain ID and address of the currently selected network on which the incomingDetectedTokens were detected.
-   * @param detectionDetails.selectedAddress - the account address on which the incomingDetectedTokens were detected.
-   * @param detectionDetails.chainId - the chainId on which the incomingDetectedTokens were detected.
-   */
-  async addDetectedTokens(incomingDetectedTokens, detectionDetails) {
-    const releaseLock = await this.mutex.acquire();
-    const chainId = detectionDetails?.chainId ?? this.config.chainId;
-    const accountAddress = detectionDetails?.selectedAddress ?? this.config.selectedAddress;
-    const { allTokens, allDetectedTokens, allIgnoredTokens } = this.state;
-    let newTokens = [...allTokens?.[chainId]?.[accountAddress] ?? []];
-    let newDetectedTokens = [
-      ...allDetectedTokens?.[chainId]?.[accountAddress] ?? []
-    ];
-    try {
-      incomingDetectedTokens.forEach((tokenToAdd) => {
-        const {
-          address,
-          symbol,
-          decimals,
-          image,
-          aggregators,
-          isERC721,
-          name
-        } = tokenToAdd;
-        const checksumAddress = _controllerutils.toChecksumHexAddress.call(void 0, address);
-        const newEntry = {
-          address: checksumAddress,
-          symbol,
-          decimals,
-          image,
-          isERC721,
-          aggregators,
-          name
-        };
-        const previousImportedIndex = newTokens.findIndex(
-          (token) => token.address.toLowerCase() === checksumAddress.toLowerCase()
-        );
-        if (previousImportedIndex !== -1) {
-          newTokens[previousImportedIndex] = newEntry;
-        } else {
-          const ignoredTokenIndex = allIgnoredTokens?.[chainId]?.[accountAddress]?.indexOf(address) ?? -1;
-          if (ignoredTokenIndex === -1) {
-            const previousDetectedIndex = newDetectedTokens.findIndex(
-              (token) => token.address.toLowerCase() === checksumAddress.toLowerCase()
-            );
-            if (previousDetectedIndex !== -1) {
-              newDetectedTokens[previousDetectedIndex] = newEntry;
-            } else {
-              newDetectedTokens.push(newEntry);
-            }
-          }
-        }
-      });
-      const { newAllTokens, newAllDetectedTokens } = this._getNewAllTokensState(
-        {
-          newTokens,
-          newDetectedTokens,
-          interactingAddress: accountAddress,
-          interactingChainId: chainId
-        }
-      );
-      const { chainId: currentChain, selectedAddress: currentAddress } = this.config;
-      newTokens = newAllTokens?.[currentChain]?.[currentAddress] || [];
-      newDetectedTokens = newAllDetectedTokens?.[currentChain]?.[currentAddress] || [];
-      this.update({
-        tokens: newTokens,
-        allTokens: newAllTokens,
-        detectedTokens: newDetectedTokens,
-        allDetectedTokens: newAllDetectedTokens
-      });
-    } finally {
-      releaseLock();
-    }
-  }
-  /**
-   * Adds isERC721 field to token object. This is called when a user attempts to add tokens that
-   * were previously added which do not yet had isERC721 field.
-   *
-   * @param tokenAddress - The contract address of the token requiring the isERC721 field added.
-   * @returns The new token object with the added isERC721 field.
-   */
-  async updateTokenType(tokenAddress) {
-    const isERC721 = await this._detectIsERC721(tokenAddress);
-    const { tokens } = this.state;
-    const tokenIndex = tokens.findIndex((token) => {
-      return token.address.toLowerCase() === tokenAddress.toLowerCase();
-    });
-    tokens[tokenIndex].isERC721 = isERC721;
-    this.update({ tokens });
-    return tokens[tokenIndex];
-  }
-  /**
-   * This is a function that updates the tokens name for the tokens name if it is not defined.
-   *
-   * @param tokenList - Represents the fetched token list from service API
-   * @param tokenAttribute - Represents the token attribute that we want to update on the token list
-   */
-  updateTokensAttribute(tokenList, tokenAttribute) {
-    const { tokens } = this.state;
-    const newTokens = tokens.map((token) => {
-      const newToken = tokenList[token.address.toLowerCase()];
-      return !token[tokenAttribute] && newToken?.[tokenAttribute] ? { ...token, [tokenAttribute]: newToken[tokenAttribute] } : { ...token };
-    });
-    this.update({ tokens: newTokens });
-  }
-  /**
-   * Detects whether or not a token is ERC-721 compatible.
-   *
-   * @param tokenAddress - The token contract address.
-   * @param networkClientId - Optional network client ID to fetch contract info with.
-   * @returns A boolean indicating whether the token address passed in supports the EIP-721
-   * interface.
-   */
-  async _detectIsERC721(tokenAddress, networkClientId) {
-    const checksumAddress = _controllerutils.toChecksumHexAddress.call(void 0, tokenAddress);
-    if (_contractmetadata2.default[checksumAddress]?.erc721 === true) {
-      return Promise.resolve(true);
-    } else if (_contractmetadata2.default[checksumAddress]?.erc20 === true) {
-      return Promise.resolve(false);
-    }
-    const tokenContract = this._createEthersContract(
-      tokenAddress,
-      _metamaskethabis.abiERC721,
-      networkClientId
-    );
-    try {
-      return await tokenContract.supportsInterface(_controllerutils.ERC721_INTERFACE_ID);
-    } catch (error) {
-      return false;
-    }
-  }
-  _getProvider(networkClientId) {
-    return new (0, _providers.Web3Provider)(
-      // @ts-expect-error TODO: remove this annotation once the `Eip1193Provider` class is released
-      networkClientId ? this.messagingSystem.call(
-        "NetworkController:getNetworkClientById",
-        networkClientId
-      ).provider : this.config.provider
-    );
-  }
-  _createEthersContract(tokenAddress, abi, networkClientId) {
-    const web3provider = this._getProvider(networkClientId);
-    const tokenContract = new (0, _contracts.Contract)(tokenAddress, abi, web3provider);
-    return tokenContract;
-  }
-  _generateRandomId() {
-    return _uuid.v1.call(void 0, );
-  }
-  /**
-   * Adds a new suggestedAsset to the list of watched assets.
-   * Parameters will be validated according to the asset type being watched.
-   *
-   * @param options - The method options.
-   * @param options.asset - The asset to be watched. For now only ERC20 tokens are accepted.
-   * @param options.type - The asset type.
-   * @param options.interactingAddress - The address of the account that is requesting to watch the asset.
-   * @param options.networkClientId - Network Client ID.
-   * @returns A promise that resolves if the asset was watched successfully, and rejects otherwise.
-   */
-  async watchAsset({
-    asset,
-    type,
-    interactingAddress,
-    networkClientId
-  }) {
-    if (type !== _controllerutils.ERC20) {
-      throw new Error(`Asset of type ${type} not supported`);
-    }
-    if (!asset.address) {
-      throw _rpcerrors.rpcErrors.invalidParams("Address must be specified");
-    }
-    if (!_controllerutils.isValidHexAddress.call(void 0, asset.address)) {
-      throw _rpcerrors.rpcErrors.invalidParams(`Invalid address "${asset.address}"`);
-    }
-    if (await this._detectIsERC721(asset.address, networkClientId)) {
-      throw _rpcerrors.rpcErrors.invalidParams(
-        `Contract ${asset.address} must match type ${type}, but was detected as ${_controllerutils.ERC721}`
-      );
-    }
-    const provider = this._getProvider(networkClientId);
-    const isErc1155 = await _controllerutils.safelyExecute.call(void 0, 
-      () => new (0, _chunk3ZHN4GFTjs.ERC1155Standard)(provider).contractSupportsBase1155Interface(
-        asset.address
-      )
-    );
-    if (isErc1155) {
-      throw _rpcerrors.rpcErrors.invalidParams(
-        `Contract ${asset.address} must match type ${type}, but was detected as ${_controllerutils.ERC1155}`
-      );
-    }
-    const erc20 = new (0, _chunkBO2WZDUMjs.ERC20Standard)(provider);
-    const [contractName, contractSymbol, contractDecimals] = await Promise.all([
-      _controllerutils.safelyExecute.call(void 0, () => erc20.getTokenName(asset.address)),
-      _controllerutils.safelyExecute.call(void 0, () => erc20.getTokenSymbol(asset.address)),
-      _controllerutils.safelyExecute.call(void 0, async () => erc20.getTokenDecimals(asset.address))
-    ]);
-    asset.name = contractName;
-    if (!asset.symbol && !contractSymbol) {
-      throw _rpcerrors.rpcErrors.invalidParams(
-        "A symbol is required, but was not found in either the request or contract"
-      );
-    }
-    if (contractSymbol !== void 0 && asset.symbol !== void 0 && asset.symbol.toUpperCase() !== contractSymbol.toUpperCase()) {
-      throw _rpcerrors.rpcErrors.invalidParams(
-        `The symbol in the request (${asset.symbol}) does not match the symbol in the contract (${contractSymbol})`
-      );
-    }
-    asset.symbol = contractSymbol ?? asset.symbol;
-    if (typeof asset.symbol !== "string") {
-      throw _rpcerrors.rpcErrors.invalidParams(`Invalid symbol: not a string`);
-    }
-    if (asset.symbol.length > 11) {
-      throw _rpcerrors.rpcErrors.invalidParams(
-        `Invalid symbol "${asset.symbol}": longer than 11 characters`
-      );
-    }
-    if (asset.decimals === void 0 && contractDecimals === void 0) {
-      throw _rpcerrors.rpcErrors.invalidParams(
-        "Decimals are required, but were not found in either the request or contract"
-      );
-    }
-    if (contractDecimals !== void 0 && asset.decimals !== void 0 && String(asset.decimals) !== contractDecimals) {
-      throw _rpcerrors.rpcErrors.invalidParams(
-        `The decimals in the request (${asset.decimals}) do not match the decimals in the contract (${contractDecimals})`
-      );
-    }
-    const decimalsStr = contractDecimals ?? asset.decimals;
-    const decimalsNum = parseInt(decimalsStr, 10);
-    if (!Number.isInteger(decimalsNum) || decimalsNum > 36 || decimalsNum < 0) {
-      throw _rpcerrors.rpcErrors.invalidParams(
-        `Invalid decimals "${decimalsStr}": must be an integer 0 <= 36`
-      );
-    }
-    asset.decimals = decimalsNum;
-    const suggestedAssetMeta = {
-      asset,
-      id: this._generateRandomId(),
-      time: Date.now(),
-      type,
-      interactingAddress: interactingAddress || this.config.selectedAddress
-    };
-    await this._requestApproval(suggestedAssetMeta);
-    const { address, symbol, decimals, name, image } = asset;
-    await this.addToken({
-      address,
-      symbol,
-      decimals,
-      name,
-      image,
-      interactingAddress: suggestedAssetMeta.interactingAddress,
-      networkClientId
-    });
-  }
-  /**
-   * Takes a new tokens and ignoredTokens array for the current network/account combination
-   * and returns new allTokens and allIgnoredTokens state to update to.
-   *
-   * @param params - Object that holds token params.
-   * @param params.newTokens - The new tokens to set for the current network and selected account.
-   * @param params.newIgnoredTokens - The new ignored tokens to set for the current network and selected account.
-   * @param params.newDetectedTokens - The new detected tokens to set for the current network and selected account.
-   * @param params.interactingAddress - The account address to use to store the tokens.
-   * @param params.interactingChainId - The chainId to use to store the tokens.
-   * @returns The updated `allTokens` and `allIgnoredTokens` state.
-   */
-  _getNewAllTokensState(params) {
-    const {
-      newTokens,
-      newIgnoredTokens,
-      newDetectedTokens,
-      interactingAddress,
-      interactingChainId
-    } = params;
-    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
-    const { chainId, selectedAddress } = this.config;
-    const userAddressToAddTokens = interactingAddress ?? selectedAddress;
-    const chainIdToAddTokens = interactingChainId ?? chainId;
-    let newAllTokens = allTokens;
-    if (newTokens?.length || newTokens && allTokens && allTokens[chainIdToAddTokens] && allTokens[chainIdToAddTokens][userAddressToAddTokens]) {
-      const networkTokens = allTokens[chainIdToAddTokens];
-      const newNetworkTokens = {
-        ...networkTokens,
-        ...{ [userAddressToAddTokens]: newTokens }
-      };
-      newAllTokens = {
-        ...allTokens,
-        ...{ [chainIdToAddTokens]: newNetworkTokens }
-      };
-    }
-    let newAllIgnoredTokens = allIgnoredTokens;
-    if (newIgnoredTokens?.length || newIgnoredTokens && allIgnoredTokens && allIgnoredTokens[chainIdToAddTokens] && allIgnoredTokens[chainIdToAddTokens][userAddressToAddTokens]) {
-      const networkIgnoredTokens = allIgnoredTokens[chainIdToAddTokens];
-      const newIgnoredNetworkTokens = {
-        ...networkIgnoredTokens,
-        ...{ [userAddressToAddTokens]: newIgnoredTokens }
-      };
-      newAllIgnoredTokens = {
-        ...allIgnoredTokens,
-        ...{ [chainIdToAddTokens]: newIgnoredNetworkTokens }
-      };
-    }
-    let newAllDetectedTokens = allDetectedTokens;
-    if (newDetectedTokens?.length || newDetectedTokens && allDetectedTokens && allDetectedTokens[chainIdToAddTokens] && allDetectedTokens[chainIdToAddTokens][userAddressToAddTokens]) {
-      const networkDetectedTokens = allDetectedTokens[chainIdToAddTokens];
-      const newDetectedNetworkTokens = {
-        ...networkDetectedTokens,
-        ...{ [userAddressToAddTokens]: newDetectedTokens }
-      };
-      newAllDetectedTokens = {
-        ...allDetectedTokens,
-        ...{ [chainIdToAddTokens]: newDetectedNetworkTokens }
-      };
-    }
-    return { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens };
-  }
-  /**
-   * Removes all tokens from the ignored list.
-   */
-  clearIgnoredTokens() {
-    this.update({ ignoredTokens: [], allIgnoredTokens: {} });
-  }
-  async _requestApproval(suggestedAssetMeta) {
-    return this.messagingSystem.call(
-      "ApprovalController:addRequest",
-      {
-        id: suggestedAssetMeta.id,
-        origin: _controllerutils.ORIGIN_METAMASK,
-        type: _controllerutils.ApprovalType.WatchAsset,
-        requestData: {
-          id: suggestedAssetMeta.id,
-          interactingAddress: suggestedAssetMeta.interactingAddress,
-          asset: {
-            address: suggestedAssetMeta.asset.address,
-            decimals: suggestedAssetMeta.asset.decimals,
-            symbol: suggestedAssetMeta.asset.symbol,
-            image: suggestedAssetMeta.asset.image || null
-          }
-        }
-      },
-      true
-    );
-  }
-};
-var TokensController_default = TokensController;
-
-
-
-
-
-exports.getDefaultTokensState = getDefaultTokensState; exports.TokensController = TokensController; exports.TokensController_default = TokensController_default;
-//# sourceMappingURL=chunk-SOK5YX7I.js.map
\ No newline at end of file
diff --git a/dist/chunk-SOK5YX7I.js.map b/dist/chunk-SOK5YX7I.js.map
deleted file mode 100644
index 8316c2629b0a4fa06ba69744fc28040afa71b573..0000000000000000000000000000000000000000
--- a/dist/chunk-SOK5YX7I.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["../src/TokensController.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,SAAS,gBAAgB;AACzB,SAAS,oBAAoB;AAO7B,SAAS,wBAAwB;AACjC,OAAO,kBAAkB;AACzB;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,SAAS,iBAAiB;AAQ1B,SAAS,iBAAiB;AAE1B,SAAS,aAAa;AACtB,SAAS,oBAAoB;AAE7B,SAAS,MAAM,cAAc;AAwE7B,IAAM,iBAAiB;AAgDhB,IAAM,wBAAwB,MAAmB;AACtD,SAAO;AAAA,IACL,QAAQ,CAAC;AAAA,IACT,eAAe,CAAC;AAAA,IAChB,gBAAgB,CAAC;AAAA,IACjB,WAAW,CAAC;AAAA,IACZ,kBAAkB,CAAC;AAAA,IACnB,mBAAmB,CAAC;AAAA,EACtB;AACF;AAKO,IAAM,mBAAN,cAA+B,iBAGpC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqDA,YAAY;AAAA,IACV,SAAS;AAAA,IACT;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAKG;AACD,UAAM,QAAQ,KAAK;AA/DrB,SAAiB,QAAQ,IAAI,MAAM;AAoCnC;AAAA;AAAA;AAAA,eAAM,IAAI,aAAa;AAKvB;AAAA;AAAA;AAAA,SAAS,OAAO;AAwBd,SAAK,gBAAgB;AAAA,MACnB,iBAAiB;AAAA,MACjB,SAAS;AAAA,MACT,UAAU;AAAA,MACV,GAAG;AAAA,IACL;AAEA,SAAK,eAAe;AAAA,MAClB,GAAG,sBAAsB;AAAA,MACzB,GAAG;AAAA,IACL;AAEA,SAAK,WAAW;AAChB,SAAK,kBAAkB,IAAI,gBAAgB;AAE3C,SAAK,kBAAkB;AAEvB,SAAK,gBAAgB;AAAA,MACnB,GAAG,cAAc;AAAA,MACjB,KAAK,kBAAkB,KAAK,IAAI;AAAA,IAClC;AAEA,SAAK,gBAAgB;AAAA,MACnB;AAAA,MACA,CAAC,EAAE,gBAAgB,MAAM;AACvB,cAAM,EAAE,WAAW,kBAAkB,kBAAkB,IAAI,KAAK;AAChE,cAAM,EAAE,QAAQ,IAAI,KAAK;AACzB,aAAK,UAAU,EAAE,gBAAgB,CAAC;AAClC,aAAK,OAAO;AAAA,UACV,QAAQ,UAAU,OAAO,IAAI,eAAe,KAAK,CAAC;AAAA,UAClD,eAAe,iBAAiB,OAAO,IAAI,eAAe,KAAK,CAAC;AAAA,UAChE,gBAAgB,kBAAkB,OAAO,IAAI,eAAe,KAAK,CAAC;AAAA,QACpE,CAAC;AAAA,MACH;AAAA,IACF;AAEA,SAAK,gBAAgB;AAAA,MACnB;AAAA,MACA,CAAC,EAAE,eAAe,MAAM;AACtB,cAAM,EAAE,WAAW,kBAAkB,kBAAkB,IAAI,KAAK;AAChE,cAAM,EAAE,gBAAgB,IAAI,KAAK;AACjC,cAAM,EAAE,QAAQ,IAAI;AACpB,aAAK,gBAAgB,MAAM;AAC3B,aAAK,kBAAkB,IAAI,gBAAgB;AAC3C,aAAK,UAAU,EAAE,QAAQ,CAAC;AAC1B,aAAK,OAAO;AAAA,UACV,QAAQ,UAAU,OAAO,IAAI,eAAe,KAAK,CAAC;AAAA,UAClD,eAAe,iBAAiB,OAAO,IAAI,eAAe,KAAK,CAAC;AAAA,UAChE,gBAAgB,kBAAkB,OAAO,IAAI,eAAe,KAAK,CAAC;AAAA,QACpE,CAAC;AAAA,MACH;AAAA,IACF;AAEA,SAAK,gBAAgB;AAAA,MACnB;AAAA,MACA,CAAC,EAAE,UAAU,MAAM;AACjB,cAAM,EAAE,OAAO,IAAI,KAAK;AACxB,YAAI,OAAO,UAAU,CAAC,OAAO,CAAC,EAAE,MAAM;AACpC,eAAK,sBAAsB,WAAW,MAAM;AAAA,QAC9C;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAnHA,MAAc,mBACZ,cACqC;AACrC,QAAI;AACF,YAAM,QAAQ,MAAM;AAAA,QAClB,KAAK,OAAO;AAAA,QACZ;AAAA,QACA,KAAK,gBAAgB;AAAA,MACvB;AACA,aAAO;AAAA,IACT,SAAS,OAAO;AACd,UACE,iBAAiB,SACjB,MAAM,QAAQ,SAAS,+BAA+B,GACtD;AACA,eAAO;AAAA,MACT;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA+GA,MAAM,SAAS;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAQqB;AACnB,UAAM,EAAE,SAAS,gBAAgB,IAAI,KAAK;AAC1C,UAAM,cAAc,MAAM,KAAK,MAAM,QAAQ;AAC7C,UAAM,EAAE,WAAW,kBAAkB,kBAAkB,IAAI,KAAK;AAChE,QAAI,iBAAiB;AACrB,QAAI,iBAAiB;AACnB,uBAAiB,KAAK,gBAAgB;AAAA,QACpC;AAAA,QACA;AAAA,MACF,EAAE,cAAc;AAAA,IAClB;AAEA,UAAM,iBAAiB,sBAAsB;AAC7C,UAAM,iCAAiC,mBAAmB;AAE1D,QAAI;AACF,gBAAU,qBAAqB,OAAO;AACtC,YAAM,SAAS,UAAU,cAAc,IAAI,cAAc,KAAK,CAAC;AAC/D,YAAM,gBACJ,iBAAiB,cAAc,IAAI,cAAc,KAAK,CAAC;AACzD,YAAM,iBACJ,kBAAkB,cAAc,IAAI,cAAc,KAAK,CAAC;AAC1D,YAAM,YAAqB,CAAC,GAAG,MAAM;AACrC,YAAM,CAAC,UAAU,aAAa,IAAI,MAAM,QAAQ,IAAI;AAAA,QAClD,KAAK,gBAAgB,SAAS,eAAe;AAAA;AAAA,QAE7C,KAAK,mBAAmB,OAAO;AAAA,MACjC,CAAC;AAED,UAAI,CAAC,mBAAmB,mBAAmB,KAAK,OAAO,SAAS;AAC9D,cAAM,IAAI;AAAA,UACR;AAAA,QACF;AAAA,MACF;AACA,YAAM,WAAkB;AAAA,QACtB;AAAA,QACA;AAAA,QACA;AAAA,QACA,OACE,SACA,uBAAuB;AAAA,UACrB,SAAS;AAAA,UACT,cAAc;AAAA,QAChB,CAAC;AAAA,QACH;AAAA,QACA,aAAa,sBAAsB,eAAe,eAAe,CAAC,CAAC;AAAA,QACnE;AAAA,MACF;AACA,YAAM,gBAAgB,UAAU;AAAA,QAC9B,CAAC,UAAU,MAAM,QAAQ,YAAY,MAAM,QAAQ,YAAY;AAAA,MACjE;AACA,UAAI,kBAAkB,IAAI;AACxB,kBAAU,aAAa,IAAI;AAAA,MAC7B,OAAO;AACL,kBAAU,KAAK,QAAQ;AAAA,MACzB;AAEA,YAAM,mBAAmB,cAAc;AAAA,QACrC,CAAC,iBAAiB,aAAa,YAAY,MAAM,QAAQ,YAAY;AAAA,MACvE;AACA,YAAM,oBAAoB,eAAe;AAAA,QACvC,CAAC,UAAU,MAAM,QAAQ,YAAY,MAAM,QAAQ,YAAY;AAAA,MACjE;AAEA,YAAM,EAAE,cAAc,qBAAqB,qBAAqB,IAC9D,KAAK,sBAAsB;AAAA,QACzB;AAAA,QACA;AAAA,QACA;AAAA,QACA,oBAAoB;AAAA,QACpB,oBAAoB;AAAA,MACtB,CAAC;AAEH,UAAI,WAAiC;AAAA,QACnC,WAAW;AAAA,QACX,kBAAkB;AAAA,QAClB,mBAAmB;AAAA,MACrB;AAGA,UAAI,gCAAgC;AAClC,mBAAW;AAAA,UACT,GAAG;AAAA,UACH,QAAQ;AAAA,UACR,eAAe;AAAA,UACf,gBAAgB;AAAA,QAClB;AAAA,MACF;AAEA,WAAK,OAAO,QAAQ;AACpB,aAAO;AAAA,IACT,UAAE;AACA,kBAAY;AAAA,IACd;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,UAAU,gBAAyB,iBAAmC;AAC1E,UAAM,cAAc,MAAM,KAAK,MAAM,QAAQ;AAC7C,UAAM,EAAE,QAAQ,gBAAgB,cAAc,IAAI,KAAK;AACvD,UAAM,oBAA6C,CAAC;AAEpD,UAAM,eAAe,OAAO,OAAO,CAAC,QAAQ,YAAY;AACtD,aAAO,QAAQ,OAAO,IAAI;AAC1B,aAAO;AAAA,IACT,GAAG,CAAC,CAAiC;AACrC,QAAI;AACF,qBAAe,QAAQ,CAAC,eAAe;AACrC,cAAM,EAAE,SAAS,QAAQ,UAAU,OAAO,aAAa,KAAK,IAC1D;AACF,cAAM,kBAAkB,qBAAqB,OAAO;AACpD,cAAM,iBAAwB;AAAA,UAC5B,SAAS;AAAA,UACT;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF;AACA,qBAAa,OAAO,IAAI;AACxB,0BAAkB,QAAQ,YAAY,CAAC,IAAI;AAC3C,eAAO;AAAA,MACT,CAAC;AACD,YAAM,YAAY,OAAO,OAAO,YAAY;AAE5C,YAAM,oBAAoB,eAAe;AAAA,QACvC,CAAC,UAAU,CAAC,kBAAkB,MAAM,QAAQ,YAAY,CAAC;AAAA,MAC3D;AACA,YAAM,mBAAmB,cAAc;AAAA,QACrC,CAAC,iBAAiB,CAAC,aAAa,aAAa,YAAY,CAAC;AAAA,MAC5D;AAEA,UAAI;AACJ,UAAI,iBAAiB;AACnB,6BAAqB,KAAK,gBAAgB;AAAA,UACxC;AAAA,UACA;AAAA,QACF,EAAE,cAAc;AAAA,MAClB;AAEA,YAAM,EAAE,cAAc,sBAAsB,oBAAoB,IAC9D,KAAK,sBAAsB;AAAA,QACzB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AAEH,WAAK,OAAO;AAAA,QACV,QAAQ;AAAA,QACR,WAAW;AAAA,QACX,gBAAgB;AAAA,QAChB,mBAAmB;AAAA,QACnB,eAAe;AAAA,QACf,kBAAkB;AAAA,MACpB,CAAC;AAAA,IACH,UAAE;AACA,kBAAY;AAAA,IACd;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,aAAa,wBAAkC;AAC7C,UAAM,EAAE,eAAe,gBAAgB,OAAO,IAAI,KAAK;AACvD,UAAM,mBAA4C,CAAC;AACnD,QAAI,mBAA6B,CAAC,GAAG,aAAa;AAElD,UAAM,4BAA4B,uBAAuB,IAAI,CAAC,YAAY;AACxE,YAAM,kBAAkB,qBAAqB,OAAO;AACpD,uBAAiB,QAAQ,YAAY,CAAC,IAAI;AAC1C,aAAO;AAAA,IACT,CAAC;AACD,uBAAmB,CAAC,GAAG,eAAe,GAAG,yBAAyB;AAClE,UAAM,oBAAoB,eAAe;AAAA,MACvC,CAAC,UAAU,CAAC,iBAAiB,MAAM,QAAQ,YAAY,CAAC;AAAA,IAC1D;AACA,UAAM,YAAY,OAAO;AAAA,MACvB,CAAC,UAAU,CAAC,iBAAiB,MAAM,QAAQ,YAAY,CAAC;AAAA,IAC1D;AAEA,UAAM,EAAE,qBAAqB,sBAAsB,aAAa,IAC9D,KAAK,sBAAsB;AAAA,MACzB;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAEH,SAAK,OAAO;AAAA,MACV,eAAe;AAAA,MACf,QAAQ;AAAA,MACR,gBAAgB;AAAA,MAChB,kBAAkB;AAAA,MAClB,mBAAmB;AAAA,MACnB,WAAW;AAAA,IACb,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,kBACJ,wBACA,kBACA;AACA,UAAM,cAAc,MAAM,KAAK,MAAM,QAAQ;AAG7C,UAAM,UAAU,kBAAkB,WAAW,KAAK,OAAO;AACzD,UAAM,iBACJ,kBAAkB,mBAAmB,KAAK,OAAO;AAEnD,UAAM,EAAE,WAAW,mBAAmB,iBAAiB,IAAI,KAAK;AAChE,QAAI,YAAY,CAAC,GAAI,YAAY,OAAO,IAAI,cAAc,KAAK,CAAC,CAAE;AAClE,QAAI,oBAAoB;AAAA,MACtB,GAAI,oBAAoB,OAAO,IAAI,cAAc,KAAK,CAAC;AAAA,IACzD;AAEA,QAAI;AACF,6BAAuB,QAAQ,CAAC,eAAe;AAC7C,cAAM;AAAA,UACJ;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF,IAAI;AACJ,cAAM,kBAAkB,qBAAqB,OAAO;AACpD,cAAM,WAAkB;AAAA,UACtB,SAAS;AAAA,UACT;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF;AACA,cAAM,wBAAwB,UAAU;AAAA,UACtC,CAAC,UACC,MAAM,QAAQ,YAAY,MAAM,gBAAgB,YAAY;AAAA,QAChE;AACA,YAAI,0BAA0B,IAAI;AAEhC,oBAAU,qBAAqB,IAAI;AAAA,QACrC,OAAO;AACL,gBAAM,oBACJ,mBAAmB,OAAO,IAAI,cAAc,GAAG,QAAQ,OAAO,KAC9D;AAEF,cAAI,sBAAsB,IAAI;AAE5B,kBAAM,wBAAwB,kBAAkB;AAAA,cAC9C,CAAC,UACC,MAAM,QAAQ,YAAY,MAAM,gBAAgB,YAAY;AAAA,YAChE;AACA,gBAAI,0BAA0B,IAAI;AAChC,gCAAkB,qBAAqB,IAAI;AAAA,YAC7C,OAAO;AACL,gCAAkB,KAAK,QAAQ;AAAA,YACjC;AAAA,UACF;AAAA,QACF;AAAA,MACF,CAAC;AAED,YAAM,EAAE,cAAc,qBAAqB,IAAI,KAAK;AAAA,QAClD;AAAA,UACE;AAAA,UACA;AAAA,UACA,oBAAoB;AAAA,UACpB,oBAAoB;AAAA,QACtB;AAAA,MACF;AAIA,YAAM,EAAE,SAAS,cAAc,iBAAiB,eAAe,IAC7D,KAAK;AAEP,kBAAY,eAAe,YAAY,IAAI,cAAc,KAAK,CAAC;AAC/D,0BACE,uBAAuB,YAAY,IAAI,cAAc,KAAK,CAAC;AAE7D,WAAK,OAAO;AAAA,QACV,QAAQ;AAAA,QACR,WAAW;AAAA,QACX,gBAAgB;AAAA,QAChB,mBAAmB;AAAA,MACrB,CAAC;AAAA,IACH,UAAE;AACA,kBAAY;AAAA,IACd;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,gBAAgB,cAAsB;AAC1C,UAAM,WAAW,MAAM,KAAK,gBAAgB,YAAY;AACxD,UAAM,EAAE,OAAO,IAAI,KAAK;AACxB,UAAM,aAAa,OAAO,UAAU,CAAC,UAAU;AAC7C,aAAO,MAAM,QAAQ,YAAY,MAAM,aAAa,YAAY;AAAA,IAClE,CAAC;AACD,WAAO,UAAU,EAAE,WAAW;AAC9B,SAAK,OAAO,EAAE,OAAO,CAAC;AACtB,WAAO,OAAO,UAAU;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,sBACN,WACA,gBACA;AACA,UAAM,EAAE,OAAO,IAAI,KAAK;AAExB,UAAM,YAAY,OAAO,IAAI,CAAC,UAAU;AACtC,YAAM,WAAW,UAAU,MAAM,QAAQ,YAAY,CAAC;AAEtD,aAAO,CAAC,MAAM,cAAc,KAAK,WAAW,cAAc,IACtD,EAAE,GAAG,OAAO,CAAC,cAAc,GAAG,SAAS,cAAc,EAAE,IACvD,EAAE,GAAG,MAAM;AAAA,IACjB,CAAC;AAED,SAAK,OAAO,EAAE,QAAQ,UAAU,CAAC;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,gBACJ,cACA,iBACA;AACA,UAAM,kBAAkB,qBAAqB,YAAY;AAGzD,QAAI,aAAa,eAAe,GAAG,WAAW,MAAM;AAClD,aAAO,QAAQ,QAAQ,IAAI;AAAA,IAC7B,WAAW,aAAa,eAAe,GAAG,UAAU,MAAM;AACxD,aAAO,QAAQ,QAAQ,KAAK;AAAA,IAC9B;AAEA,UAAM,gBAAgB,KAAK;AAAA,MACzB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,QAAI;AACF,aAAO,MAAM,cAAc,kBAAkB,mBAAmB;AAAA,IAClE,SAAS,OAAO;AAKd,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EAEA,aAAa,iBAAiD;AAC5D,WAAO,IAAI;AAAA;AAAA,MAET,kBACI,KAAK,gBAAgB;AAAA,QACnB;AAAA,QACA;AAAA,MACF,EAAE,WACF,KAAK,OAAO;AAAA,IAClB;AAAA,EACF;AAAA,EAEA,sBACE,cACA,KACA,iBACU;AACV,UAAM,eAAe,KAAK,aAAa,eAAe;AACtD,UAAM,gBAAgB,IAAI,SAAS,cAAc,KAAK,YAAY;AAClE,WAAO;AAAA,EACT;AAAA,EAEA,oBAA4B;AAC1B,WAAO,OAAO;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,MAAM,WAAW;AAAA,IACf;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAKkB;AAChB,QAAI,SAAS,OAAO;AAClB,YAAM,IAAI,MAAM,iBAAiB,IAAI,gBAAgB;AAAA,IACvD;AAEA,QAAI,CAAC,MAAM,SAAS;AAClB,YAAM,UAAU,cAAc,2BAA2B;AAAA,IAC3D;AAEA,QAAI,CAAC,kBAAkB,MAAM,OAAO,GAAG;AACrC,YAAM,UAAU,cAAc,oBAAoB,MAAM,OAAO,GAAG;AAAA,IACpE;AAIA,QAAI,MAAM,KAAK,gBAAgB,MAAM,SAAS,eAAe,GAAG;AAC9D,YAAM,UAAU;AAAA,QACd,YAAY,MAAM,OAAO,oBAAoB,IAAI,yBAAyB,MAAM;AAAA,MAClF;AAAA,IACF;AAEA,UAAM,WAAW,KAAK,aAAa,eAAe;AAClD,UAAM,YAAY,MAAM;AAAA,MAAc,MACpC,IAAI,gBAAgB,QAAQ,EAAE;AAAA,QAC5B,MAAM;AAAA,MACR;AAAA,IACF;AACA,QAAI,WAAW;AACb,YAAM,UAAU;AAAA,QACd,YAAY,MAAM,OAAO,oBAAoB,IAAI,yBAAyB,OAAO;AAAA,MACnF;AAAA,IACF;AAEA,UAAM,QAAQ,IAAI,cAAc,QAAQ;AACxC,UAAM,CAAC,cAAc,gBAAgB,gBAAgB,IAAI,MAAM,QAAQ,IAAI;AAAA,MACzE,cAAc,MAAM,MAAM,aAAa,MAAM,OAAO,CAAC;AAAA,MACrD,cAAc,MAAM,MAAM,eAAe,MAAM,OAAO,CAAC;AAAA,MACvD,cAAc,YAAY,MAAM,iBAAiB,MAAM,OAAO,CAAC;AAAA,IACjE,CAAC;AAED,UAAM,OAAO;AAIb,QAAI,CAAC,MAAM,UAAU,CAAC,gBAAgB;AACpC,YAAM,UAAU;AAAA,QACd;AAAA,MACF;AAAA,IACF;AAEA,QACE,mBAAmB,UACnB,MAAM,WAAW,UACjB,MAAM,OAAO,YAAY,MAAM,eAAe,YAAY,GAC1D;AACA,YAAM,UAAU;AAAA,QACd,8BAA8B,MAAM,MAAM,gDAAgD,cAAc;AAAA,MAC1G;AAAA,IACF;AAEA,UAAM,SAAS,kBAAkB,MAAM;AACvC,QAAI,OAAO,MAAM,WAAW,UAAU;AACpC,YAAM,UAAU,cAAc,8BAA8B;AAAA,IAC9D;AAEA,QAAI,MAAM,OAAO,SAAS,IAAI;AAC5B,YAAM,UAAU;AAAA,QACd,mBAAmB,MAAM,MAAM;AAAA,MACjC;AAAA,IACF;AAIA,QAAI,MAAM,aAAa,UAAa,qBAAqB,QAAW;AAClE,YAAM,UAAU;AAAA,QACd;AAAA,MACF;AAAA,IACF;AAEA,QACE,qBAAqB,UACrB,MAAM,aAAa,UACnB,OAAO,MAAM,QAAQ,MAAM,kBAC3B;AACA,YAAM,UAAU;AAAA,QACd,gCAAgC,MAAM,QAAQ,gDAAgD,gBAAgB;AAAA,MAChH;AAAA,IACF;AAEA,UAAM,cAAc,oBAAoB,MAAM;AAC9C,UAAM,cAAc,SAAS,aAAkC,EAAE;AACjE,QAAI,CAAC,OAAO,UAAU,WAAW,KAAK,cAAc,MAAM,cAAc,GAAG;AACzE,YAAM,UAAU;AAAA,QACd,qBAAqB,WAAW;AAAA,MAClC;AAAA,IACF;AACA,UAAM,WAAW;AAEjB,UAAM,qBAAyC;AAAA,MAC7C;AAAA,MACA,IAAI,KAAK,kBAAkB;AAAA,MAC3B,MAAM,KAAK,IAAI;AAAA,MACf;AAAA,MACA,oBAAoB,sBAAsB,KAAK,OAAO;AAAA,IACxD;AAEA,UAAM,KAAK,iBAAiB,kBAAkB;AAE9C,UAAM,EAAE,SAAS,QAAQ,UAAU,MAAM,MAAM,IAAI;AACnD,UAAM,KAAK,SAAS;AAAA,MAClB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,oBAAoB,mBAAmB;AAAA,MACvC;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,sBAAsB,QAMnB;AACD,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,IAAI;AACJ,UAAM,EAAE,WAAW,kBAAkB,kBAAkB,IAAI,KAAK;AAChE,UAAM,EAAE,SAAS,gBAAgB,IAAI,KAAK;AAE1C,UAAM,yBAAyB,sBAAsB;AACrD,UAAM,qBAAqB,sBAAsB;AAEjD,QAAI,eAAe;AACnB,QACE,WAAW,UACV,aACC,aACA,UAAU,kBAAkB,KAC5B,UAAU,kBAAkB,EAAE,sBAAsB,GACtD;AACA,YAAM,gBAAgB,UAAU,kBAAkB;AAClD,YAAM,mBAAmB;AAAA,QACvB,GAAG;AAAA,QACH,GAAG,EAAE,CAAC,sBAAsB,GAAG,UAAU;AAAA,MAC3C;AACA,qBAAe;AAAA,QACb,GAAG;AAAA,QACH,GAAG,EAAE,CAAC,kBAAkB,GAAG,iBAAiB;AAAA,MAC9C;AAAA,IACF;AAEA,QAAI,sBAAsB;AAC1B,QACE,kBAAkB,UACjB,oBACC,oBACA,iBAAiB,kBAAkB,KACnC,iBAAiB,kBAAkB,EAAE,sBAAsB,GAC7D;AACA,YAAM,uBAAuB,iBAAiB,kBAAkB;AAChE,YAAM,0BAA0B;AAAA,QAC9B,GAAG;AAAA,QACH,GAAG,EAAE,CAAC,sBAAsB,GAAG,iBAAiB;AAAA,MAClD;AACA,4BAAsB;AAAA,QACpB,GAAG;AAAA,QACH,GAAG,EAAE,CAAC,kBAAkB,GAAG,wBAAwB;AAAA,MACrD;AAAA,IACF;AAEA,QAAI,uBAAuB;AAC3B,QACE,mBAAmB,UAClB,qBACC,qBACA,kBAAkB,kBAAkB,KACpC,kBAAkB,kBAAkB,EAAE,sBAAsB,GAC9D;AACA,YAAM,wBAAwB,kBAAkB,kBAAkB;AAClE,YAAM,2BAA2B;AAAA,QAC/B,GAAG;AAAA,QACH,GAAG,EAAE,CAAC,sBAAsB,GAAG,kBAAkB;AAAA,MACnD;AACA,6BAAuB;AAAA,QACrB,GAAG;AAAA,QACH,GAAG,EAAE,CAAC,kBAAkB,GAAG,yBAAyB;AAAA,MACtD;AAAA,IACF;AACA,WAAO,EAAE,cAAc,qBAAqB,qBAAqB;AAAA,EACnE;AAAA;AAAA;AAAA;AAAA,EAKA,qBAAqB;AACnB,SAAK,OAAO,EAAE,eAAe,CAAC,GAAG,kBAAkB,CAAC,EAAE,CAAC;AAAA,EACzD;AAAA,EAEA,MAAM,iBAAiB,oBAAwC;AAC7D,WAAO,KAAK,gBAAgB;AAAA,MAC1B;AAAA,MACA;AAAA,QACE,IAAI,mBAAmB;AAAA,QACvB,QAAQ;AAAA,QACR,MAAM,aAAa;AAAA,QACnB,aAAa;AAAA,UACX,IAAI,mBAAmB;AAAA,UACvB,oBAAoB,mBAAmB;AAAA,UACvC,OAAO;AAAA,YACL,SAAS,mBAAmB,MAAM;AAAA,YAClC,UAAU,mBAAmB,MAAM;AAAA,YACnC,QAAQ,mBAAmB,MAAM;AAAA,YACjC,OAAO,mBAAmB,MAAM,SAAS;AAAA,UAC3C;AAAA,QACF;AAAA,MACF;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;AAEA,IAAO,2BAAQ","sourcesContent":["import { Contract } from '@ethersproject/contracts';\nimport { Web3Provider } from '@ethersproject/providers';\nimport type { AddApprovalRequest } from '@metamask/approval-controller';\nimport type {\n  BaseConfig,\n  BaseState,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseControllerV1 } from '@metamask/base-controller';\nimport contractsMap from '@metamask/contract-metadata';\nimport {\n  toChecksumHexAddress,\n  ERC721_INTERFACE_ID,\n  ORIGIN_METAMASK,\n  ApprovalType,\n  ERC20,\n  ERC721,\n  ERC1155,\n  isValidHexAddress,\n  safelyExecute,\n} from '@metamask/controller-utils';\nimport { abiERC721 } from '@metamask/metamask-eth-abis';\nimport type {\n  NetworkClientId,\n  NetworkControllerGetNetworkClientByIdAction,\n  NetworkControllerNetworkDidChangeEvent,\n  Provider,\n} from '@metamask/network-controller';\nimport type { PreferencesControllerStateChangeEvent } from '@metamask/preferences-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { Hex } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport { EventEmitter } from 'events';\nimport type { Patch } from 'immer/dist/immer';\nimport { v1 as random } from 'uuid';\n\nimport { formatAggregatorNames, formatIconUrlWithProxy } from './assetsUtil';\nimport { ERC20Standard } from './Standards/ERC20Standard';\nimport { ERC1155Standard } from './Standards/NftStandards/ERC1155/ERC1155Standard';\nimport {\n  fetchTokenMetadata,\n  TOKEN_METADATA_NO_SUPPORT_ERROR,\n} from './token-service';\nimport type {\n  TokenListMap,\n  TokenListStateChange,\n  TokenListToken,\n} from './TokenListController';\nimport type { Token } from './TokenRatesController';\n\n/**\n * @type TokensConfig\n *\n * Tokens controller configuration\n * @property selectedAddress - Vault selected address\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface TokensConfig extends BaseConfig {\n  selectedAddress: string;\n  chainId: Hex;\n  provider: Provider | undefined;\n}\n\n/**\n * @type SuggestedAssetMeta\n *\n * Suggested asset by EIP747 meta data\n * @property id - Generated UUID associated with this suggested asset\n * @property time - Timestamp associated with this this suggested asset\n * @property type - Type type this suggested asset\n * @property asset - Asset suggested object\n * @property interactingAddress - Account address that requested watch asset\n */\ntype SuggestedAssetMeta = {\n  id: string;\n  time: number;\n  type: string;\n  asset: Token;\n  interactingAddress: string;\n};\n\n/**\n * @type TokensState\n *\n * Assets controller state\n * @property tokens - List of tokens associated with the active network and address pair\n * @property ignoredTokens - List of ignoredTokens associated with the active network and address pair\n * @property detectedTokens - List of detected tokens associated with the active network and address pair\n * @property allTokens - Object containing tokens by network and account\n * @property allIgnoredTokens - Object containing hidden/ignored tokens by network and account\n * @property allDetectedTokens - Object containing tokens detected with non-zero balances\n */\nexport type TokensState = {\n  tokens: Token[];\n  ignoredTokens: string[];\n  detectedTokens: Token[];\n  allTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n  allIgnoredTokens: { [chainId: Hex]: { [key: string]: string[] } };\n  allDetectedTokens: { [chainId: Hex]: { [key: string]: Token[] } };\n};\n\n/**\n * The name of the {@link TokensController}.\n */\nconst controllerName = 'TokensController';\n\nexport type TokensControllerActions =\n  | TokensControllerGetStateAction\n  | TokensControllerAddDetectedTokensAction;\n\n// TODO: Once `TokensController` is upgraded to V2, rewrite this type using the `ControllerGetStateAction` type, which constrains `TokensState` as `Record<string, Json>`.\nexport type TokensControllerGetStateAction = {\n  type: `${typeof controllerName}:getState`;\n  handler: () => TokensState;\n};\n\nexport type TokensControllerAddDetectedTokensAction = {\n  type: `${typeof controllerName}:addDetectedTokens`;\n  handler: TokensController['addDetectedTokens'];\n};\n\n/**\n * The external actions available to the {@link TokensController}.\n */\nexport type AllowedActions =\n  | AddApprovalRequest\n  | NetworkControllerGetNetworkClientByIdAction;\n\n// TODO: Once `TokensController` is upgraded to V2, rewrite this type using the `ControllerStateChangeEvent` type, which constrains `TokensState` as `Record<string, Json>`.\nexport type TokensControllerStateChangeEvent = {\n  type: `${typeof controllerName}:stateChange`;\n  payload: [TokensState, Patch[]];\n};\n\nexport type TokensControllerEvents = TokensControllerStateChangeEvent;\n\nexport type AllowedEvents =\n  | NetworkControllerNetworkDidChangeEvent\n  | PreferencesControllerStateChangeEvent\n  | TokenListStateChange;\n\n/**\n * The messenger of the {@link TokensController}.\n */\nexport type TokensControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  TokensControllerActions | AllowedActions,\n  TokensControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\nexport const getDefaultTokensState = (): TokensState => {\n  return {\n    tokens: [],\n    ignoredTokens: [],\n    detectedTokens: [],\n    allTokens: {},\n    allIgnoredTokens: {},\n    allDetectedTokens: {},\n  };\n};\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class TokensController extends BaseControllerV1<\n  TokensConfig,\n  TokensState & BaseState\n> {\n  private readonly mutex = new Mutex();\n\n  private abortController: AbortController;\n\n  private readonly messagingSystem: TokensControllerMessenger;\n\n  /**\n   * Fetch metadata for a token.\n   *\n   * @param tokenAddress - The address of the token.\n   * @returns The token metadata.\n   */\n  private async fetchTokenMetadata(\n    tokenAddress: string,\n  ): Promise<TokenListToken | undefined> {\n    try {\n      const token = await fetchTokenMetadata<TokenListToken>(\n        this.config.chainId,\n        tokenAddress,\n        this.abortController.signal,\n      );\n      return token;\n    } catch (error) {\n      if (\n        error instanceof Error &&\n        error.message.includes(TOKEN_METADATA_NO_SUPPORT_ERROR)\n      ) {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokensController';\n\n  /**\n   * Creates a TokensController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.config - Initial options used to configure this controller.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.messenger - The controller messenger.\n   */\n  constructor({\n    chainId: initialChainId,\n    config,\n    state,\n    messenger,\n  }: {\n    chainId: Hex;\n    config?: Partial<TokensConfig>;\n    state?: Partial<TokensState>;\n    messenger: TokensControllerMessenger;\n  }) {\n    super(config, state);\n\n    this.defaultConfig = {\n      selectedAddress: '',\n      chainId: initialChainId,\n      provider: undefined,\n      ...config,\n    };\n\n    this.defaultState = {\n      ...getDefaultTokensState(),\n      ...state,\n    };\n\n    this.initialize();\n    this.abortController = new AbortController();\n\n    this.messagingSystem = messenger;\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:addDetectedTokens` as const,\n      this.addDetectedTokens.bind(this),\n    );\n\n    this.messagingSystem.subscribe(\n      'PreferencesController:stateChange',\n      ({ selectedAddress }) => {\n        const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n        const { chainId } = this.config;\n        this.configure({ selectedAddress });\n        this.update({\n          tokens: allTokens[chainId]?.[selectedAddress] ?? [],\n          ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] ?? [],\n          detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] ?? [],\n        });\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'NetworkController:networkDidChange',\n      ({ providerConfig }) => {\n        const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n        const { selectedAddress } = this.config;\n        const { chainId } = providerConfig;\n        this.abortController.abort();\n        this.abortController = new AbortController();\n        this.configure({ chainId });\n        this.update({\n          tokens: allTokens[chainId]?.[selectedAddress] || [],\n          ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] || [],\n          detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] || [],\n        });\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'TokenListController:stateChange',\n      ({ tokenList }) => {\n        const { tokens } = this.state;\n        if (tokens.length && !tokens[0].name) {\n          this.updateTokensAttribute(tokenList, 'name');\n        }\n      },\n    );\n  }\n\n  /**\n   * Adds a token to the stored token list.\n   *\n   * @param options - The method argument object.\n   * @param options.address - Hex address of the token contract.\n   * @param options.symbol - Symbol of the token.\n   * @param options.decimals - Number of decimals the token uses.\n   * @param options.name - Name of the token.\n   * @param options.image - Image of the token.\n   * @param options.interactingAddress - The address of the account to add a token to.\n   * @param options.networkClientId - Network Client ID.\n   * @returns Current token list.\n   */\n  async addToken({\n    address,\n    symbol,\n    decimals,\n    name,\n    image,\n    interactingAddress,\n    networkClientId,\n  }: {\n    address: string;\n    symbol: string;\n    decimals: number;\n    name?: string;\n    image?: string;\n    interactingAddress?: string;\n    networkClientId?: NetworkClientId;\n  }): Promise<Token[]> {\n    const { chainId, selectedAddress } = this.config;\n    const releaseLock = await this.mutex.acquire();\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    let currentChainId = chainId;\n    if (networkClientId) {\n      currentChainId = this.messagingSystem.call(\n        'NetworkController:getNetworkClientById',\n        networkClientId,\n      ).configuration.chainId;\n    }\n\n    const accountAddress = interactingAddress || selectedAddress;\n    const isInteractingWithWalletAccount = accountAddress === selectedAddress;\n\n    try {\n      address = toChecksumHexAddress(address);\n      const tokens = allTokens[currentChainId]?.[accountAddress] || [];\n      const ignoredTokens =\n        allIgnoredTokens[currentChainId]?.[accountAddress] || [];\n      const detectedTokens =\n        allDetectedTokens[currentChainId]?.[accountAddress] || [];\n      const newTokens: Token[] = [...tokens];\n      const [isERC721, tokenMetadata] = await Promise.all([\n        this._detectIsERC721(address, networkClientId),\n        // TODO parameterize the token metadata fetch by networkClientId\n        this.fetchTokenMetadata(address),\n      ]);\n      // TODO remove this once this method is fully parameterized by networkClientId\n      if (!networkClientId && currentChainId !== this.config.chainId) {\n        throw new Error(\n          'TokensController Error: Switched networks while adding token',\n        );\n      }\n      const newEntry: Token = {\n        address,\n        symbol,\n        decimals,\n        image:\n          image ||\n          formatIconUrlWithProxy({\n            chainId: currentChainId,\n            tokenAddress: address,\n          }),\n        isERC721,\n        aggregators: formatAggregatorNames(tokenMetadata?.aggregators || []),\n        name,\n      };\n      const previousIndex = newTokens.findIndex(\n        (token) => token.address.toLowerCase() === address.toLowerCase(),\n      );\n      if (previousIndex !== -1) {\n        newTokens[previousIndex] = newEntry;\n      } else {\n        newTokens.push(newEntry);\n      }\n\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase(),\n      );\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => token.address.toLowerCase() !== address.toLowerCase(),\n      );\n\n      const { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens } =\n        this._getNewAllTokensState({\n          newTokens,\n          newIgnoredTokens,\n          newDetectedTokens,\n          interactingAddress: accountAddress,\n          interactingChainId: currentChainId,\n        });\n\n      let newState: Partial<TokensState> = {\n        allTokens: newAllTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n        allDetectedTokens: newAllDetectedTokens,\n      };\n\n      // Only update active tokens if user is interacting with their active wallet account.\n      if (isInteractingWithWalletAccount) {\n        newState = {\n          ...newState,\n          tokens: newTokens,\n          ignoredTokens: newIgnoredTokens,\n          detectedTokens: newDetectedTokens,\n        };\n      }\n\n      this.update(newState);\n      return newTokens;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Add a batch of tokens.\n   *\n   * @param tokensToImport - Array of tokens to import.\n   * @param networkClientId - Optional network client ID used to determine interacting chain ID.\n   */\n  async addTokens(tokensToImport: Token[], networkClientId?: NetworkClientId) {\n    const releaseLock = await this.mutex.acquire();\n    const { tokens, detectedTokens, ignoredTokens } = this.state;\n    const importedTokensMap: { [key: string]: true } = {};\n    // Used later to dedupe imported tokens\n    const newTokensMap = tokens.reduce((output, current) => {\n      output[current.address] = current;\n      return output;\n    }, {} as { [address: string]: Token });\n    try {\n      tokensToImport.forEach((tokenToAdd) => {\n        const { address, symbol, decimals, image, aggregators, name } =\n          tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const formattedToken: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          aggregators,\n          name,\n        };\n        newTokensMap[address] = formattedToken;\n        importedTokensMap[address.toLowerCase()] = true;\n        return formattedToken;\n      });\n      const newTokens = Object.values(newTokensMap);\n\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => !importedTokensMap[token.address.toLowerCase()],\n      );\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => !newTokensMap[tokenAddress.toLowerCase()],\n      );\n\n      let interactingChainId;\n      if (networkClientId) {\n        interactingChainId = this.messagingSystem.call(\n          'NetworkController:getNetworkClientById',\n          networkClientId,\n        ).configuration.chainId;\n      }\n\n      const { newAllTokens, newAllDetectedTokens, newAllIgnoredTokens } =\n        this._getNewAllTokensState({\n          newTokens,\n          newDetectedTokens,\n          newIgnoredTokens,\n          interactingChainId,\n        });\n\n      this.update({\n        tokens: newTokens,\n        allTokens: newAllTokens,\n        detectedTokens: newDetectedTokens,\n        allDetectedTokens: newAllDetectedTokens,\n        ignoredTokens: newIgnoredTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Ignore a batch of tokens.\n   *\n   * @param tokenAddressesToIgnore - Array of token addresses to ignore.\n   */\n  ignoreTokens(tokenAddressesToIgnore: string[]) {\n    const { ignoredTokens, detectedTokens, tokens } = this.state;\n    const ignoredTokensMap: { [key: string]: true } = {};\n    let newIgnoredTokens: string[] = [...ignoredTokens];\n\n    const checksummedTokenAddresses = tokenAddressesToIgnore.map((address) => {\n      const checksumAddress = toChecksumHexAddress(address);\n      ignoredTokensMap[address.toLowerCase()] = true;\n      return checksumAddress;\n    });\n    newIgnoredTokens = [...ignoredTokens, ...checksummedTokenAddresses];\n    const newDetectedTokens = detectedTokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n    const newTokens = tokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n\n    const { newAllIgnoredTokens, newAllDetectedTokens, newAllTokens } =\n      this._getNewAllTokensState({\n        newIgnoredTokens,\n        newDetectedTokens,\n        newTokens,\n      });\n\n    this.update({\n      ignoredTokens: newIgnoredTokens,\n      tokens: newTokens,\n      detectedTokens: newDetectedTokens,\n      allIgnoredTokens: newAllIgnoredTokens,\n      allDetectedTokens: newAllDetectedTokens,\n      allTokens: newAllTokens,\n    });\n  }\n\n  /**\n   * Adds a batch of detected tokens to the stored token list.\n   *\n   * @param incomingDetectedTokens - Array of detected tokens to be added or updated.\n   * @param detectionDetails - An object containing the chain ID and address of the currently selected network on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.selectedAddress - the account address on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.chainId - the chainId on which the incomingDetectedTokens were detected.\n   */\n  async addDetectedTokens(\n    incomingDetectedTokens: Token[],\n    detectionDetails?: { selectedAddress: string; chainId: Hex },\n  ) {\n    const releaseLock = await this.mutex.acquire();\n\n    // Get existing tokens for the chain + account\n    const chainId = detectionDetails?.chainId ?? this.config.chainId;\n    const accountAddress =\n      detectionDetails?.selectedAddress ?? this.config.selectedAddress;\n\n    const { allTokens, allDetectedTokens, allIgnoredTokens } = this.state;\n    let newTokens = [...(allTokens?.[chainId]?.[accountAddress] ?? [])];\n    let newDetectedTokens = [\n      ...(allDetectedTokens?.[chainId]?.[accountAddress] ?? []),\n    ];\n\n    try {\n      incomingDetectedTokens.forEach((tokenToAdd) => {\n        const {\n          address,\n          symbol,\n          decimals,\n          image,\n          aggregators,\n          isERC721,\n          name,\n        } = tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const newEntry: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          isERC721,\n          aggregators,\n          name,\n        };\n        const previousImportedIndex = newTokens.findIndex(\n          (token) =>\n            token.address.toLowerCase() === checksumAddress.toLowerCase(),\n        );\n        if (previousImportedIndex !== -1) {\n          // Update existing data of imported token\n          newTokens[previousImportedIndex] = newEntry;\n        } else {\n          const ignoredTokenIndex =\n            allIgnoredTokens?.[chainId]?.[accountAddress]?.indexOf(address) ??\n            -1;\n\n          if (ignoredTokenIndex === -1) {\n            // Add detected token\n            const previousDetectedIndex = newDetectedTokens.findIndex(\n              (token) =>\n                token.address.toLowerCase() === checksumAddress.toLowerCase(),\n            );\n            if (previousDetectedIndex !== -1) {\n              newDetectedTokens[previousDetectedIndex] = newEntry;\n            } else {\n              newDetectedTokens.push(newEntry);\n            }\n          }\n        }\n      });\n\n      const { newAllTokens, newAllDetectedTokens } = this._getNewAllTokensState(\n        {\n          newTokens,\n          newDetectedTokens,\n          interactingAddress: accountAddress,\n          interactingChainId: chainId,\n        },\n      );\n\n      // We may be detecting tokens on a different chain/account pair than are currently configured.\n      // Re-point `tokens` and `detectedTokens` to keep them referencing the current chain/account.\n      const { chainId: currentChain, selectedAddress: currentAddress } =\n        this.config;\n\n      newTokens = newAllTokens?.[currentChain]?.[currentAddress] || [];\n      newDetectedTokens =\n        newAllDetectedTokens?.[currentChain]?.[currentAddress] || [];\n\n      this.update({\n        tokens: newTokens,\n        allTokens: newAllTokens,\n        detectedTokens: newDetectedTokens,\n        allDetectedTokens: newAllDetectedTokens,\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds isERC721 field to token object. This is called when a user attempts to add tokens that\n   * were previously added which do not yet had isERC721 field.\n   *\n   * @param tokenAddress - The contract address of the token requiring the isERC721 field added.\n   * @returns The new token object with the added isERC721 field.\n   */\n  async updateTokenType(tokenAddress: string) {\n    const isERC721 = await this._detectIsERC721(tokenAddress);\n    const { tokens } = this.state;\n    const tokenIndex = tokens.findIndex((token) => {\n      return token.address.toLowerCase() === tokenAddress.toLowerCase();\n    });\n    tokens[tokenIndex].isERC721 = isERC721;\n    this.update({ tokens });\n    return tokens[tokenIndex];\n  }\n\n  /**\n   * This is a function that updates the tokens name for the tokens name if it is not defined.\n   *\n   * @param tokenList - Represents the fetched token list from service API\n   * @param tokenAttribute - Represents the token attribute that we want to update on the token list\n   */\n  private updateTokensAttribute(\n    tokenList: TokenListMap,\n    tokenAttribute: keyof Token & keyof TokenListToken,\n  ) {\n    const { tokens } = this.state;\n\n    const newTokens = tokens.map((token) => {\n      const newToken = tokenList[token.address.toLowerCase()];\n\n      return !token[tokenAttribute] && newToken?.[tokenAttribute]\n        ? { ...token, [tokenAttribute]: newToken[tokenAttribute] }\n        : { ...token };\n    });\n\n    this.update({ tokens: newTokens });\n  }\n\n  /**\n   * Detects whether or not a token is ERC-721 compatible.\n   *\n   * @param tokenAddress - The token contract address.\n   * @param networkClientId - Optional network client ID to fetch contract info with.\n   * @returns A boolean indicating whether the token address passed in supports the EIP-721\n   * interface.\n   */\n  async _detectIsERC721(\n    tokenAddress: string,\n    networkClientId?: NetworkClientId,\n  ) {\n    const checksumAddress = toChecksumHexAddress(tokenAddress);\n    // if this token is already in our contract metadata map we don't need\n    // to check against the contract\n    if (contractsMap[checksumAddress]?.erc721 === true) {\n      return Promise.resolve(true);\n    } else if (contractsMap[checksumAddress]?.erc20 === true) {\n      return Promise.resolve(false);\n    }\n\n    const tokenContract = this._createEthersContract(\n      tokenAddress,\n      abiERC721,\n      networkClientId,\n    );\n    try {\n      return await tokenContract.supportsInterface(ERC721_INTERFACE_ID);\n    } catch (error) {\n      // currently we see a variety of errors across different networks when\n      // token contracts are not ERC721 compatible. We need to figure out a better\n      // way of differentiating token interface types but for now if we get an error\n      // we have to assume the token is not ERC721 compatible.\n      return false;\n    }\n  }\n\n  _getProvider(networkClientId?: NetworkClientId): Web3Provider {\n    return new Web3Provider(\n      // @ts-expect-error TODO: remove this annotation once the `Eip1193Provider` class is released\n      networkClientId\n        ? this.messagingSystem.call(\n            'NetworkController:getNetworkClientById',\n            networkClientId,\n          ).provider\n        : this.config.provider,\n    );\n  }\n\n  _createEthersContract(\n    tokenAddress: string,\n    abi: string,\n    networkClientId?: NetworkClientId,\n  ): Contract {\n    const web3provider = this._getProvider(networkClientId);\n    const tokenContract = new Contract(tokenAddress, abi, web3provider);\n    return tokenContract;\n  }\n\n  _generateRandomId(): string {\n    return random();\n  }\n\n  /**\n   * Adds a new suggestedAsset to the list of watched assets.\n   * Parameters will be validated according to the asset type being watched.\n   *\n   * @param options - The method options.\n   * @param options.asset - The asset to be watched. For now only ERC20 tokens are accepted.\n   * @param options.type - The asset type.\n   * @param options.interactingAddress - The address of the account that is requesting to watch the asset.\n   * @param options.networkClientId - Network Client ID.\n   * @returns A promise that resolves if the asset was watched successfully, and rejects otherwise.\n   */\n  async watchAsset({\n    asset,\n    type,\n    interactingAddress,\n    networkClientId,\n  }: {\n    asset: Token;\n    type: string;\n    interactingAddress?: string;\n    networkClientId?: NetworkClientId;\n  }): Promise<void> {\n    if (type !== ERC20) {\n      throw new Error(`Asset of type ${type} not supported`);\n    }\n\n    if (!asset.address) {\n      throw rpcErrors.invalidParams('Address must be specified');\n    }\n\n    if (!isValidHexAddress(asset.address)) {\n      throw rpcErrors.invalidParams(`Invalid address \"${asset.address}\"`);\n    }\n\n    // Validate contract\n\n    if (await this._detectIsERC721(asset.address, networkClientId)) {\n      throw rpcErrors.invalidParams(\n        `Contract ${asset.address} must match type ${type}, but was detected as ${ERC721}`,\n      );\n    }\n\n    const provider = this._getProvider(networkClientId);\n    const isErc1155 = await safelyExecute(() =>\n      new ERC1155Standard(provider).contractSupportsBase1155Interface(\n        asset.address,\n      ),\n    );\n    if (isErc1155) {\n      throw rpcErrors.invalidParams(\n        `Contract ${asset.address} must match type ${type}, but was detected as ${ERC1155}`,\n      );\n    }\n\n    const erc20 = new ERC20Standard(provider);\n    const [contractName, contractSymbol, contractDecimals] = await Promise.all([\n      safelyExecute(() => erc20.getTokenName(asset.address)),\n      safelyExecute(() => erc20.getTokenSymbol(asset.address)),\n      safelyExecute(async () => erc20.getTokenDecimals(asset.address)),\n    ]);\n\n    asset.name = contractName;\n\n    // Validate symbol\n\n    if (!asset.symbol && !contractSymbol) {\n      throw rpcErrors.invalidParams(\n        'A symbol is required, but was not found in either the request or contract',\n      );\n    }\n\n    if (\n      contractSymbol !== undefined &&\n      asset.symbol !== undefined &&\n      asset.symbol.toUpperCase() !== contractSymbol.toUpperCase()\n    ) {\n      throw rpcErrors.invalidParams(\n        `The symbol in the request (${asset.symbol}) does not match the symbol in the contract (${contractSymbol})`,\n      );\n    }\n\n    asset.symbol = contractSymbol ?? asset.symbol;\n    if (typeof asset.symbol !== 'string') {\n      throw rpcErrors.invalidParams(`Invalid symbol: not a string`);\n    }\n\n    if (asset.symbol.length > 11) {\n      throw rpcErrors.invalidParams(\n        `Invalid symbol \"${asset.symbol}\": longer than 11 characters`,\n      );\n    }\n\n    // Validate decimals\n\n    if (asset.decimals === undefined && contractDecimals === undefined) {\n      throw rpcErrors.invalidParams(\n        'Decimals are required, but were not found in either the request or contract',\n      );\n    }\n\n    if (\n      contractDecimals !== undefined &&\n      asset.decimals !== undefined &&\n      String(asset.decimals) !== contractDecimals\n    ) {\n      throw rpcErrors.invalidParams(\n        `The decimals in the request (${asset.decimals}) do not match the decimals in the contract (${contractDecimals})`,\n      );\n    }\n\n    const decimalsStr = contractDecimals ?? asset.decimals;\n    const decimalsNum = parseInt(decimalsStr as unknown as string, 10);\n    if (!Number.isInteger(decimalsNum) || decimalsNum > 36 || decimalsNum < 0) {\n      throw rpcErrors.invalidParams(\n        `Invalid decimals \"${decimalsStr}\": must be an integer 0 <= 36`,\n      );\n    }\n    asset.decimals = decimalsNum;\n\n    const suggestedAssetMeta: SuggestedAssetMeta = {\n      asset,\n      id: this._generateRandomId(),\n      time: Date.now(),\n      type,\n      interactingAddress: interactingAddress || this.config.selectedAddress,\n    };\n\n    await this._requestApproval(suggestedAssetMeta);\n\n    const { address, symbol, decimals, name, image } = asset;\n    await this.addToken({\n      address,\n      symbol,\n      decimals,\n      name,\n      image,\n      interactingAddress: suggestedAssetMeta.interactingAddress,\n      networkClientId,\n    });\n  }\n\n  /**\n   * Takes a new tokens and ignoredTokens array for the current network/account combination\n   * and returns new allTokens and allIgnoredTokens state to update to.\n   *\n   * @param params - Object that holds token params.\n   * @param params.newTokens - The new tokens to set for the current network and selected account.\n   * @param params.newIgnoredTokens - The new ignored tokens to set for the current network and selected account.\n   * @param params.newDetectedTokens - The new detected tokens to set for the current network and selected account.\n   * @param params.interactingAddress - The account address to use to store the tokens.\n   * @param params.interactingChainId - The chainId to use to store the tokens.\n   * @returns The updated `allTokens` and `allIgnoredTokens` state.\n   */\n  _getNewAllTokensState(params: {\n    newTokens?: Token[];\n    newIgnoredTokens?: string[];\n    newDetectedTokens?: Token[];\n    interactingAddress?: string;\n    interactingChainId?: Hex;\n  }) {\n    const {\n      newTokens,\n      newIgnoredTokens,\n      newDetectedTokens,\n      interactingAddress,\n      interactingChainId,\n    } = params;\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    const { chainId, selectedAddress } = this.config;\n\n    const userAddressToAddTokens = interactingAddress ?? selectedAddress;\n    const chainIdToAddTokens = interactingChainId ?? chainId;\n\n    let newAllTokens = allTokens;\n    if (\n      newTokens?.length ||\n      (newTokens &&\n        allTokens &&\n        allTokens[chainIdToAddTokens] &&\n        allTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkTokens = allTokens[chainIdToAddTokens];\n      const newNetworkTokens = {\n        ...networkTokens,\n        ...{ [userAddressToAddTokens]: newTokens },\n      };\n      newAllTokens = {\n        ...allTokens,\n        ...{ [chainIdToAddTokens]: newNetworkTokens },\n      };\n    }\n\n    let newAllIgnoredTokens = allIgnoredTokens;\n    if (\n      newIgnoredTokens?.length ||\n      (newIgnoredTokens &&\n        allIgnoredTokens &&\n        allIgnoredTokens[chainIdToAddTokens] &&\n        allIgnoredTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkIgnoredTokens = allIgnoredTokens[chainIdToAddTokens];\n      const newIgnoredNetworkTokens = {\n        ...networkIgnoredTokens,\n        ...{ [userAddressToAddTokens]: newIgnoredTokens },\n      };\n      newAllIgnoredTokens = {\n        ...allIgnoredTokens,\n        ...{ [chainIdToAddTokens]: newIgnoredNetworkTokens },\n      };\n    }\n\n    let newAllDetectedTokens = allDetectedTokens;\n    if (\n      newDetectedTokens?.length ||\n      (newDetectedTokens &&\n        allDetectedTokens &&\n        allDetectedTokens[chainIdToAddTokens] &&\n        allDetectedTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkDetectedTokens = allDetectedTokens[chainIdToAddTokens];\n      const newDetectedNetworkTokens = {\n        ...networkDetectedTokens,\n        ...{ [userAddressToAddTokens]: newDetectedTokens },\n      };\n      newAllDetectedTokens = {\n        ...allDetectedTokens,\n        ...{ [chainIdToAddTokens]: newDetectedNetworkTokens },\n      };\n    }\n    return { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens };\n  }\n\n  /**\n   * Removes all tokens from the ignored list.\n   */\n  clearIgnoredTokens() {\n    this.update({ ignoredTokens: [], allIgnoredTokens: {} });\n  }\n\n  async _requestApproval(suggestedAssetMeta: SuggestedAssetMeta) {\n    return this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        id: suggestedAssetMeta.id,\n        origin: ORIGIN_METAMASK,\n        type: ApprovalType.WatchAsset,\n        requestData: {\n          id: suggestedAssetMeta.id,\n          interactingAddress: suggestedAssetMeta.interactingAddress,\n          asset: {\n            address: suggestedAssetMeta.asset.address,\n            decimals: suggestedAssetMeta.asset.decimals,\n            symbol: suggestedAssetMeta.asset.symbol,\n            image: suggestedAssetMeta.asset.image || null,\n          },\n        },\n      },\n      true,\n    );\n  }\n}\n\nexport default TokensController;\n"]}
\ No newline at end of file
diff --git a/dist/chunk-TPJ5KVPF.js b/dist/chunk-TPJ5KVPF.js
new file mode 100644
index 0000000000000000000000000000000000000000..aabd35cf730d54ddd278093f5aa6d7d035adfc2e
--- /dev/null
+++ b/dist/chunk-TPJ5KVPF.js
@@ -0,0 +1,379 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+
+
+var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
+
+// src/token-prices-service/codefi-v2.ts
+var _controllerutils = require('@metamask/controller-utils');
+var _utils = require('@metamask/utils');
+
+
+
+
+
+
+
+
+var _cockatiel = require('cockatiel');
+var SUPPORTED_CURRENCIES = [
+  // Bitcoin
+  "btc",
+  // Ether
+  "eth",
+  // Litecoin
+  "ltc",
+  // Bitcoin Cash
+  "bch",
+  // Binance Coin
+  "bnb",
+  // EOS
+  "eos",
+  // XRP
+  "xrp",
+  // Lumens
+  "xlm",
+  // Chainlink
+  "link",
+  // Polkadot
+  "dot",
+  // Yearn.finance
+  "yfi",
+  // US Dollar
+  "usd",
+  // United Arab Emirates Dirham
+  "aed",
+  // Argentine Peso
+  "ars",
+  // Australian Dollar
+  "aud",
+  // Bangladeshi Taka
+  "bdt",
+  // Bahraini Dinar
+  "bhd",
+  // Bermudian Dollar
+  "bmd",
+  // Brazil Real
+  "brl",
+  // Canadian Dollar
+  "cad",
+  // Swiss Franc
+  "chf",
+  // Chilean Peso
+  "clp",
+  // Chinese Yuan
+  "cny",
+  // Czech Koruna
+  "czk",
+  // Danish Krone
+  "dkk",
+  // Euro
+  "eur",
+  // British Pound Sterling
+  "gbp",
+  // Hong Kong Dollar
+  "hkd",
+  // Hungarian Forint
+  "huf",
+  // Indonesian Rupiah
+  "idr",
+  // Israeli New Shekel
+  "ils",
+  // Indian Rupee
+  "inr",
+  // Japanese Yen
+  "jpy",
+  // South Korean Won
+  "krw",
+  // Kuwaiti Dinar
+  "kwd",
+  // Sri Lankan Rupee
+  "lkr",
+  // Burmese Kyat
+  "mmk",
+  // Mexican Peso
+  "mxn",
+  // Malaysian Ringgit
+  "myr",
+  // Nigerian Naira
+  "ngn",
+  // Norwegian Krone
+  "nok",
+  // New Zealand Dollar
+  "nzd",
+  // Philippine Peso
+  "php",
+  // Pakistani Rupee
+  "pkr",
+  // Polish Zloty
+  "pln",
+  // Russian Ruble
+  "rub",
+  // Saudi Riyal
+  "sar",
+  // Swedish Krona
+  "sek",
+  // Singapore Dollar
+  "sgd",
+  // Thai Baht
+  "thb",
+  // Turkish Lira
+  "try",
+  // New Taiwan Dollar
+  "twd",
+  // Ukrainian hryvnia
+  "uah",
+  // Venezuelan bolívar fuerte
+  "vef",
+  // Vietnamese đồng
+  "vnd",
+  // South African Rand
+  "zar",
+  // IMF Special Drawing Rights
+  "xdr",
+  // Silver - Troy Ounce
+  "xag",
+  // Gold - Troy Ounce
+  "xau",
+  // Bits
+  "bits",
+  // Satoshi
+  "sats"
+];
+var SUPPORTED_CHAIN_IDS = [
+  // Ethereum Mainnet
+  "0x1",
+  // OP Mainnet
+  "0xa",
+  // Cronos Mainnet
+  "0x19",
+  // BNB Smart Chain Mainnet
+  "0x38",
+  // Syscoin Mainnet
+  "0x39",
+  // OKXChain Mainnet
+  "0x42",
+  // Hoo Smart Chain
+  "0x46",
+  // Meter Mainnet
+  "0x52",
+  // TomoChain
+  "0x58",
+  // Gnosis
+  "0x64",
+  // Velas EVM Mainnet
+  "0x6a",
+  // Fuse Mainnet
+  "0x7a",
+  // Huobi ECO Chain Mainnet
+  "0x80",
+  // Polygon Mainnet
+  "0x89",
+  // Fantom Opera
+  "0xfa",
+  // Boba Network
+  "0x120",
+  // KCC Mainnet
+  "0x141",
+  // zkSync Era Mainnet
+  "0x144",
+  // Theta Mainnet
+  "0x169",
+  // Metis Andromeda Mainnet
+  "0x440",
+  // Moonbeam
+  "0x504",
+  // Moonriver
+  "0x505",
+  // Base
+  "0x2105",
+  // Shiden
+  "0x150",
+  // Smart Bitcoin Cash
+  "0x2710",
+  // Arbitrum One
+  "0xa4b1",
+  // Celo Mainnet
+  "0xa4ec",
+  // Oasis Emerald
+  "0xa516",
+  // Avalanche C-Chain
+  "0xa86a",
+  // Polis Mainnet
+  "0x518af",
+  // Aurora Mainnet
+  "0x4e454152",
+  // Harmony Mainnet Shard 0
+  "0x63564c40",
+  // Linea Mainnet
+  "0xe708"
+];
+var BASE_URL = "https://price-api.metafi.codefi.network/v2";
+var DEFAULT_TOKEN_PRICE_RETRIES = 3;
+var DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES = (1 + DEFAULT_TOKEN_PRICE_RETRIES) * 3;
+var DEFAULT_DEGRADED_THRESHOLD = 5e3;
+var _tokenPricePolicy;
+var CodefiTokenPricesServiceV2 = class {
+  /**
+   * Construct a Codefi Token Price Service.
+   *
+   * @param options - Constructor options
+   * @param options.degradedThreshold - The threshold between "normal" and "degrated" service,
+   * in milliseconds.
+   * @param options.retries - Number of retry attempts for each token price update.
+   * @param options.maximumConsecutiveFailures - The maximum number of consecutive failures
+   * allowed before breaking the circuit and pausing further updates.
+   * @param options.onBreak - An event handler for when the circuit breaks, useful for capturing
+   * metrics about network failures.
+   * @param options.onDegraded - An event handler for when the circuit remains closed, but requests
+   * are failing or resolving too slowly (i.e. resolving more slowly than the `degradedThreshold).
+   * @param options.circuitBreakDuration - The amount of time to wait when the circuit breaks
+   * from too many consecutive failures.
+   */
+  constructor({
+    degradedThreshold = DEFAULT_DEGRADED_THRESHOLD,
+    retries = DEFAULT_TOKEN_PRICE_RETRIES,
+    maximumConsecutiveFailures = DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES,
+    onBreak,
+    onDegraded,
+    circuitBreakDuration = 30 * 60 * 1e3
+  } = {}) {
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _tokenPricePolicy, void 0);
+    const retryPolicy = _cockatiel.retry.call(void 0, _cockatiel.handleAll, {
+      maxAttempts: retries,
+      backoff: new (0, _cockatiel.ExponentialBackoff)()
+    });
+    const circuitBreakerPolicy = _cockatiel.circuitBreaker.call(void 0, _cockatiel.handleAll, {
+      halfOpenAfter: circuitBreakDuration,
+      breaker: new (0, _cockatiel.ConsecutiveBreaker)(maximumConsecutiveFailures)
+    });
+    if (onBreak) {
+      circuitBreakerPolicy.onBreak(onBreak);
+    }
+    if (onDegraded) {
+      retryPolicy.onGiveUp(() => {
+        if (circuitBreakerPolicy.state === _cockatiel.CircuitState.Closed) {
+          onDegraded();
+        }
+      });
+      retryPolicy.onSuccess(({ duration }) => {
+        if (circuitBreakerPolicy.state === _cockatiel.CircuitState.Closed && duration > degradedThreshold) {
+          onDegraded();
+        }
+      });
+    }
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _tokenPricePolicy, _cockatiel.wrap.call(void 0, retryPolicy, circuitBreakerPolicy));
+  }
+  /**
+   * Retrieves prices in the given currency for the tokens identified by the
+   * given addresses which are expected to live on the given chain.
+   *
+   * @param args - The arguments to function.
+   * @param args.chainId - An EIP-155 chain ID.
+   * @param args.tokenAddresses - Addresses for tokens that live on the chain.
+   * @param args.currency - The desired currency of the token prices.
+   * @returns The prices for the requested tokens.
+   */
+  async fetchTokenPrices({
+    chainId,
+    tokenAddresses,
+    currency
+  }) {
+    const chainIdAsNumber = _utils.hexToNumber.call(void 0, chainId);
+    const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
+    const url = new URL(`${BASE_URL}/chains/${chainIdAsNumber}/spot-prices`);
+    url.searchParams.append(
+      "tokenAddresses",
+      [ZERO_ADDRESS, ...tokenAddresses].join(",")
+    );
+    url.searchParams.append("vsCurrency", currency);
+    url.searchParams.append("includeMarketData", "true");
+    const pricesByCurrencyByTokenAddress = await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _tokenPricePolicy).execute(
+      () => _controllerutils.handleFetch.call(void 0, url, { headers: { "Cache-Control": "no-cache" } })
+    );
+    return [ZERO_ADDRESS, ...tokenAddresses].reduce(
+      (obj, tokenAddress) => {
+        const lowercasedTokenAddress = tokenAddress.toLowerCase();
+        const tokenData = pricesByCurrencyByTokenAddress[lowercasedTokenAddress] || {};
+        const {
+          price,
+          pricePercentChange1d,
+          priceChange1d,
+          allTimeHigh,
+          allTimeLow,
+          circulatingSupply,
+          dilutedMarketCap,
+          high1d,
+          marketCap,
+          totalVolume,
+          low1d,
+          marketCapPercentChange1d,
+          pricePercentChange1h,
+          pricePercentChange7d,
+          pricePercentChange14d,
+          pricePercentChange30d,
+          pricePercentChange200d,
+          pricePercentChange1y
+        } = tokenData;
+        const tokenPrice = {
+          tokenAddress,
+          value: price,
+          currency,
+          pricePercentChange1d,
+          priceChange1d,
+          allTimeHigh,
+          allTimeLow,
+          circulatingSupply,
+          dilutedMarketCap,
+          high1d,
+          marketCap,
+          totalVolume,
+          low1d,
+          marketCapPercentChange1d,
+          pricePercentChange1h,
+          pricePercentChange7d,
+          pricePercentChange14d,
+          pricePercentChange30d,
+          pricePercentChange200d,
+          pricePercentChange1y
+        };
+        return {
+          ...obj,
+          ...tokenPrice.value !== void 0 ? { [tokenAddress]: tokenPrice } : {}
+        };
+      },
+      {}
+    );
+  }
+  /**
+   * Type guard for whether the API can return token prices for the given chain
+   * ID.
+   *
+   * @param chainId - The chain ID to check.
+   * @returns True if the API supports the chain ID, false otherwise.
+   */
+  validateChainIdSupported(chainId) {
+    const supportedChainIds = SUPPORTED_CHAIN_IDS;
+    return typeof chainId === "string" && supportedChainIds.includes(chainId);
+  }
+  /**
+   * Type guard for whether the API can return token prices in the given
+   * currency.
+   *
+   * @param currency - The currency to check. If a string, can be either
+   * lowercase or uppercase.
+   * @returns True if the API supports the currency, false otherwise.
+   */
+  validateCurrencySupported(currency) {
+    const supportedCurrencies = SUPPORTED_CURRENCIES;
+    return typeof currency === "string" && supportedCurrencies.includes(currency.toLowerCase());
+  }
+};
+_tokenPricePolicy = new WeakMap();
+
+
+
+
+
+exports.SUPPORTED_CURRENCIES = SUPPORTED_CURRENCIES; exports.SUPPORTED_CHAIN_IDS = SUPPORTED_CHAIN_IDS; exports.CodefiTokenPricesServiceV2 = CodefiTokenPricesServiceV2;
+//# sourceMappingURL=chunk-TPJ5KVPF.js.map
\ No newline at end of file
diff --git a/dist/chunk-TPJ5KVPF.js.map b/dist/chunk-TPJ5KVPF.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..bc5e108a97eb07b0d9df37c009fcfbfbcd289242
--- /dev/null
+++ b/dist/chunk-TPJ5KVPF.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/token-prices-service/codefi-v2.ts"],"names":[],"mappings":"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","sourcesContent":["import { handleFetch } from '@metamask/controller-utils';\nimport type { Hex } from '@metamask/utils';\nimport { hexToNumber } from '@metamask/utils';\nimport {\n  circuitBreaker,\n  ConsecutiveBreaker,\n  ExponentialBackoff,\n  handleAll,\n  type IPolicy,\n  retry,\n  wrap,\n  CircuitState,\n} from 'cockatiel';\n\nimport type {\n  AbstractTokenPricesService,\n  TokenPrice,\n  TokenPricesByTokenAddress,\n} from './abstract-token-prices-service';\n\n/**\n * The list of currencies that can be supplied as the `vsCurrency` parameter to\n * the `/spot-prices` endpoint, in lowercase form.\n */\nexport const SUPPORTED_CURRENCIES = [\n  // Bitcoin\n  'btc',\n  // Ether\n  'eth',\n  // Litecoin\n  'ltc',\n  // Bitcoin Cash\n  'bch',\n  // Binance Coin\n  'bnb',\n  // EOS\n  'eos',\n  // XRP\n  'xrp',\n  // Lumens\n  'xlm',\n  // Chainlink\n  'link',\n  // Polkadot\n  'dot',\n  // Yearn.finance\n  'yfi',\n  // US Dollar\n  'usd',\n  // United Arab Emirates Dirham\n  'aed',\n  // Argentine Peso\n  'ars',\n  // Australian Dollar\n  'aud',\n  // Bangladeshi Taka\n  'bdt',\n  // Bahraini Dinar\n  'bhd',\n  // Bermudian Dollar\n  'bmd',\n  // Brazil Real\n  'brl',\n  // Canadian Dollar\n  'cad',\n  // Swiss Franc\n  'chf',\n  // Chilean Peso\n  'clp',\n  // Chinese Yuan\n  'cny',\n  // Czech Koruna\n  'czk',\n  // Danish Krone\n  'dkk',\n  // Euro\n  'eur',\n  // British Pound Sterling\n  'gbp',\n  // Hong Kong Dollar\n  'hkd',\n  // Hungarian Forint\n  'huf',\n  // Indonesian Rupiah\n  'idr',\n  // Israeli New Shekel\n  'ils',\n  // Indian Rupee\n  'inr',\n  // Japanese Yen\n  'jpy',\n  // South Korean Won\n  'krw',\n  // Kuwaiti Dinar\n  'kwd',\n  // Sri Lankan Rupee\n  'lkr',\n  // Burmese Kyat\n  'mmk',\n  // Mexican Peso\n  'mxn',\n  // Malaysian Ringgit\n  'myr',\n  // Nigerian Naira\n  'ngn',\n  // Norwegian Krone\n  'nok',\n  // New Zealand Dollar\n  'nzd',\n  // Philippine Peso\n  'php',\n  // Pakistani Rupee\n  'pkr',\n  // Polish Zloty\n  'pln',\n  // Russian Ruble\n  'rub',\n  // Saudi Riyal\n  'sar',\n  // Swedish Krona\n  'sek',\n  // Singapore Dollar\n  'sgd',\n  // Thai Baht\n  'thb',\n  // Turkish Lira\n  'try',\n  // New Taiwan Dollar\n  'twd',\n  // Ukrainian hryvnia\n  'uah',\n  // Venezuelan bolívar fuerte\n  'vef',\n  // Vietnamese đồng\n  'vnd',\n  // South African Rand\n  'zar',\n  // IMF Special Drawing Rights\n  'xdr',\n  // Silver - Troy Ounce\n  'xag',\n  // Gold - Troy Ounce\n  'xau',\n  // Bits\n  'bits',\n  // Satoshi\n  'sats',\n] as const;\n\n/**\n * A currency that can be supplied as the `vsCurrency` parameter to\n * the `/spot-prices` endpoint. Covers both uppercase and lowercase versions.\n */\ntype SupportedCurrency =\n  | (typeof SUPPORTED_CURRENCIES)[number]\n  | Uppercase<(typeof SUPPORTED_CURRENCIES)[number]>;\n\n/**\n * The list of chain IDs that can be supplied in the URL for the `/spot-prices`\n * endpoint, but in hexadecimal form (for consistency with how we represent\n * chain IDs in other places).\n * @see Used by {@link CodefiTokenPricesServiceV2} to validate that a given chain ID is supported by V2 of the Codefi Price API.\n */\nexport const SUPPORTED_CHAIN_IDS = [\n  // Ethereum Mainnet\n  '0x1',\n  // OP Mainnet\n  '0xa',\n  // Cronos Mainnet\n  '0x19',\n  // BNB Smart Chain Mainnet\n  '0x38',\n  // Syscoin Mainnet\n  '0x39',\n  // OKXChain Mainnet\n  '0x42',\n  // Hoo Smart Chain\n  '0x46',\n  // Meter Mainnet\n  '0x52',\n  // TomoChain\n  '0x58',\n  // Gnosis\n  '0x64',\n  // Velas EVM Mainnet\n  '0x6a',\n  // Fuse Mainnet\n  '0x7a',\n  // Huobi ECO Chain Mainnet\n  '0x80',\n  // Polygon Mainnet\n  '0x89',\n  // Fantom Opera\n  '0xfa',\n  // Boba Network\n  '0x120',\n  // KCC Mainnet\n  '0x141',\n  // zkSync Era Mainnet\n  '0x144',\n  // Theta Mainnet\n  '0x169',\n  // Metis Andromeda Mainnet\n  '0x440',\n  // Moonbeam\n  '0x504',\n  // Moonriver\n  '0x505',\n  // Base\n  '0x2105',\n  // Shiden\n  '0x150',\n  // Smart Bitcoin Cash\n  '0x2710',\n  // Arbitrum One\n  '0xa4b1',\n  // Celo Mainnet\n  '0xa4ec',\n  // Oasis Emerald\n  '0xa516',\n  // Avalanche C-Chain\n  '0xa86a',\n  // Polis Mainnet\n  '0x518af',\n  // Aurora Mainnet\n  '0x4e454152',\n  // Harmony Mainnet Shard 0\n  '0x63564c40',\n  // Linea Mainnet\n  '0xe708',\n] as const;\n\n/**\n * A chain ID that can be supplied in the URL for the `/spot-prices` endpoint,\n * but in hexadecimal form (for consistency with how we represent chain IDs in\n * other places).\n */\ntype SupportedChainId = (typeof SUPPORTED_CHAIN_IDS)[number];\n\n/**\n * All requests to V2 of the Price API start with this.\n */\nconst BASE_URL = 'https://price-api.metafi.codefi.network/v2';\n\nconst DEFAULT_TOKEN_PRICE_RETRIES = 3;\n// Each update attempt will result (1 + retries) calls if the server is down\nconst DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES =\n  (1 + DEFAULT_TOKEN_PRICE_RETRIES) * 3;\n\nconst DEFAULT_DEGRADED_THRESHOLD = 5_000;\n\ntype CryptoData = {\n  allTimeHigh: number;\n  allTimeLow: number;\n  circulatingSupply: number;\n  dilutedMarketCap: number;\n  high1d: number;\n  low1d: number;\n  marketCap: number;\n  marketCapPercentChange1d: number;\n  price: number;\n  priceChange1d: number;\n  pricePercentChange1d: number;\n  pricePercentChange1h: number;\n  pricePercentChange1y: number;\n  pricePercentChange7d: number;\n  pricePercentChange14d: number;\n  pricePercentChange30d: number;\n  pricePercentChange200d: number;\n  totalVolume: number;\n};\n\ntype AddressCryptoDataMap = { [address: Hex]: CryptoData };\n\n/**\n * This version of the token prices service uses V2 of the Codefi Price API to\n * fetch token prices.\n */\nexport class CodefiTokenPricesServiceV2\n  implements\n    AbstractTokenPricesService<SupportedChainId, Hex, SupportedCurrency>\n{\n  #tokenPricePolicy: IPolicy;\n\n  /**\n   * Construct a Codefi Token Price Service.\n   *\n   * @param options - Constructor options\n   * @param options.degradedThreshold - The threshold between \"normal\" and \"degrated\" service,\n   * in milliseconds.\n   * @param options.retries - Number of retry attempts for each token price update.\n   * @param options.maximumConsecutiveFailures - The maximum number of consecutive failures\n   * allowed before breaking the circuit and pausing further updates.\n   * @param options.onBreak - An event handler for when the circuit breaks, useful for capturing\n   * metrics about network failures.\n   * @param options.onDegraded - An event handler for when the circuit remains closed, but requests\n   * are failing or resolving too slowly (i.e. resolving more slowly than the `degradedThreshold).\n   * @param options.circuitBreakDuration - The amount of time to wait when the circuit breaks\n   * from too many consecutive failures.\n   */\n  constructor({\n    degradedThreshold = DEFAULT_DEGRADED_THRESHOLD,\n    retries = DEFAULT_TOKEN_PRICE_RETRIES,\n    maximumConsecutiveFailures = DEFAULT_TOKEN_PRICE_MAX_CONSECUTIVE_FAILURES,\n    onBreak,\n    onDegraded,\n    circuitBreakDuration = 30 * 60 * 1000,\n  }: {\n    degradedThreshold?: number;\n    retries?: number;\n    maximumConsecutiveFailures?: number;\n    onBreak?: () => void;\n    onDegraded?: () => void;\n    circuitBreakDuration?: number;\n  } = {}) {\n    // Construct a policy that will retry each update, and halt further updates\n    // for a certain period after too many consecutive failures.\n    const retryPolicy = retry(handleAll, {\n      maxAttempts: retries,\n      backoff: new ExponentialBackoff(),\n    });\n    const circuitBreakerPolicy = circuitBreaker(handleAll, {\n      halfOpenAfter: circuitBreakDuration,\n      breaker: new ConsecutiveBreaker(maximumConsecutiveFailures),\n    });\n    if (onBreak) {\n      circuitBreakerPolicy.onBreak(onBreak);\n    }\n    if (onDegraded) {\n      retryPolicy.onGiveUp(() => {\n        if (circuitBreakerPolicy.state === CircuitState.Closed) {\n          onDegraded();\n        }\n      });\n      retryPolicy.onSuccess(({ duration }) => {\n        if (\n          circuitBreakerPolicy.state === CircuitState.Closed &&\n          duration > degradedThreshold\n        ) {\n          onDegraded();\n        }\n      });\n    }\n    this.#tokenPricePolicy = wrap(retryPolicy, circuitBreakerPolicy);\n  }\n\n  /**\n   * Retrieves prices in the given currency for the tokens identified by the\n   * given addresses which are expected to live on the given chain.\n   *\n   * @param args - The arguments to function.\n   * @param args.chainId - An EIP-155 chain ID.\n   * @param args.tokenAddresses - Addresses for tokens that live on the chain.\n   * @param args.currency - The desired currency of the token prices.\n   * @returns The prices for the requested tokens.\n   */\n  async fetchTokenPrices({\n    chainId,\n    tokenAddresses,\n    currency,\n  }: {\n    chainId: SupportedChainId;\n    tokenAddresses: Hex[];\n    currency: SupportedCurrency;\n  }): Promise<Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>> {\n    const chainIdAsNumber = hexToNumber(chainId);\n    const ZERO_ADDRESS: `0x${string}` =\n      '0x0000000000000000000000000000000000000000';\n\n    const url = new URL(`${BASE_URL}/chains/${chainIdAsNumber}/spot-prices`);\n    url.searchParams.append(\n      'tokenAddresses',\n      [ZERO_ADDRESS, ...tokenAddresses].join(','),\n    );\n    url.searchParams.append('vsCurrency', currency);\n    url.searchParams.append('includeMarketData', 'true');\n\n    const pricesByCurrencyByTokenAddress: AddressCryptoDataMap =\n      await this.#tokenPricePolicy.execute(() =>\n        handleFetch(url, { headers: { 'Cache-Control': 'no-cache' } }),\n      );\n\n    return [ZERO_ADDRESS, ...tokenAddresses].reduce(\n      (\n        obj: Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>,\n        tokenAddress,\n      ) => {\n        // The Price API lowercases both currency and token addresses, so we have\n        // to keep track of them and make sure we return the original versions.\n        const lowercasedTokenAddress =\n          tokenAddress.toLowerCase() as Lowercase<Hex>;\n\n        const tokenData =\n          pricesByCurrencyByTokenAddress[lowercasedTokenAddress] || {};\n\n        const {\n          price,\n          pricePercentChange1d,\n          priceChange1d,\n          allTimeHigh,\n          allTimeLow,\n          circulatingSupply,\n          dilutedMarketCap,\n          high1d,\n          marketCap,\n          totalVolume,\n          low1d,\n          marketCapPercentChange1d,\n          pricePercentChange1h,\n          pricePercentChange7d,\n          pricePercentChange14d,\n          pricePercentChange30d,\n          pricePercentChange200d,\n          pricePercentChange1y,\n        } = tokenData;\n\n        const tokenPrice: TokenPrice<Hex, SupportedCurrency> = {\n          tokenAddress,\n          value: price,\n          currency,\n          pricePercentChange1d,\n          priceChange1d,\n          allTimeHigh,\n          allTimeLow,\n          circulatingSupply,\n          dilutedMarketCap,\n          high1d,\n          marketCap,\n          totalVolume,\n          low1d,\n          marketCapPercentChange1d,\n          pricePercentChange1h,\n          pricePercentChange7d,\n          pricePercentChange14d,\n          pricePercentChange30d,\n          pricePercentChange200d,\n          pricePercentChange1y,\n        };\n\n        return {\n          ...obj,\n          ...(tokenPrice.value !== undefined\n            ? { [tokenAddress]: tokenPrice }\n            : {}),\n        };\n      },\n      {},\n    ) as Partial<TokenPricesByTokenAddress<Hex, SupportedCurrency>>;\n  }\n\n  /**\n   * Type guard for whether the API can return token prices for the given chain\n   * ID.\n   *\n   * @param chainId - The chain ID to check.\n   * @returns True if the API supports the chain ID, false otherwise.\n   */\n  validateChainIdSupported(chainId: unknown): chainId is SupportedChainId {\n    const supportedChainIds: readonly string[] = SUPPORTED_CHAIN_IDS;\n    return typeof chainId === 'string' && supportedChainIds.includes(chainId);\n  }\n\n  /**\n   * Type guard for whether the API can return token prices in the given\n   * currency.\n   *\n   * @param currency - The currency to check. If a string, can be either\n   * lowercase or uppercase.\n   * @returns True if the API supports the currency, false otherwise.\n   */\n  validateCurrencySupported(currency: unknown): currency is SupportedCurrency {\n    const supportedCurrencies: readonly string[] = SUPPORTED_CURRENCIES;\n    return (\n      typeof currency === 'string' &&\n      supportedCurrencies.includes(currency.toLowerCase())\n    );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/chunk-U36OEBF2.js b/dist/chunk-U36OEBF2.js
new file mode 100644
index 0000000000000000000000000000000000000000..6a1b6eee33b075d1936734509eb63138877cee5f
--- /dev/null
+++ b/dist/chunk-U36OEBF2.js
@@ -0,0 +1,284 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunkOKEA7NPVjs = require('./chunk-OKEA7NPV.js');
+
+
+
+
+var _chunkLS6R3HQLjs = require('./chunk-LS6R3HQL.js');
+
+
+
+var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
+
+// src/TokenListController.ts
+var _controllerutils = require('@metamask/controller-utils');
+var _pollingcontroller = require('@metamask/polling-controller');
+var _asyncmutex = require('async-mutex');
+var DEFAULT_INTERVAL = 24 * 60 * 60 * 1e3;
+var DEFAULT_THRESHOLD = 24 * 60 * 60 * 1e3;
+var name = "TokenListController";
+var metadata = {
+  tokenList: { persist: true, anonymous: true },
+  tokensChainsCache: { persist: true, anonymous: true },
+  preventPollingOnNetworkRestart: { persist: true, anonymous: true }
+};
+var getDefaultTokenListState = () => {
+  return {
+    tokenList: {},
+    tokensChainsCache: {},
+    preventPollingOnNetworkRestart: false
+  };
+};
+var _onNetworkControllerStateChange, onNetworkControllerStateChange_fn, _fetchFromCache, fetchFromCache_fn;
+var TokenListController = class extends _pollingcontroller.StaticIntervalPollingController {
+  /**
+   * Creates a TokenListController instance.
+   *
+   * @param options - The controller options.
+   * @param options.chainId - The chain ID of the current network.
+   * @param options.onNetworkStateChange - A function for registering an event handler for network state changes.
+   * @param options.interval - The polling interval, in milliseconds.
+   * @param options.cacheRefreshThreshold - The token cache expiry time, in milliseconds.
+   * @param options.messenger - A restricted controller messenger.
+   * @param options.state - Initial state to set on this controller.
+   * @param options.preventPollingOnNetworkRestart - Determines whether to prevent poilling on network restart in extension.
+   */
+  constructor({
+    chainId,
+    preventPollingOnNetworkRestart = false,
+    onNetworkStateChange,
+    interval = DEFAULT_INTERVAL,
+    cacheRefreshThreshold = DEFAULT_THRESHOLD,
+    messenger,
+    state
+  }) {
+    super({
+      name,
+      metadata,
+      messenger,
+      state: { ...getDefaultTokenListState(), ...state }
+    });
+    /**
+     * Updates state and restarts polling on changes to the network controller
+     * state.
+     *
+     * @param networkControllerState - The updated network controller state.
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _onNetworkControllerStateChange);
+    /**
+     * Checks if the Cache timestamp is valid,
+     * if yes data in cache will be returned
+     * otherwise null will be returned.
+     * @param chainId - The chain ID of the network for which to fetch the cache.
+     * @returns The cached data, or `null` if the cache was expired.
+     */
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _fetchFromCache);
+    this.mutex = new (0, _asyncmutex.Mutex)();
+    this.intervalDelay = interval;
+    this.cacheRefreshThreshold = cacheRefreshThreshold;
+    this.chainId = chainId;
+    this.updatePreventPollingOnNetworkRestart(preventPollingOnNetworkRestart);
+    this.abortController = new AbortController();
+    if (onNetworkStateChange) {
+      onNetworkStateChange(async (networkControllerState) => {
+        await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _onNetworkControllerStateChange, onNetworkControllerStateChange_fn).call(this, networkControllerState);
+      });
+    } else {
+      this.messagingSystem.subscribe(
+        "NetworkController:stateChange",
+        async (networkControllerState) => {
+          await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _onNetworkControllerStateChange, onNetworkControllerStateChange_fn).call(this, networkControllerState);
+        }
+      );
+    }
+  }
+  /**
+   * Start polling for the token list.
+   */
+  async start() {
+    if (!_chunkLS6R3HQLjs.isTokenListSupportedForNetwork.call(void 0, this.chainId)) {
+      return;
+    }
+    await this.startPolling();
+  }
+  /**
+   * Restart polling for the token list.
+   */
+  async restart() {
+    this.stopPolling();
+    await this.startPolling();
+  }
+  /**
+   * Stop polling for the token list.
+   */
+  stop() {
+    this.stopPolling();
+  }
+  /**
+   * Prepare to discard this controller.
+   *
+   * This stops any active polling.
+   */
+  destroy() {
+    super.destroy();
+    this.stopPolling();
+  }
+  stopPolling() {
+    if (this.intervalId) {
+      clearInterval(this.intervalId);
+    }
+  }
+  /**
+   * Starts a new polling interval.
+   */
+  async startPolling() {
+    await _controllerutils.safelyExecute.call(void 0, () => this.fetchTokenList());
+    this.intervalId = setInterval(async () => {
+      await _controllerutils.safelyExecute.call(void 0, () => this.fetchTokenList());
+    }, this.intervalDelay);
+  }
+  /**
+   * Fetching token list from the Token Service API.
+   *
+   * @private
+   * @param networkClientId - The ID of the network client triggering the fetch.
+   * @returns A promise that resolves when this operation completes.
+   */
+  async _executePoll(networkClientId) {
+    return this.fetchTokenList(networkClientId);
+  }
+  /**
+   * Fetching token list from the Token Service API.
+   *
+   * @param networkClientId - The ID of the network client triggering the fetch.
+   */
+  async fetchTokenList(networkClientId) {
+    const releaseLock = await this.mutex.acquire();
+    let networkClient;
+    if (networkClientId) {
+      networkClient = this.messagingSystem.call(
+        "NetworkController:getNetworkClientById",
+        networkClientId
+      );
+    }
+    const chainId = networkClient?.configuration.chainId ?? this.chainId;
+    try {
+      const { tokensChainsCache } = this.state;
+      let tokenList = {};
+      const cachedTokens = await _controllerutils.safelyExecute.call(void 0, 
+        () => _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _fetchFromCache, fetchFromCache_fn).call(this, chainId)
+      );
+      if (cachedTokens) {
+        tokenList = { ...cachedTokens };
+      } else {
+        const tokensFromAPI = await _controllerutils.safelyExecute.call(void 0, 
+          () => _chunkOKEA7NPVjs.fetchTokenListByChainId.call(void 0, 
+            chainId,
+            this.abortController.signal
+          )
+        );
+        if (!tokensFromAPI) {
+          tokenList = { ...tokensChainsCache[chainId]?.data || {} };
+          this.update(() => {
+            return {
+              ...this.state,
+              tokenList,
+              tokensChainsCache
+            };
+          });
+          return;
+        }
+        for (const token of tokensFromAPI) {
+          const formattedToken = {
+            ...token,
+            aggregators: _chunkLS6R3HQLjs.formatAggregatorNames.call(void 0, token.aggregators),
+            iconUrl: _chunkLS6R3HQLjs.formatIconUrlWithProxy.call(void 0, {
+              chainId,
+              tokenAddress: token.address
+            })
+          };
+          tokenList[token.address] = formattedToken;
+        }
+      }
+      const updatedTokensChainsCache = {
+        ...tokensChainsCache,
+        [chainId]: {
+          timestamp: Date.now(),
+          data: tokenList
+        }
+      };
+      this.update(() => {
+        return {
+          ...this.state,
+          tokenList,
+          tokensChainsCache: updatedTokensChainsCache
+        };
+      });
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Clearing tokenList and tokensChainsCache explicitly.
+   */
+  clearingTokenListData() {
+    this.update(() => {
+      return {
+        ...this.state,
+        tokenList: {},
+        tokensChainsCache: {}
+      };
+    });
+  }
+  /**
+   * Updates preventPollingOnNetworkRestart from extension.
+   *
+   * @param shouldPreventPolling - Determine whether to prevent polling on network change
+   */
+  updatePreventPollingOnNetworkRestart(shouldPreventPolling) {
+    this.update(() => {
+      return {
+        ...this.state,
+        preventPollingOnNetworkRestart: shouldPreventPolling
+      };
+    });
+  }
+};
+_onNetworkControllerStateChange = new WeakSet();
+onNetworkControllerStateChange_fn = async function(networkControllerState) {
+  if (this.chainId !== networkControllerState.providerConfig.chainId) {
+    this.abortController.abort();
+    this.abortController = new AbortController();
+    this.chainId = networkControllerState.providerConfig.chainId;
+    if (this.state.preventPollingOnNetworkRestart) {
+      this.clearingTokenListData();
+    } else {
+      this.update(() => {
+        return {
+          ...this.state,
+          tokenList: this.state.tokensChainsCache[this.chainId]?.data || {}
+        };
+      });
+      await this.restart();
+    }
+  }
+};
+_fetchFromCache = new WeakSet();
+fetchFromCache_fn = async function(chainId) {
+  const { tokensChainsCache } = this.state;
+  const dataCache = tokensChainsCache[chainId];
+  const now = Date.now();
+  if (dataCache?.data && now - dataCache?.timestamp < this.cacheRefreshThreshold) {
+    return dataCache.data;
+  }
+  return null;
+};
+var TokenListController_default = TokenListController;
+
+
+
+
+
+exports.getDefaultTokenListState = getDefaultTokenListState; exports.TokenListController = TokenListController; exports.TokenListController_default = TokenListController_default;
+//# sourceMappingURL=chunk-U36OEBF2.js.map
\ No newline at end of file
diff --git a/dist/chunk-U36OEBF2.js.map b/dist/chunk-U36OEBF2.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..3fecf02e65893f4642b548fa908200f9c5d94954
--- /dev/null
+++ b/dist/chunk-U36OEBF2.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/TokenListController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { safelyExecute } from '@metamask/controller-utils';\nimport type {\n  NetworkClientId,\n  NetworkControllerStateChangeEvent,\n  NetworkState,\n  NetworkControllerGetNetworkClientByIdAction,\n} from '@metamask/network-controller';\nimport { StaticIntervalPollingController } from '@metamask/polling-controller';\nimport type { Hex } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\n\nimport {\n  isTokenListSupportedForNetwork,\n  formatAggregatorNames,\n  formatIconUrlWithProxy,\n} from './assetsUtil';\nimport { fetchTokenListByChainId } from './token-service';\n\nconst DEFAULT_INTERVAL = 24 * 60 * 60 * 1000;\nconst DEFAULT_THRESHOLD = 24 * 60 * 60 * 1000;\n\nconst name = 'TokenListController';\n\nexport type TokenListToken = {\n  name: string;\n  symbol: string;\n  decimals: number;\n  address: string;\n  occurrences: number;\n  aggregators: string[];\n  iconUrl: string;\n};\n\nexport type TokenListMap = Record<string, TokenListToken>;\n\ntype DataCache = {\n  timestamp: number;\n  data: TokenListMap;\n};\ntype TokensChainsCache = {\n  [chainId: Hex]: DataCache;\n};\n\nexport type TokenListState = {\n  tokenList: TokenListMap;\n  tokensChainsCache: TokensChainsCache;\n  preventPollingOnNetworkRestart: boolean;\n};\n\nexport type TokenListStateChange = ControllerStateChangeEvent<\n  typeof name,\n  TokenListState\n>;\n\nexport type TokenListControllerEvents = TokenListStateChange;\n\nexport type GetTokenListState = ControllerGetStateAction<\n  typeof name,\n  TokenListState\n>;\n\nexport type TokenListControllerActions = GetTokenListState;\n\ntype AllowedActions = NetworkControllerGetNetworkClientByIdAction;\n\ntype AllowedEvents = NetworkControllerStateChangeEvent;\n\nexport type TokenListControllerMessenger = RestrictedControllerMessenger<\n  typeof name,\n  TokenListControllerActions | AllowedActions,\n  TokenListControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\nconst metadata = {\n  tokenList: { persist: true, anonymous: true },\n  tokensChainsCache: { persist: true, anonymous: true },\n  preventPollingOnNetworkRestart: { persist: true, anonymous: true },\n};\n\nexport const getDefaultTokenListState = (): TokenListState => {\n  return {\n    tokenList: {},\n    tokensChainsCache: {},\n    preventPollingOnNetworkRestart: false,\n  };\n};\n\n/**\n * Controller that passively polls on a set interval for the list of tokens from metaswaps api\n */\nexport class TokenListController extends StaticIntervalPollingController<\n  typeof name,\n  TokenListState,\n  TokenListControllerMessenger\n> {\n  private readonly mutex = new Mutex();\n\n  private intervalId?: ReturnType<typeof setTimeout>;\n\n  private readonly intervalDelay: number;\n\n  private readonly cacheRefreshThreshold: number;\n\n  private chainId: Hex;\n\n  private abortController: AbortController;\n\n  /**\n   * Creates a TokenListController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onNetworkStateChange - A function for registering an event handler for network state changes.\n   * @param options.interval - The polling interval, in milliseconds.\n   * @param options.cacheRefreshThreshold - The token cache expiry time, in milliseconds.\n   * @param options.messenger - A restricted controller messenger.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.preventPollingOnNetworkRestart - Determines whether to prevent poilling on network restart in extension.\n   */\n  constructor({\n    chainId,\n    preventPollingOnNetworkRestart = false,\n    onNetworkStateChange,\n    interval = DEFAULT_INTERVAL,\n    cacheRefreshThreshold = DEFAULT_THRESHOLD,\n    messenger,\n    state,\n  }: {\n    chainId: Hex;\n    preventPollingOnNetworkRestart?: boolean;\n    onNetworkStateChange?: (\n      listener: (networkState: NetworkState) => void,\n    ) => void;\n    interval?: number;\n    cacheRefreshThreshold?: number;\n    messenger: TokenListControllerMessenger;\n    state?: Partial<TokenListState>;\n  }) {\n    super({\n      name,\n      metadata,\n      messenger,\n      state: { ...getDefaultTokenListState(), ...state },\n    });\n    this.intervalDelay = interval;\n    this.cacheRefreshThreshold = cacheRefreshThreshold;\n    this.chainId = chainId;\n    this.updatePreventPollingOnNetworkRestart(preventPollingOnNetworkRestart);\n    this.abortController = new AbortController();\n    if (onNetworkStateChange) {\n      onNetworkStateChange(async (networkControllerState) => {\n        await this.#onNetworkControllerStateChange(networkControllerState);\n      });\n    } else {\n      this.messagingSystem.subscribe(\n        'NetworkController:stateChange',\n        async (networkControllerState) => {\n          await this.#onNetworkControllerStateChange(networkControllerState);\n        },\n      );\n    }\n  }\n\n  /**\n   * Updates state and restarts polling on changes to the network controller\n   * state.\n   *\n   * @param networkControllerState - The updated network controller state.\n   */\n  async #onNetworkControllerStateChange(networkControllerState: NetworkState) {\n    if (this.chainId !== networkControllerState.providerConfig.chainId) {\n      this.abortController.abort();\n      this.abortController = new AbortController();\n      this.chainId = networkControllerState.providerConfig.chainId;\n      if (this.state.preventPollingOnNetworkRestart) {\n        this.clearingTokenListData();\n      } else {\n        // Ensure tokenList is referencing data from correct network\n        this.update(() => {\n          return {\n            ...this.state,\n            tokenList: this.state.tokensChainsCache[this.chainId]?.data || {},\n          };\n        });\n        await this.restart();\n      }\n    }\n  }\n\n  /**\n   * Start polling for the token list.\n   */\n  async start() {\n    if (!isTokenListSupportedForNetwork(this.chainId)) {\n      return;\n    }\n    await this.startPolling();\n  }\n\n  /**\n   * Restart polling for the token list.\n   */\n  async restart() {\n    this.stopPolling();\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for the token list.\n   */\n  stop() {\n    this.stopPolling();\n  }\n\n  /**\n   * Prepare to discard this controller.\n   *\n   * This stops any active polling.\n   */\n  override destroy() {\n    super.destroy();\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   */\n  private async startPolling(): Promise<void> {\n    await safelyExecute(() => this.fetchTokenList());\n    this.intervalId = setInterval(async () => {\n      await safelyExecute(() => this.fetchTokenList());\n    }, this.intervalDelay);\n  }\n\n  /**\n   * Fetching token list from the Token Service API.\n   *\n   * @private\n   * @param networkClientId - The ID of the network client triggering the fetch.\n   * @returns A promise that resolves when this operation completes.\n   */\n  async _executePoll(networkClientId: string): Promise<void> {\n    return this.fetchTokenList(networkClientId);\n  }\n\n  /**\n   * Fetching token list from the Token Service API.\n   *\n   * @param networkClientId - The ID of the network client triggering the fetch.\n   */\n  async fetchTokenList(networkClientId?: NetworkClientId): Promise<void> {\n    const releaseLock = await this.mutex.acquire();\n    let networkClient;\n    if (networkClientId) {\n      networkClient = this.messagingSystem.call(\n        'NetworkController:getNetworkClientById',\n        networkClientId,\n      );\n    }\n    const chainId = networkClient?.configuration.chainId ?? this.chainId;\n    try {\n      const { tokensChainsCache } = this.state;\n      let tokenList: TokenListMap = {};\n      const cachedTokens = await safelyExecute(() =>\n        this.#fetchFromCache(chainId),\n      );\n      if (cachedTokens) {\n        // Use non-expired cached tokens\n        tokenList = { ...cachedTokens };\n      } else {\n        // Fetch fresh token list\n        const tokensFromAPI = await safelyExecute(\n          () =>\n            fetchTokenListByChainId(\n              chainId,\n              this.abortController.signal,\n            ) as Promise<TokenListToken[]>,\n        );\n\n        if (!tokensFromAPI) {\n          // Fallback to expired cached tokens\n          tokenList = { ...(tokensChainsCache[chainId]?.data || {}) };\n          this.update(() => {\n            return {\n              ...this.state,\n              tokenList,\n              tokensChainsCache,\n            };\n          });\n          return;\n        }\n        for (const token of tokensFromAPI) {\n          const formattedToken: TokenListToken = {\n            ...token,\n            aggregators: formatAggregatorNames(token.aggregators),\n            iconUrl: formatIconUrlWithProxy({\n              chainId,\n              tokenAddress: token.address,\n            }),\n          };\n          tokenList[token.address] = formattedToken;\n        }\n      }\n      const updatedTokensChainsCache: TokensChainsCache = {\n        ...tokensChainsCache,\n        [chainId]: {\n          timestamp: Date.now(),\n          data: tokenList,\n        },\n      };\n      this.update(() => {\n        return {\n          ...this.state,\n          tokenList,\n          tokensChainsCache: updatedTokensChainsCache,\n        };\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Checks if the Cache timestamp is valid,\n   * if yes data in cache will be returned\n   * otherwise null will be returned.\n   * @param chainId - The chain ID of the network for which to fetch the cache.\n   * @returns The cached data, or `null` if the cache was expired.\n   */\n  async #fetchFromCache(chainId: Hex): Promise<TokenListMap | null> {\n    const { tokensChainsCache }: TokenListState = this.state;\n    const dataCache = tokensChainsCache[chainId];\n    const now = Date.now();\n    if (\n      dataCache?.data &&\n      now - dataCache?.timestamp < this.cacheRefreshThreshold\n    ) {\n      return dataCache.data;\n    }\n    return null;\n  }\n\n  /**\n   * Clearing tokenList and tokensChainsCache explicitly.\n   */\n  clearingTokenListData(): void {\n    this.update(() => {\n      return {\n        ...this.state,\n        tokenList: {},\n        tokensChainsCache: {},\n      };\n    });\n  }\n\n  /**\n   * Updates preventPollingOnNetworkRestart from extension.\n   *\n   * @param shouldPreventPolling - Determine whether to prevent polling on network change\n   */\n  updatePreventPollingOnNetworkRestart(shouldPreventPolling: boolean): void {\n    this.update(() => {\n      return {\n        ...this.state,\n        preventPollingOnNetworkRestart: shouldPreventPolling,\n      };\n    });\n  }\n}\n\nexport default TokenListController;\n"]}
\ No newline at end of file
diff --git a/dist/index.js b/dist/index.js
index 4fd181a913b306223c4c0825b0edc9c516acad9d..095567634e3a5da156b7de49fb7d96b3fa76c68f 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -2,13 +2,13 @@
 
 
 
-var _chunk4FMVFW2Tjs = require('./chunk-4FMVFW2T.js');
+var _chunkTPJ5KVPFjs = require('./chunk-TPJ5KVPF.js');
 
 
-var _chunkIOQX3VTDjs = require('./chunk-IOQX3VTD.js');
+var _chunk6MY5FIJBjs = require('./chunk-6MY5FIJB.js');
 
 
-var _chunkSOK5YX7Ijs = require('./chunk-SOK5YX7I.js');
+var _chunkAVPUXAZYjs = require('./chunk-AVPUXAZY.js');
 
 
 var _chunkV4ZO3F2Sjs = require('./chunk-V4ZO3F2S.js');
@@ -27,7 +27,7 @@ require('./chunk-DYH5P3VY.js');
 
 
 
-var _chunkKM3J4DO6js = require('./chunk-KM3J4DO6.js');
+var _chunkF2F3NGG3js = require('./chunk-F2F3NGG3.js');
 
 
 
@@ -41,8 +41,8 @@ var _chunkLD4GC7ORjs = require('./chunk-LD4GC7OR.js');
 var _chunkI53XGBU3js = require('./chunk-I53XGBU3.js');
 
 
-var _chunkDEQZ35QEjs = require('./chunk-DEQZ35QE.js');
-require('./chunk-OHSQRYVL.js');
+var _chunkU36OEBF2js = require('./chunk-U36OEBF2.js');
+require('./chunk-OKEA7NPV.js');
 
 
 
@@ -71,5 +71,5 @@ require('./chunk-Z4BLTVTB.js');
 
 
 
-exports.AccountTrackerController = _chunkV4ZO3F2Sjs.AccountTrackerController; exports.AssetsContractController = _chunkQHU4H6HPjs.AssetsContractController; exports.BlockaidResultType = _chunkX2MMIBYWjs.BlockaidResultType; exports.CodefiTokenPricesServiceV2 = _chunk4FMVFW2Tjs.CodefiTokenPricesServiceV2; exports.CurrencyRateController = _chunkLRKDZWS6js.CurrencyRateController; exports.MISSING_PROVIDER_ERROR = _chunkQHU4H6HPjs.MISSING_PROVIDER_ERROR; exports.NftController = _chunkKM3J4DO6js.NftController; exports.NftDetectionController = _chunkX2MMIBYWjs.NftDetectionController; exports.SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID = _chunkQHU4H6HPjs.SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID; exports.SUPPORTED_CHAIN_IDS = _chunk4FMVFW2Tjs.SUPPORTED_CHAIN_IDS; exports.TokenBalancesController = _chunkLD4GC7ORjs.TokenBalancesController; exports.TokenDetectionController = _chunkI53XGBU3js.TokenDetectionController; exports.TokenListController = _chunkDEQZ35QEjs.TokenListController; exports.TokenRatesController = _chunkIOQX3VTDjs.TokenRatesController; exports.TokensController = _chunkSOK5YX7Ijs.TokensController; exports.fetchTokenContractExchangeRates = _chunkLS6R3HQLjs.fetchTokenContractExchangeRates; exports.formatIconUrlWithProxy = _chunkLS6R3HQLjs.formatIconUrlWithProxy; exports.getDefaultNftState = _chunkKM3J4DO6js.getDefaultNftState; exports.getFormattedIpfsUrl = _chunkLS6R3HQLjs.getFormattedIpfsUrl; exports.isTokenDetectionSupportedForNetwork = _chunkLS6R3HQLjs.isTokenDetectionSupportedForNetwork;
+exports.AccountTrackerController = _chunkV4ZO3F2Sjs.AccountTrackerController; exports.AssetsContractController = _chunkQHU4H6HPjs.AssetsContractController; exports.BlockaidResultType = _chunkX2MMIBYWjs.BlockaidResultType; exports.CodefiTokenPricesServiceV2 = _chunkTPJ5KVPFjs.CodefiTokenPricesServiceV2; exports.CurrencyRateController = _chunkLRKDZWS6js.CurrencyRateController; exports.MISSING_PROVIDER_ERROR = _chunkQHU4H6HPjs.MISSING_PROVIDER_ERROR; exports.NftController = _chunkF2F3NGG3js.NftController; exports.NftDetectionController = _chunkX2MMIBYWjs.NftDetectionController; exports.SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID = _chunkQHU4H6HPjs.SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID; exports.SUPPORTED_CHAIN_IDS = _chunkTPJ5KVPFjs.SUPPORTED_CHAIN_IDS; exports.TokenBalancesController = _chunkLD4GC7ORjs.TokenBalancesController; exports.TokenDetectionController = _chunkI53XGBU3js.TokenDetectionController; exports.TokenListController = _chunkU36OEBF2js.TokenListController; exports.TokenRatesController = _chunk6MY5FIJBjs.TokenRatesController; exports.TokensController = _chunkAVPUXAZYjs.TokensController; exports.fetchTokenContractExchangeRates = _chunkLS6R3HQLjs.fetchTokenContractExchangeRates; exports.formatIconUrlWithProxy = _chunkLS6R3HQLjs.formatIconUrlWithProxy; exports.getDefaultNftState = _chunkF2F3NGG3js.getDefaultNftState; exports.getFormattedIpfsUrl = _chunkLS6R3HQLjs.getFormattedIpfsUrl; exports.isTokenDetectionSupportedForNetwork = _chunkLS6R3HQLjs.isTokenDetectionSupportedForNetwork;
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/dist/index.mjs b/dist/index.mjs
index 746ec6dfda28da67de13f6f13f891117ec98d354..6b933e0128c1e636d5d97ec51377d9589a7ce30f 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -2,13 +2,13 @@ import "./chunk-27KOXCQK.mjs";
 import {
   CodefiTokenPricesServiceV2,
   SUPPORTED_CHAIN_IDS
-} from "./chunk-OSEZFHQ3.mjs";
+} from "./chunk-7RV5HGC4.mjs";
 import {
   TokenRatesController
-} from "./chunk-OWTCG2N3.mjs";
+} from "./chunk-4L54AXTJ.mjs";
 import {
   TokensController
-} from "./chunk-6XOM7KOQ.mjs";
+} from "./chunk-MDHJNCTR.mjs";
 import {
   AccountTrackerController
 } from "./chunk-PAJTKWEC.mjs";
@@ -27,7 +27,7 @@ import "./chunk-PWZE6KJV.mjs";
 import {
   NftController,
   getDefaultNftState
-} from "./chunk-S6CZP74C.mjs";
+} from "./chunk-ONJIVH6M.mjs";
 import {
   BlockaidResultType,
   NftDetectionController
@@ -41,8 +41,8 @@ import {
 } from "./chunk-D3PCUDTX.mjs";
 import {
   TokenListController
-} from "./chunk-RUE635TV.mjs";
-import "./chunk-NXGX7LZJ.mjs";
+} from "./chunk-C64L6MMU.mjs";
+import "./chunk-S6KASB6I.mjs";
 import {
   fetchTokenContractExchangeRates,
   formatIconUrlWithProxy,
diff --git a/dist/token-prices-service/codefi-v2.js b/dist/token-prices-service/codefi-v2.js
index 12349307f439aee9f735ae3c4f41a6a16dce117f..598f46f894a40c5067881f214c5603e4a2543487 100644
--- a/dist/token-prices-service/codefi-v2.js
+++ b/dist/token-prices-service/codefi-v2.js
@@ -2,11 +2,11 @@
 
 
 
-var _chunk4FMVFW2Tjs = require('../chunk-4FMVFW2T.js');
+var _chunkTPJ5KVPFjs = require('../chunk-TPJ5KVPF.js');
 require('../chunk-Z4BLTVTB.js');
 
 
 
 
-exports.CodefiTokenPricesServiceV2 = _chunk4FMVFW2Tjs.CodefiTokenPricesServiceV2; exports.SUPPORTED_CHAIN_IDS = _chunk4FMVFW2Tjs.SUPPORTED_CHAIN_IDS; exports.SUPPORTED_CURRENCIES = _chunk4FMVFW2Tjs.SUPPORTED_CURRENCIES;
+exports.CodefiTokenPricesServiceV2 = _chunkTPJ5KVPFjs.CodefiTokenPricesServiceV2; exports.SUPPORTED_CHAIN_IDS = _chunkTPJ5KVPFjs.SUPPORTED_CHAIN_IDS; exports.SUPPORTED_CURRENCIES = _chunkTPJ5KVPFjs.SUPPORTED_CURRENCIES;
 //# sourceMappingURL=codefi-v2.js.map
\ No newline at end of file
diff --git a/dist/token-prices-service/codefi-v2.mjs b/dist/token-prices-service/codefi-v2.mjs
index 84a8c58d9fcae51e3803c259c1c783ccf5d8b977..be6748a0c0e1cd6afb78122c35ca4572ccf542b8 100644
--- a/dist/token-prices-service/codefi-v2.mjs
+++ b/dist/token-prices-service/codefi-v2.mjs
@@ -2,7 +2,7 @@ import {
   CodefiTokenPricesServiceV2,
   SUPPORTED_CHAIN_IDS,
   SUPPORTED_CURRENCIES
-} from "../chunk-OSEZFHQ3.mjs";
+} from "../chunk-7RV5HGC4.mjs";
 import "../chunk-XUI43LEZ.mjs";
 export {
   CodefiTokenPricesServiceV2,
diff --git a/dist/token-prices-service/index.js b/dist/token-prices-service/index.js
index 9751eb6244eba1681e47d1c84db5e6a5355806aa..a83dbc9e47191a52e1844e27e712f9fae66ea1c0 100644
--- a/dist/token-prices-service/index.js
+++ b/dist/token-prices-service/index.js
@@ -2,10 +2,10 @@
 
 
 
-var _chunk4FMVFW2Tjs = require('../chunk-4FMVFW2T.js');
+var _chunkTPJ5KVPFjs = require('../chunk-TPJ5KVPF.js');
 require('../chunk-Z4BLTVTB.js');
 
 
 
-exports.CodefiTokenPricesServiceV2 = _chunk4FMVFW2Tjs.CodefiTokenPricesServiceV2; exports.SUPPORTED_CHAIN_IDS = _chunk4FMVFW2Tjs.SUPPORTED_CHAIN_IDS;
+exports.CodefiTokenPricesServiceV2 = _chunkTPJ5KVPFjs.CodefiTokenPricesServiceV2; exports.SUPPORTED_CHAIN_IDS = _chunkTPJ5KVPFjs.SUPPORTED_CHAIN_IDS;
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/dist/token-prices-service/index.mjs b/dist/token-prices-service/index.mjs
index f0a82176b8d48796683adfc34e611c3777d4cfd3..e3a3dc26eeef90d00783918f4a295c1c1ed5d7e4 100644
--- a/dist/token-prices-service/index.mjs
+++ b/dist/token-prices-service/index.mjs
@@ -2,7 +2,7 @@ import "../chunk-27KOXCQK.mjs";
 import {
   CodefiTokenPricesServiceV2,
   SUPPORTED_CHAIN_IDS
-} from "../chunk-OSEZFHQ3.mjs";
+} from "../chunk-7RV5HGC4.mjs";
 import "../chunk-XUI43LEZ.mjs";
 export {
   CodefiTokenPricesServiceV2,
diff --git a/dist/token-service.js b/dist/token-service.js
index 262a71417884eac999a1e088d95df4d3ce936771..ef46e96ba35838567c9ff3f9d4a18c604409578f 100644
--- a/dist/token-service.js
+++ b/dist/token-service.js
@@ -3,7 +3,7 @@
 
 
 
-var _chunkOHSQRYVLjs = require('./chunk-OHSQRYVL.js');
+var _chunkOKEA7NPVjs = require('./chunk-OKEA7NPV.js');
 require('./chunk-LS6R3HQL.js');
 require('./chunk-Z4BLTVTB.js');
 
@@ -11,5 +11,5 @@ require('./chunk-Z4BLTVTB.js');
 
 
 
-exports.TOKEN_END_POINT_API = _chunkOHSQRYVLjs.TOKEN_END_POINT_API; exports.TOKEN_METADATA_NO_SUPPORT_ERROR = _chunkOHSQRYVLjs.TOKEN_METADATA_NO_SUPPORT_ERROR; exports.fetchTokenListByChainId = _chunkOHSQRYVLjs.fetchTokenListByChainId; exports.fetchTokenMetadata = _chunkOHSQRYVLjs.fetchTokenMetadata;
+exports.TOKEN_END_POINT_API = _chunkOKEA7NPVjs.TOKEN_END_POINT_API; exports.TOKEN_METADATA_NO_SUPPORT_ERROR = _chunkOKEA7NPVjs.TOKEN_METADATA_NO_SUPPORT_ERROR; exports.fetchTokenListByChainId = _chunkOKEA7NPVjs.fetchTokenListByChainId; exports.fetchTokenMetadata = _chunkOKEA7NPVjs.fetchTokenMetadata;
 //# sourceMappingURL=token-service.js.map
\ No newline at end of file
diff --git a/dist/token-service.mjs b/dist/token-service.mjs
index 34cabaa1b1030ec2b836bb40a175621ac55dfb6c..dd0c1fd283a1d7106334ec4c188cc996e4a7d1f8 100644
--- a/dist/token-service.mjs
+++ b/dist/token-service.mjs
@@ -3,7 +3,7 @@ import {
   TOKEN_METADATA_NO_SUPPORT_ERROR,
   fetchTokenListByChainId,
   fetchTokenMetadata
-} from "./chunk-NXGX7LZJ.mjs";
+} from "./chunk-S6KASB6I.mjs";
 import "./chunk-X5PLVMOQ.mjs";
 import "./chunk-XUI43LEZ.mjs";
 export {
diff --git a/dist/tsconfig.build.tsbuildinfo b/dist/tsconfig.build.tsbuildinfo
index 8fcb5ed1e96838473899856fb3a69763871d1238..858494a63a52048b760c1392e598fe5758601840 100644
--- a/dist/tsconfig.build.tsbuildinfo
+++ b/dist/tsconfig.build.tsbuildinfo
@@ -1 +1 @@
-{"program":{"fileNames":["../../../node_modules/typescript/lib/lib.es5.d.ts","../../../node_modules/typescript/lib/lib.es2015.d.ts","../../../node_modules/typescript/lib/lib.es2016.d.ts","../../../node_modules/typescript/lib/lib.es2017.d.ts","../../../node_modules/typescript/lib/lib.es2018.d.ts","../../../node_modules/typescript/lib/lib.es2019.d.ts","../../../node_modules/typescript/lib/lib.es2020.d.ts","../../../node_modules/typescript/lib/lib.dom.d.ts","../../../node_modules/typescript/lib/lib.es2015.core.d.ts","../../../node_modules/typescript/lib/lib.es2015.collection.d.ts","../../../node_modules/typescript/lib/lib.es2015.generator.d.ts","../../../node_modules/typescript/lib/lib.es2015.iterable.d.ts","../../../node_modules/typescript/lib/lib.es2015.promise.d.ts","../../../node_modules/typescript/lib/lib.es2015.proxy.d.ts","../../../node_modules/typescript/lib/lib.es2015.reflect.d.ts","../../../node_modules/typescript/lib/lib.es2015.symbol.d.ts","../../../node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts","../../../node_modules/typescript/lib/lib.es2016.array.include.d.ts","../../../node_modules/typescript/lib/lib.es2017.object.d.ts","../../../node_modules/typescript/lib/lib.es2017.sharedmemory.d.ts","../../../node_modules/typescript/lib/lib.es2017.string.d.ts","../../../node_modules/typescript/lib/lib.es2017.intl.d.ts","../../../node_modules/typescript/lib/lib.es2017.typedarrays.d.ts","../../../node_modules/typescript/lib/lib.es2018.asyncgenerator.d.ts","../../../node_modules/typescript/lib/lib.es2018.asynciterable.d.ts","../../../node_modules/typescript/lib/lib.es2018.intl.d.ts","../../../node_modules/typescript/lib/lib.es2018.promise.d.ts","../../../node_modules/typescript/lib/lib.es2018.regexp.d.ts","../../../node_modules/typescript/lib/lib.es2019.array.d.ts","../../../node_modules/typescript/lib/lib.es2019.object.d.ts","../../../node_modules/typescript/lib/lib.es2019.string.d.ts","../../../node_modules/typescript/lib/lib.es2019.symbol.d.ts","../../../node_modules/typescript/lib/lib.es2019.intl.d.ts","../../../node_modules/typescript/lib/lib.es2020.bigint.d.ts","../../../node_modules/typescript/lib/lib.es2020.date.d.ts","../../../node_modules/typescript/lib/lib.es2020.promise.d.ts","../../../node_modules/typescript/lib/lib.es2020.sharedmemory.d.ts","../../../node_modules/typescript/lib/lib.es2020.string.d.ts","../../../node_modules/typescript/lib/lib.es2020.symbol.wellknown.d.ts","../../../node_modules/typescript/lib/lib.es2020.intl.d.ts","../../../node_modules/typescript/lib/lib.es2020.number.d.ts","../../../node_modules/typescript/lib/lib.esnext.intl.d.ts","../../../types/eth-ens-namehash.d.ts","../../../types/ethereum-ens-network-map.d.ts","../../../types/global.d.ts","../../../types/single-call-balance-checker-abi.d.ts","../../../types/@metamask/contract-metadata.d.ts","../../../types/@metamask/eth-hd-keyring.d.ts","../../../types/@metamask/eth-simple-keyring.d.ts","../../../types/@metamask/ethjs-provider-http.d.ts","../../../types/@metamask/ethjs-unit.d.ts","../../../types/@metamask/metamask-eth-abis.d.ts","../../../types/eth-json-rpc-infura/src/createProvider.d.ts","../../../types/eth-phishing-detect/src/config.json.d.ts","../../../types/eth-phishing-detect/src/detector.d.ts","../../base-controller/dist/types/BaseControllerV1.d.ts","../../../node_modules/superstruct/dist/error.d.ts","../../../node_modules/superstruct/dist/utils.d.ts","../../../node_modules/superstruct/dist/struct.d.ts","../../../node_modules/superstruct/dist/structs/coercions.d.ts","../../../node_modules/superstruct/dist/structs/refinements.d.ts","../../../node_modules/superstruct/dist/structs/types.d.ts","../../../node_modules/superstruct/dist/structs/utilities.d.ts","../../../node_modules/superstruct/dist/index.d.ts","../../../node_modules/@metamask/utils/dist/types/assert.d.ts","../../../node_modules/@metamask/utils/dist/types/base64.d.ts","../../../node_modules/@metamask/utils/dist/types/hex.d.ts","../../../node_modules/@metamask/utils/dist/types/bytes.d.ts","../../../node_modules/@metamask/utils/dist/types/caip-types.d.ts","../../../node_modules/@metamask/utils/dist/types/checksum.d.ts","../../../node_modules/@metamask/utils/dist/types/coercers.d.ts","../../../node_modules/@metamask/utils/dist/types/collections.d.ts","../../../node_modules/@metamask/utils/dist/types/encryption-types.d.ts","../../../node_modules/@metamask/utils/dist/types/errors.d.ts","../../../node_modules/@metamask/utils/dist/types/json.d.ts","../../../node_modules/@types/node/assert.d.ts","../../../node_modules/@types/node/assert/strict.d.ts","../../../node_modules/@types/node/globals.d.ts","../../../node_modules/@types/node/async_hooks.d.ts","../../../node_modules/@types/node/buffer.d.ts","../../../node_modules/@types/node/child_process.d.ts","../../../node_modules/@types/node/cluster.d.ts","../../../node_modules/@types/node/console.d.ts","../../../node_modules/@types/node/constants.d.ts","../../../node_modules/@types/node/crypto.d.ts","../../../node_modules/@types/node/dgram.d.ts","../../../node_modules/@types/node/diagnostics_channel.d.ts","../../../node_modules/@types/node/dns.d.ts","../../../node_modules/@types/node/dns/promises.d.ts","../../../node_modules/@types/node/domain.d.ts","../../../node_modules/@types/node/events.d.ts","../../../node_modules/@types/node/fs.d.ts","../../../node_modules/@types/node/fs/promises.d.ts","../../../node_modules/@types/node/http.d.ts","../../../node_modules/@types/node/http2.d.ts","../../../node_modules/@types/node/https.d.ts","../../../node_modules/@types/node/inspector.d.ts","../../../node_modules/@types/node/module.d.ts","../../../node_modules/@types/node/net.d.ts","../../../node_modules/@types/node/os.d.ts","../../../node_modules/@types/node/path.d.ts","../../../node_modules/@types/node/perf_hooks.d.ts","../../../node_modules/@types/node/process.d.ts","../../../node_modules/@types/node/punycode.d.ts","../../../node_modules/@types/node/querystring.d.ts","../../../node_modules/@types/node/readline.d.ts","../../../node_modules/@types/node/repl.d.ts","../../../node_modules/@types/node/stream.d.ts","../../../node_modules/@types/node/stream/promises.d.ts","../../../node_modules/@types/node/stream/consumers.d.ts","../../../node_modules/@types/node/stream/web.d.ts","../../../node_modules/@types/node/string_decoder.d.ts","../../../node_modules/@types/node/test.d.ts","../../../node_modules/@types/node/timers.d.ts","../../../node_modules/@types/node/timers/promises.d.ts","../../../node_modules/@types/node/tls.d.ts","../../../node_modules/@types/node/trace_events.d.ts","../../../node_modules/@types/node/tty.d.ts","../../../node_modules/@types/node/url.d.ts","../../../node_modules/@types/node/util.d.ts","../../../node_modules/@types/node/v8.d.ts","../../../node_modules/@types/node/vm.d.ts","../../../node_modules/@types/node/wasi.d.ts","../../../node_modules/@types/node/worker_threads.d.ts","../../../node_modules/@types/node/zlib.d.ts","../../../node_modules/@types/node/globals.global.d.ts","../../../node_modules/@types/node/index.d.ts","../../../node_modules/@ethereumjs/common/dist/enums.d.ts","../../../node_modules/@ethereumjs/common/dist/types.d.ts","../../../node_modules/buffer/index.d.ts","../../../node_modules/@ethereumjs/util/dist/constants.d.ts","../../../node_modules/@ethereumjs/util/dist/units.d.ts","../../../node_modules/@ethereumjs/util/dist/address.d.ts","../../../node_modules/@ethereumjs/util/dist/bytes.d.ts","../../../node_modules/@ethereumjs/util/dist/types.d.ts","../../../node_modules/@ethereumjs/util/dist/account.d.ts","../../../node_modules/@ethereumjs/util/dist/withdrawal.d.ts","../../../node_modules/@ethereumjs/util/dist/signature.d.ts","../../../node_modules/@ethereumjs/util/dist/encoding.d.ts","../../../node_modules/@ethereumjs/util/dist/asyncEventEmitter.d.ts","../../../node_modules/@ethereumjs/util/dist/internal.d.ts","../../../node_modules/@ethereumjs/util/dist/lock.d.ts","../../../node_modules/@ethereumjs/util/dist/provider.d.ts","../../../node_modules/@ethereumjs/util/dist/index.d.ts","../../../node_modules/@ethereumjs/common/dist/common.d.ts","../../../node_modules/@ethereumjs/common/dist/utils.d.ts","../../../node_modules/@ethereumjs/common/dist/index.d.ts","../../../node_modules/@ethereumjs/tx/dist/eip2930Transaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/legacyTransaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/types.d.ts","../../../node_modules/@ethereumjs/tx/dist/baseTransaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/eip1559Transaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/transactionFactory.d.ts","../../../node_modules/@ethereumjs/tx/dist/index.d.ts","../../../node_modules/@metamask/utils/dist/types/keyring.d.ts","../../../node_modules/@types/ms/index.d.ts","../../../node_modules/@types/debug/index.d.ts","../../../node_modules/@metamask/utils/dist/types/logging.d.ts","../../../node_modules/@metamask/utils/dist/types/misc.d.ts","../../../node_modules/@metamask/utils/dist/types/number.d.ts","../../../node_modules/@metamask/utils/dist/types/opaque.d.ts","../../../node_modules/@metamask/utils/dist/types/promise.d.ts","../../../node_modules/@metamask/utils/dist/types/time.d.ts","../../../node_modules/@metamask/utils/dist/types/transaction-types.d.ts","../../../node_modules/@metamask/utils/dist/types/versions.d.ts","../../../node_modules/@metamask/utils/dist/types/index.d.ts","../../../node_modules/immer/dist/utils/env.d.ts","../../../node_modules/immer/dist/utils/errors.d.ts","../../../node_modules/immer/dist/types/types-external.d.ts","../../../node_modules/immer/dist/types/types-internal.d.ts","../../../node_modules/immer/dist/utils/common.d.ts","../../../node_modules/immer/dist/utils/plugins.d.ts","../../../node_modules/immer/dist/core/scope.d.ts","../../../node_modules/immer/dist/core/finalize.d.ts","../../../node_modules/immer/dist/core/proxy.d.ts","../../../node_modules/immer/dist/core/immerClass.d.ts","../../../node_modules/immer/dist/core/current.d.ts","../../../node_modules/immer/dist/internal.d.ts","../../../node_modules/immer/dist/plugins/es5.d.ts","../../../node_modules/immer/dist/plugins/patches.d.ts","../../../node_modules/immer/dist/plugins/mapset.d.ts","../../../node_modules/immer/dist/plugins/all.d.ts","../../../node_modules/immer/dist/immer.d.ts","../../base-controller/dist/types/RestrictedControllerMessenger.d.ts","../../base-controller/dist/types/ControllerMessenger.d.ts","../../base-controller/dist/types/BaseControllerV2.d.ts","../../base-controller/dist/types/index.d.ts","../../controller-utils/dist/types/types.d.ts","../../controller-utils/dist/types/constants.d.ts","../../../node_modules/@metamask/eth-query/index.d.ts","../../../node_modules/@types/bn.js/index.d.ts","../../controller-utils/dist/types/util.d.ts","../../../node_modules/@spruceid/siwe-parser/dist/abnf.d.ts","../../../node_modules/@spruceid/siwe-parser/dist/utils.d.ts","../../../node_modules/@spruceid/siwe-parser/dist/parsers.d.ts","../../controller-utils/dist/types/siwe.d.ts","../../controller-utils/dist/types/index.d.ts","../../../node_modules/@metamask/swappable-obj-proxy/dist/types.d.ts","../../../node_modules/@metamask/swappable-obj-proxy/dist/createEventEmitterProxy.d.ts","../../../node_modules/@metamask/swappable-obj-proxy/dist/createSwappableProxy.d.ts","../../../node_modules/@metamask/swappable-obj-proxy/dist/index.d.ts","../../network-controller/dist/types/constants.d.ts","../../../node_modules/@metamask/safe-event-emitter/index.d.ts","../../json-rpc-engine/dist/types/JsonRpcEngine.d.ts","../../json-rpc-engine/dist/types/createAsyncMiddleware.d.ts","../../json-rpc-engine/dist/types/createScaffoldMiddleware.d.ts","../../json-rpc-engine/dist/types/getUniqueId.d.ts","../../json-rpc-engine/dist/types/idRemapMiddleware.d.ts","../../json-rpc-engine/dist/types/mergeMiddleware.d.ts","../../json-rpc-engine/dist/types/index.d.ts","../../eth-json-rpc-provider/dist/types/safe-event-emitter-provider.d.ts","../../eth-json-rpc-provider/dist/types/provider-from-engine.d.ts","../../eth-json-rpc-provider/dist/types/provider-from-middleware.d.ts","../../eth-json-rpc-provider/dist/types/index.d.ts","../../../node_modules/eth-block-tracker/dist/BlockTracker.d.ts","../../../node_modules/eth-block-tracker/dist/PollingBlockTracker.d.ts","../../../node_modules/eth-block-tracker/dist/SubscribeBlockTracker.d.ts","../../../node_modules/eth-block-tracker/dist/index.d.ts","../../network-controller/dist/types/types.d.ts","../../network-controller/dist/types/create-auto-managed-network-client.d.ts","../../network-controller/dist/types/NetworkController.d.ts","../../network-controller/dist/types/create-network-client.d.ts","../../network-controller/dist/types/index.d.ts","../../polling-controller/dist/types/types.d.ts","../../polling-controller/dist/types/BlockTrackerPollingController.d.ts","../../polling-controller/dist/types/StaticIntervalPollingController.d.ts","../../polling-controller/dist/types/index.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/patchCBOR.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/lib/DataItem.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/lib/cbor-sync.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/lib/index.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/ur.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/urEncoder.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/fountainEncoder.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/fountainDecoder.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/urDecoder.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/index.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/RegistryType.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/RegistryItem.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/CryptoCoinInfo.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/PathComponent.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/CryptoKeypath.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/types.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/CryptoHDKey.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/CryptoECKey.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/Bytes.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/MultiKey.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/ScriptExpression.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/CryptoOutput.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/CryptoPSBT.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/CryptoAccount.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/Decoder/index.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/extended/CryptoMultiAccounts.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/errors/index.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/extended/DerivationSchema.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/extended/KeyDerivation.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/extended/QRHardwareCall.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/utils.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/index.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/EthSignRequest.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/EthSignature.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/ETHNFTItem.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/utlis.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/index.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/dist/InteractionProvider.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/dist/BaseKeyring.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/dist/index.d.ts","../../../node_modules/@metamask/obs-store/node_modules/@metamask/safe-event-emitter/index.d.ts","../../../node_modules/@metamask/obs-store/dist/ObservableStore.d.ts","../../../node_modules/@metamask/obs-store/dist/asStream.d.ts","../../../node_modules/@metamask/obs-store/dist/ComposedStore.d.ts","../../../node_modules/@metamask/obs-store/dist/MergedStore.d.ts","../../../node_modules/@metamask/obs-store/dist/transform.d.ts","../../../node_modules/@metamask/obs-store/dist/index.d.ts","../../../node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/index.d.ts","../../../node_modules/@keystonehq/metamask-airgapped-keyring/dist/MetaMaskInteractionProvider.d.ts","../../../node_modules/@keystonehq/metamask-airgapped-keyring/dist/MetaMaskKeyring.d.ts","../../../node_modules/@keystonehq/metamask-airgapped-keyring/dist/index.d.ts","../../../node_modules/@metamask/browser-passworder/dist/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/superstruct.d.ts","../../../node_modules/@metamask/keyring-api/dist/api.d.ts","../../../node_modules/@metamask/keyring-api/dist/contexts.d.ts","../../../node_modules/@metamask/keyring-api/dist/eth/erc4337/types.d.ts","../../../node_modules/@metamask/keyring-api/dist/eth/erc4337/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/eth/types.d.ts","../../../node_modules/@metamask/keyring-api/dist/eth/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/events.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/api.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/eth/EthKeyring.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/eth/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/events.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/rpc.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/types.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/JsonRpcRequest.d.ts","../../../node_modules/@metamask/keyring-api/dist/KeyringClient.d.ts","../../../node_modules/@metamask/providers/dist/types/utils.d.ts","../../../node_modules/@metamask/providers/dist/types/BaseProvider.d.ts","../../../node_modules/@metamask/providers/dist/types/EIP6963.d.ts","../../../node_modules/@types/readable-stream/node_modules/safe-buffer/index.d.ts","../../../node_modules/@types/readable-stream/index.d.ts","../../../node_modules/@metamask/providers/dist/types/StreamProvider.d.ts","../../../node_modules/@metamask/providers/dist/types/extension-provider/createExternalExtensionProvider.d.ts","../../../node_modules/@metamask/providers/dist/types/MetaMaskInpageProvider.d.ts","../../../node_modules/@metamask/providers/dist/types/initializeInpageProvider.d.ts","../../../node_modules/@metamask/providers/dist/types/shimWeb3.d.ts","../../../node_modules/@metamask/providers/dist/types/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/KeyringSnapRpcClient.d.ts","../../../node_modules/@metamask/keyring-api/dist/rpc-handler.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/utils.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/classes.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/errors.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/error-constants.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/errors.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/error-wrappers.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/errors.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/helpers.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/structs.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/svg.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/error-wrappers.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/nodes.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/address.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/copyable.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/divider.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/heading.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/image.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/panel.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/spinner.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/text.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/row.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/button.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/input.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/form.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/component.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/images.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/create-interface.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/dialog.d.ts","../../../node_modules/@metamask/key-tree/dist/types/constants.d.ts","../../../node_modules/@noble/ed25519/lib/index.d.ts","../../../node_modules/@metamask/key-tree/dist/types/curves/ed25519.d.ts","../../../node_modules/@noble/secp256k1/lib/index.d.ts","../../../node_modules/@metamask/key-tree/dist/types/curves/secp256k1.d.ts","../../../node_modules/@metamask/key-tree/dist/types/curves/curve.d.ts","../../../node_modules/@metamask/key-tree/dist/types/curves/index.d.ts","../../../node_modules/@metamask/key-tree/dist/types/utils.d.ts","../../../node_modules/@metamask/key-tree/dist/types/BIP44CoinTypeNode.d.ts","../../../node_modules/@metamask/key-tree/dist/types/SLIP10Node.d.ts","../../../node_modules/@metamask/key-tree/dist/types/BIP44Node.d.ts","../../../node_modules/@metamask/key-tree/dist/types/derivers/bip32.d.ts","../../../node_modules/@metamask/key-tree/dist/types/derivers/bip39.d.ts","../../../node_modules/@metamask/key-tree/dist/types/derivers/slip10.d.ts","../../../node_modules/@metamask/key-tree/dist/types/derivers/index.d.ts","../../../node_modules/@metamask/key-tree/dist/types/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/caip.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/permissions.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-bip32-entropy.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-bip32-public-key.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-bip44-entropy.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-client-status.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-entropy.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-file.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/interface.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-interface-state.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-locale.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/snap.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-snaps.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/invoke-snap.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/invoke-keyring.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/manage-accounts.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/manage-state.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/notify.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/request-snaps.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/update-interface.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/methods.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/provider.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/global.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/images.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/cronjob.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/home-page.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/keyring.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/lifecycle.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/name-lookup.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/rpc-request.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/transaction.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/signature.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/user-input.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/snap-utils.d.ts","../../../node_modules/@metamask/keyring-api/dist/index.d.ts","../../message-manager/dist/types/AbstractMessageManager.d.ts","../../message-manager/dist/types/MessageManager.d.ts","../../message-manager/dist/types/PersonalMessageManager.d.ts","../../message-manager/dist/types/TypedMessageManager.d.ts","../../message-manager/dist/types/EncryptionPublicKeyManager.d.ts","../../message-manager/dist/types/DecryptMessageManager.d.ts","../../message-manager/dist/types/index.d.ts","../../keyring-controller/dist/types/KeyringController.d.ts","../../keyring-controller/dist/types/index.d.ts","../../preferences-controller/dist/types/constants.d.ts","../../preferences-controller/dist/types/PreferencesController.d.ts","../../preferences-controller/dist/types/index.d.ts","../../../node_modules/async-mutex/lib/MutexInterface.d.ts","../../../node_modules/async-mutex/lib/Mutex.d.ts","../../../node_modules/async-mutex/lib/SemaphoreInterface.d.ts","../../../node_modules/async-mutex/lib/Semaphore.d.ts","../../../node_modules/async-mutex/lib/withTimeout.d.ts","../../../node_modules/async-mutex/lib/index.d.ts","../../../node_modules/@types/lodash/common/common.d.ts","../../../node_modules/@types/lodash/common/array.d.ts","../../../node_modules/@types/lodash/common/collection.d.ts","../../../node_modules/@types/lodash/common/date.d.ts","../../../node_modules/@types/lodash/common/function.d.ts","../../../node_modules/@types/lodash/common/lang.d.ts","../../../node_modules/@types/lodash/common/math.d.ts","../../../node_modules/@types/lodash/common/number.d.ts","../../../node_modules/@types/lodash/common/object.d.ts","../../../node_modules/@types/lodash/common/seq.d.ts","../../../node_modules/@types/lodash/common/string.d.ts","../../../node_modules/@types/lodash/common/util.d.ts","../../../node_modules/@types/lodash/index.d.ts","../src/AccountTrackerController.ts","../../../node_modules/@ethersproject/bytes/lib/index.d.ts","../../../node_modules/@ethersproject/bignumber/lib/bignumber.d.ts","../../../node_modules/@ethersproject/bignumber/lib/fixednumber.d.ts","../../../node_modules/@ethersproject/bignumber/lib/index.d.ts","../../../node_modules/@ethersproject/abi/lib/fragments.d.ts","../../../node_modules/@ethersproject/abi/lib/coders/abstract-coder.d.ts","../../../node_modules/@ethersproject/abi/lib/abi-coder.d.ts","../../../node_modules/@ethersproject/properties/lib/index.d.ts","../../../node_modules/@ethersproject/abi/lib/interface.d.ts","../../../node_modules/@ethersproject/abi/lib/index.d.ts","../../../node_modules/@ethersproject/networks/lib/types.d.ts","../../../node_modules/@ethersproject/networks/lib/index.d.ts","../../../node_modules/@ethersproject/transactions/lib/index.d.ts","../../../node_modules/@ethersproject/web/lib/index.d.ts","../../../node_modules/@ethersproject/abstract-provider/lib/index.d.ts","../../../node_modules/@ethersproject/abstract-signer/lib/index.d.ts","../../../node_modules/@ethersproject/contracts/lib/index.d.ts","../../../node_modules/@ethersproject/providers/lib/formatter.d.ts","../../../node_modules/@ethersproject/providers/lib/base-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/json-rpc-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/websocket-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/url-json-rpc-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/alchemy-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/ankr-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/cloudflare-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/etherscan-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/fallback-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/ipc-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/infura-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/json-rpc-batch-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/nodesmith-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/pocket-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/web3-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/index.d.ts","../../../node_modules/multiformats/types/src/bases/interface.d.ts","../../../node_modules/multiformats/types/src/hashes/interface.d.ts","../../../node_modules/multiformats/types/src/cid.d.ts","../../../node_modules/@ethersproject/address/lib/index.d.ts","../../approval-controller/dist/types/ApprovalController.d.ts","../../approval-controller/dist/types/errors.d.ts","../../approval-controller/dist/types/index.d.ts","../../../node_modules/@types/uuid/index.d.ts","../src/constants.ts","../src/NftDetectionController.ts","../src/NftController.ts","../src/token-prices-service/abstract-token-prices-service.ts","../../../node_modules/cockatiel/dist/backoff/ConstantBackoff.d.ts","../../../node_modules/cockatiel/dist/backoff/DelegateBackoff.d.ts","../../../node_modules/cockatiel/dist/backoff/ExponentialBackoffGenerators.d.ts","../../../node_modules/cockatiel/dist/backoff/ExponentialBackoff.d.ts","../../../node_modules/cockatiel/dist/backoff/IterableBackoff.d.ts","../../../node_modules/cockatiel/dist/backoff/Backoff.d.ts","../../../node_modules/cockatiel/dist/common/Event.d.ts","../../../node_modules/cockatiel/dist/BulkheadPolicy.d.ts","../../../node_modules/cockatiel/dist/FallbackPolicy.d.ts","../../../node_modules/cockatiel/dist/NoopPolicy.d.ts","../../../node_modules/cockatiel/dist/RetryPolicy.d.ts","../../../node_modules/cockatiel/dist/TimeoutPolicy.d.ts","../../../node_modules/cockatiel/dist/Policy.d.ts","../../../node_modules/cockatiel/dist/common/Executor.d.ts","../../../node_modules/cockatiel/dist/CircuitBreakerPolicy.d.ts","../../../node_modules/cockatiel/dist/breaker/SamplingBreaker.d.ts","../../../node_modules/cockatiel/dist/breaker/ConsecutiveBreaker.d.ts","../../../node_modules/cockatiel/dist/breaker/Breaker.d.ts","../../../node_modules/cockatiel/dist/errors/BrokenCircuitError.d.ts","../../../node_modules/cockatiel/dist/errors/BulkheadRejectedError.d.ts","../../../node_modules/cockatiel/dist/errors/IsolatedCircuitError.d.ts","../../../node_modules/cockatiel/dist/errors/TaskCancelledError.d.ts","../../../node_modules/cockatiel/dist/errors/Errors.d.ts","../../../node_modules/cockatiel/dist/index.d.ts","../src/token-prices-service/codefi-v2.ts","../src/token-prices-service/index.ts","../src/crypto-compare.ts","../../../node_modules/@metamask/metamask-eth-abis/dist/abis/abiERC20.d.ts","../../../node_modules/@metamask/metamask-eth-abis/dist/abis/abiERC721.d.ts","../../../node_modules/@metamask/metamask-eth-abis/dist/abis/abiERC1155.d.ts","../../../node_modules/@metamask/metamask-eth-abis/dist/abis/fiatTokenV2.d.ts","../../../node_modules/@metamask/metamask-eth-abis/dist/index.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/parser.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/address.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/array.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/bool.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/bytes.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/fixed-bytes.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/function.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/number.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/string.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/tuple.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/index.d.ts","../../../node_modules/@metamask/abi-utils/dist/types/abi.d.ts","../../../node_modules/@metamask/abi-utils/dist/types/index.d.ts","../../../node_modules/@metamask/abi-utils/dist/abi.d.ts","../../../node_modules/@metamask/abi-utils/dist/errors.d.ts","../../../node_modules/@metamask/abi-utils/dist/index.d.ts","../src/Standards/ERC20Standard.ts","../src/Standards/NftStandards/ERC1155/ERC1155Standard.ts","../src/token-service.ts","../src/TokenListController.ts","../src/TokensController.ts","../src/TokenRatesController.ts","../src/assetsUtil.ts","../src/Standards/NftStandards/ERC721/ERC721Standard.ts","../src/AssetsContractController.ts","../src/CurrencyRateController.ts","../src/TokenBalancesController.ts","../../../node_modules/@metamask/object-multiplex/dist/Substream.d.ts","../../../node_modules/@metamask/object-multiplex/dist/ObjectMultiplex.d.ts","../../../node_modules/@metamask/object-multiplex/dist/index.d.ts","../../../node_modules/@metamask/post-message-stream/dist/utils.d.ts","../../../node_modules/@metamask/post-message-stream/dist/BasePostMessageStream.d.ts","../../../node_modules/@metamask/post-message-stream/dist/window/WindowPostMessageStream.d.ts","../../../node_modules/@metamask/post-message-stream/dist/WebWorker/WebWorkerPostMessageStream.d.ts","../../../node_modules/@metamask/post-message-stream/dist/WebWorker/WebWorkerParentPostMessageStream.d.ts","../../../node_modules/@metamask/post-message-stream/dist/node-process/ProcessParentMessageStream.d.ts","../../../node_modules/@metamask/post-message-stream/dist/node-process/ProcessMessageStream.d.ts","../../../node_modules/@metamask/post-message-stream/dist/node-thread/ThreadParentMessageStream.d.ts","../../../node_modules/@metamask/post-message-stream/dist/node-thread/ThreadMessageStream.d.ts","../../../node_modules/@metamask/post-message-stream/dist/runtime/BrowserRuntimePostMessageStream.d.ts","../../../node_modules/@metamask/post-message-stream/dist/index.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/array.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/auxiliary-files.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/virtual-file/VirtualFile.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/virtual-file/index.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/base64.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/bytes.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/caveats.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/checksum.d.ts","../../../node_modules/cron-parser/types/common.d.ts","../../../node_modules/cron-parser/types/index.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/cronjob.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/deep-clone.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/default-endowments.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/derivation-paths.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/entropy.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/errors.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/handler-types.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/handlers.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/iframe.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/json.d.ts","../../../node_modules/nanoid/index.d.ts","../../../node_modules/@types/deep-freeze-strict/index.d.ts","../../permission-controller/src/permission-middleware.ts","../../permission-controller/src/SubjectMetadataController.ts","../../permission-controller/src/utils.ts","../../permission-controller/src/PermissionController.ts","../../permission-controller/src/Permission.ts","../../permission-controller/src/errors.ts","../../permission-controller/src/Caveat.ts","../../permission-controller/src/rpc-methods/getPermissions.ts","../../permission-controller/src/rpc-methods/requestPermissions.ts","../../permission-controller/src/rpc-methods/revokePermissions.ts","../../permission-controller/src/rpc-methods/index.ts","../../permission-controller/src/index.ts","../../../node_modules/@metamask/snaps-utils/dist/types/json-rpc.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/structs.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/manifest/validation.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/manifest/index.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/localization.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/logging.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/namespace.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/path.d.ts","../../../node_modules/@metamask/snaps-registry/dist/verify.d.ts","../../../node_modules/@metamask/snaps-registry/dist/index.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/types.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/snaps.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/strings.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/ui.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/validation.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/versions.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/ExecutionService.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/AbstractExecutionService.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/ProxyPostMessageStream.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/iframe/IframeExecutionService.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/iframe/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/proxy/ProxyExecutionService.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/offscreen/OffscreenExecutionService.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/offscreen/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/webworker/WebWorkerExecutionService.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/webworker/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/location/npm.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/location/location.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/location/http.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/location/local.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/location/index.d.ts","../../../node_modules/@xstate/fsm/lib/types.d.ts","../../../node_modules/@xstate/fsm/lib/index.d.ts","../../../node_modules/@types/punycode/index.d.ts","../../phishing-controller/src/utils.ts","../../phishing-controller/src/PhishingController.ts","../../phishing-controller/src/index.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/interface/SnapInterfaceController.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/interface/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/types/encryptor.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/types/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/registry/registry.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/registry/json.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/registry/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/Timer.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/SnapController.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/selectors.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/utils.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/cronjob/CronjobController.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/cronjob/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/index.d.ts","../../accounts-controller/dist/types/AccountsController.d.ts","../../accounts-controller/dist/types/utils.d.ts","../../accounts-controller/dist/types/index.d.ts","../src/TokenDetectionController.ts","../src/index.ts","../../../node_modules/@babel/types/lib/index.d.ts","../../../node_modules/@types/babel__generator/index.d.ts","../../../node_modules/@babel/parser/typings/babel-parser.d.ts","../../../node_modules/@types/babel__template/index.d.ts","../../../node_modules/@types/babel__traverse/index.d.ts","../../../node_modules/@types/babel__core/index.d.ts","../../../node_modules/@types/eslint/helpers.d.ts","../../../node_modules/@types/estree/index.d.ts","../../../node_modules/@types/json-schema/index.d.ts","../../../node_modules/@types/eslint/index.d.ts","../../../node_modules/@types/graceful-fs/index.d.ts","../../../node_modules/@types/istanbul-lib-coverage/index.d.ts","../../../node_modules/@types/istanbul-lib-report/index.d.ts","../../../node_modules/@types/istanbul-reports/index.d.ts","../../../node_modules/chalk/index.d.ts","../../../node_modules/jest-diff/build/cleanupSemantic.d.ts","../../../node_modules/pretty-format/build/types.d.ts","../../../node_modules/pretty-format/build/index.d.ts","../../../node_modules/jest-diff/build/types.d.ts","../../../node_modules/jest-diff/build/diffLines.d.ts","../../../node_modules/jest-diff/build/printDiffs.d.ts","../../../node_modules/jest-diff/build/index.d.ts","../../../node_modules/jest-matcher-utils/build/index.d.ts","../../../node_modules/@types/jest/index.d.ts","../../../node_modules/@types/jest-when/index.d.ts","../../../node_modules/@types/json5/index.d.ts","../../../node_modules/@types/minimatch/index.d.ts","../../../node_modules/@types/parse-json/index.d.ts","../../../node_modules/@types/pbkdf2/index.d.ts","../../../node_modules/@types/prettier/index.d.ts","../../../node_modules/@types/secp256k1/index.d.ts","../../../node_modules/@types/semver/classes/semver.d.ts","../../../node_modules/@types/semver/functions/parse.d.ts","../../../node_modules/@types/semver/functions/valid.d.ts","../../../node_modules/@types/semver/functions/clean.d.ts","../../../node_modules/@types/semver/functions/inc.d.ts","../../../node_modules/@types/semver/functions/diff.d.ts","../../../node_modules/@types/semver/functions/major.d.ts","../../../node_modules/@types/semver/functions/minor.d.ts","../../../node_modules/@types/semver/functions/patch.d.ts","../../../node_modules/@types/semver/functions/prerelease.d.ts","../../../node_modules/@types/semver/functions/compare.d.ts","../../../node_modules/@types/semver/functions/rcompare.d.ts","../../../node_modules/@types/semver/functions/compare-loose.d.ts","../../../node_modules/@types/semver/functions/compare-build.d.ts","../../../node_modules/@types/semver/functions/sort.d.ts","../../../node_modules/@types/semver/functions/rsort.d.ts","../../../node_modules/@types/semver/functions/gt.d.ts","../../../node_modules/@types/semver/functions/lt.d.ts","../../../node_modules/@types/semver/functions/eq.d.ts","../../../node_modules/@types/semver/functions/neq.d.ts","../../../node_modules/@types/semver/functions/gte.d.ts","../../../node_modules/@types/semver/functions/lte.d.ts","../../../node_modules/@types/semver/functions/cmp.d.ts","../../../node_modules/@types/semver/functions/coerce.d.ts","../../../node_modules/@types/semver/classes/comparator.d.ts","../../../node_modules/@types/semver/classes/range.d.ts","../../../node_modules/@types/semver/functions/satisfies.d.ts","../../../node_modules/@types/semver/ranges/max-satisfying.d.ts","../../../node_modules/@types/semver/ranges/min-satisfying.d.ts","../../../node_modules/@types/semver/ranges/to-comparators.d.ts","../../../node_modules/@types/semver/ranges/min-version.d.ts","../../../node_modules/@types/semver/ranges/valid.d.ts","../../../node_modules/@types/semver/ranges/outside.d.ts","../../../node_modules/@types/semver/ranges/gtr.d.ts","../../../node_modules/@types/semver/ranges/ltr.d.ts","../../../node_modules/@types/semver/ranges/intersects.d.ts","../../../node_modules/@types/semver/ranges/simplify.d.ts","../../../node_modules/@types/semver/ranges/subset.d.ts","../../../node_modules/@types/semver/internals/identifiers.d.ts","../../../node_modules/@types/semver/index.d.ts","../../../node_modules/@types/sinonjs__fake-timers/index.d.ts","../../../node_modules/@types/sinon/index.d.ts","../../../node_modules/@types/stack-utils/index.d.ts","../../../node_modules/@types/yargs-parser/index.d.ts","../../../node_modules/@types/yargs/index.d.ts"],"fileInfos":[{"version":"8730f4bf322026ff5229336391a18bcaa1f94d4f82416c8b2f3954e2ccaae2ba","affectsGlobalScope":true},"dc47c4fa66b9b9890cf076304de2a9c5201e94b740cffdf09f87296d877d71f6","7a387c58583dfca701b6c85e0adaf43fb17d590fb16d5b2dc0a2fbd89f35c467","8a12173c586e95f4433e0c6dc446bc88346be73ffe9ca6eec7aa63c8f3dca7f9","5f4e733ced4e129482ae2186aae29fde948ab7182844c3a5a51dd346182c7b06","4b421cbfb3a38a27c279dec1e9112c3d1da296f77a1a85ddadf7e7a425d45d18","1fc5ab7a764205c68fa10d381b08417795fc73111d6dd16b5b1ed36badb743d9",{"version":"3aafcb693fe5b5c3bd277bd4c3a617b53db474fe498fc5df067c5603b1eebde7","affectsGlobalScope":true},{"version":"adb996790133eb33b33aadb9c09f15c2c575e71fb57a62de8bf74dbf59ec7dfb","affectsGlobalScope":true},{"version":"8cc8c5a3bac513368b0157f3d8b31cfdcfe78b56d3724f30f80ed9715e404af8","affectsGlobalScope":true},{"version":"cdccba9a388c2ee3fd6ad4018c640a471a6c060e96f1232062223063b0a5ac6a","affectsGlobalScope":true},{"version":"c5c05907c02476e4bde6b7e76a79ffcd948aedd14b6a8f56e4674221b0417398","affectsGlobalScope":true},{"version":"5f406584aef28a331c36523df688ca3650288d14f39c5d2e555c95f0d2ff8f6f","affectsGlobalScope":true},{"version":"22f230e544b35349cfb3bd9110b6ef37b41c6d6c43c3314a31bd0d9652fcec72","affectsGlobalScope":true},{"version":"7ea0b55f6b315cf9ac2ad622b0a7813315bb6e97bf4bb3fbf8f8affbca7dc695","affectsGlobalScope":true},{"version":"3013574108c36fd3aaca79764002b3717da09725a36a6fc02eac386593110f93","affectsGlobalScope":true},{"version":"eb26de841c52236d8222f87e9e6a235332e0788af8c87a71e9e210314300410a","affectsGlobalScope":true},{"version":"3be5a1453daa63e031d266bf342f3943603873d890ab8b9ada95e22389389006","affectsGlobalScope":true},{"version":"17bb1fc99591b00515502d264fa55dc8370c45c5298f4a5c2083557dccba5a2a","affectsGlobalScope":true},{"version":"7ce9f0bde3307ca1f944119f6365f2d776d281a393b576a18a2f2893a2d75c98","affectsGlobalScope":true},{"version":"6a6b173e739a6a99629a8594bfb294cc7329bfb7b227f12e1f7c11bc163b8577","affectsGlobalScope":true},{"version":"81cac4cbc92c0c839c70f8ffb94eb61e2d32dc1c3cf6d95844ca099463cf37ea","affectsGlobalScope":true},{"version":"b0124885ef82641903d232172577f2ceb5d3e60aed4da1153bab4221e1f6dd4e","affectsGlobalScope":true},{"version":"0eb85d6c590b0d577919a79e0084fa1744c1beba6fd0d4e951432fa1ede5510a","affectsGlobalScope":true},{"version":"da233fc1c8a377ba9e0bed690a73c290d843c2c3d23a7bd7ec5cd3d7d73ba1e0","affectsGlobalScope":true},{"version":"d154ea5bb7f7f9001ed9153e876b2d5b8f5c2bb9ec02b3ae0d239ec769f1f2ae","affectsGlobalScope":true},{"version":"bb2d3fb05a1d2ffbca947cc7cbc95d23e1d053d6595391bd325deb265a18d36c","affectsGlobalScope":true},{"version":"c80df75850fea5caa2afe43b9949338ce4e2de086f91713e9af1a06f973872b8","affectsGlobalScope":true},{"version":"9d57b2b5d15838ed094aa9ff1299eecef40b190722eb619bac4616657a05f951","affectsGlobalScope":true},{"version":"6c51b5dd26a2c31dbf37f00cfc32b2aa6a92e19c995aefb5b97a3a64f1ac99de","affectsGlobalScope":true},{"version":"6e7997ef61de3132e4d4b2250e75343f487903ddf5370e7ce33cf1b9db9a63ed","affectsGlobalScope":true},{"version":"2ad234885a4240522efccd77de6c7d99eecf9b4de0914adb9a35c0c22433f993","affectsGlobalScope":true},{"version":"5e5e095c4470c8bab227dbbc61374878ecead104c74ab9960d3adcccfee23205","affectsGlobalScope":true},{"version":"09aa50414b80c023553090e2f53827f007a301bc34b0495bfb2c3c08ab9ad1eb","affectsGlobalScope":true},{"version":"d7f680a43f8cd12a6b6122c07c54ba40952b0c8aa140dcfcf32eb9e6cb028596","affectsGlobalScope":true},{"version":"3787b83e297de7c315d55d4a7c546ae28e5f6c0a361b7a1dcec1f1f50a54ef11","affectsGlobalScope":true},{"version":"e7e8e1d368290e9295ef18ca23f405cf40d5456fa9f20db6373a61ca45f75f40","affectsGlobalScope":true},{"version":"faf0221ae0465363c842ce6aa8a0cbda5d9296940a8e26c86e04cc4081eea21e","affectsGlobalScope":true},{"version":"06393d13ea207a1bfe08ec8d7be562549c5e2da8983f2ee074e00002629d1871","affectsGlobalScope":true},{"version":"2768ef564cfc0689a1b76106c421a2909bdff0acbe87da010785adab80efdd5c","affectsGlobalScope":true},{"version":"b248e32ca52e8f5571390a4142558ae4f203ae2f94d5bac38a3084d529ef4e58","affectsGlobalScope":true},{"version":"52d1bb7ab7a3306fd0375c8bff560feed26ed676a5b0457fa8027b563aecb9a4","affectsGlobalScope":true},"70bbfaec021ac4a0c805374225b55d70887f987df8b8dd7711d79464bb7b4385","869089d60b67219f63e6aca810284c89bae1b384b5cbc7ce64e53d82ad223ed5",{"version":"18338b6a4b920ec7d49b4ffafcbf0fa8a86b4bfd432966efd722dab611157cf4","affectsGlobalScope":true},"62a0875a0397b35a2364f1d401c0ce17975dfa4d47bf6844de858ae04da349f9","ee7491d0318d1fafcba97d5b72b450eb52671570f7a4ecd9e8898d40eaae9472","e3e7d217d89b380c1f34395eadc9289542851b0f0a64007dfe1fb7cf7423d24e","fd79909e93b4d50fd0ed9f3d39ddf8ba0653290bac25c295aac49f6befbd081b","345a9cc2945406f53051cd0e9b51f82e1e53929848eab046fdda91ee8aa7da31","9debe2de883da37a914e5e784a7be54c201b8f1d783822ad6f443ff409a5ea21","dee5d5c5440cda1f3668f11809a5503c30db0476ad117dd450f7ba5a45300e8f","f5e396c1424c391078c866d6f84afe0b4d2f7f85a160b9c756cd63b5b1775d93","5caa6f4fff16066d377d4e254f6c34c16540da3809cd66cd626a303bc33c419f","730d055528bdf12c8524870bb33d237991be9084c57634e56e5d8075f6605e02","75b22c74010ba649de1a1676a4c4b8b5bb4294fecd05089e2094429b16d7840c","e475453e7140e95542332943d3052fe4c7430ad1efce42b3e9157f1fee8cbc5f","ebfdf904255ce746c9d30117c2edef355fb19bf7650478d2405f39f0e4f302e6","f3f63b48addb8e2ea9d20bb671c3c306413b3daa39996d0ae52f63d8e32158e1","a50599c08934a62f11657bdbe0dc929ab66da1b1f09974408fd9a33ec1bb8060","5a20e7d6c630b91be15e9b837853173829d00273197481dc8d3e94df61105a71","8d478048d71cc16f806d4b71b252ecb67c7444ccf4f4b09b29a312712184f859","b4000a0a525fa921e896cbdb32ae802c9684f0fd371b5fc69e7310f7918cc2c3","9df4662ca3dbc2522bc115833ee04faa1afbb4e249a85ef4a0a09c621346bd08","b25d9065cf1c1f537a140bbc508e953ed2262f77134574c432d206ff36f4bdbf","1b103313097041aa9cd705a682c652f08613cb5cf8663321061c0902f845e81c","68ccec8662818911d8a12b8ed028bc5729fb4f1d34793c4701265ba60bc73cf4","5f85b8b79dc4d36af672c035b2beb71545de63a5d60bccbeee64c260941672ab","b3d48529ae61dc27d0bfbfa2cb3e0dff8189644bd155bdf5df1e8e14669f7043","40fe4b689225816b31fe5794c0fbf3534568819709e40295ead998a2bc1ab237","f65b5e33b9ad545a1eebbd6afe857314725ad42aaf069913e33f928ab3e4990a","fb6f2a87beb7fb1f4c2b762d0c76a9459fc91f557231569b0ee21399e22aa13d","31c858dc85996fac4b7fa944e1016d5c72f514930a72357ab5001097bf6511c7","3de30a871b3340be8b679c52aa12f90dd1c8c60874517be58968fdbcc4d79445","6fd985bd31eaf77542625306fb0404d32bff978990f0a06428e5f0b9a3b58109","34693fb4a5e771e11668219221344dd1bd7d8b77ed005a1c1d965fb559be8406","7394959e5a741b185456e1ef5d64599c36c60a323207450991e7a42e08911419",{"version":"e44ea2d6b7b853f6c81482416db43dafc11944561b810e469ae423085511ce7e","affectsGlobalScope":true},"f51b4042a3ac86f1f707500a9768f88d0b0c1fc3f3e45a73333283dea720cdc6",{"version":"a7289d79eb84a59d2475b4d0136b4404be3cfdd17c3ea46b9194add1d645df01","affectsGlobalScope":true},"0bb26fa2a90ee890eed57ee812c71fa84d3d07850163ec4a204de86412cc57c1","132ca47da601c60141dd6f10bd08c70d0620177e5638439df2464ec3945b6d98",{"version":"55d2bbae076fed7269c3e16faeb32f988f558427b7a1c3bf04aa7551ab86ae90","affectsGlobalScope":true},"a40826e8476694e90da94aa008283a7de50d1dafd37beada623863f1901cb7fb","cf83847c9264dcd592b6c89c1542925b899b277228687f3638614e3fa784cf76","3a41ebe7f089d50f447466b35b6cabb8b584c0994fc9809d0cd0a4ebc41e1239","7693b90b3075deaccafd5efb467bf9f2b747a3075be888652ef73e64396d8628","0c42d6cba77d9ad1cf45256ccb8489aa502fe2dbee1ec9048a29d49f5d532e73","2cf89c17245db65d175d4ef699cd68187516f9b3ae5c572fc0b9ad60f35dc223","5f20d20b7607174caf1a6da9141aeb9f2142159ae2410ca30c7a0fccd1d19c99",{"version":"a34d65f61ec5aac5b53502c8b0bd4e00d217bccb95bf94d449e2571baa11fb8c","affectsGlobalScope":true},"8d42e5af5fb0a96a77e135ce84cc60636c9bad39d9dba043a4efe9d1bdeb3cc3","56fcc451e9065eb121c9cc4c1b9994a816306f3b0b3b1fce7ad59f0ac97a9999","8a6f12b74d3e6c4f5e1b918cb8e64ae16bc6756cf0d48bcc28a28e1bf26ca0cd","c3759b5bc5cc40f5988d86a497741a80fa91258629ae50a2b3735e774cd377cc","bf268a0aea37ad4ae3b7a9b58559190b6fc01ea16a31e35cd05817a0a60f895a","45dd82fb5aea9b12b2a90b427b28f3a014e8b2ee9b74087a5ab882841cb5fbc5",{"version":"d7dad6db394a3d9f7b49755e4b610fbf8ed6eb0c9810ae5f1a119f6b5d76de45","affectsGlobalScope":true},"48b2f9302651eb31acd5be69bb4e6b35797a7fcd6b77391d10a4ccadf7dc3609","0c8c917ef15498c827bd494a0ef365e9f76deb211f8acbb86932e20489310788","dd67d2b5e4e8a182a38de8e69fb736945eaa4588e0909c14e01a14bd3cc1fd1e",{"version":"9cdc2c6144b03822c9842505d09945bcf813b86827fdb260dd7586b63abc19bf","affectsGlobalScope":true},{"version":"2923dee3c897f03e91b54a210cdbefea7290562f0ac4b948667d4c9ee844b79e","affectsGlobalScope":true},"79169698d09a2be54b14f3bcad2575b414bf3525063fde0a1e4fcd5d6efd380e","051d939bcf77caa3cef3282708ab3a6fdfb741a7366e1d74a9e7603b67417ec3","0be79b3ff0f16b6c2f9bc8c4cc7097ea417d8d67f8267f7e1eec8e32b548c2ff","1c61ffa3a71b77363b30d19832c269ef62fba787f5610cac7254728d3b69ab2e","a234d62ae81d012ebf23898a45672edf3e5c93ecf5a438a42b96c08dd68cde43","269929a24b2816343a178008ac9ae9248304d92a8ba8e233055e0ed6dbe6ef71","09ed02a725db002693236b6dfc49b2c6eb5557be1421d7fbe4f07cfe38211d92","09d801ff4a303d4976d4b9cb94af3a9097c4a70345e662d176975872d2998e51","c8558b01389b5f7610ac293aa612ccea2ae64d83af43b49f8142f190be1f414c","c40fdf7b2e18df49ce0568e37f0292c12807a0748be79e272745e7216bed2606",{"version":"b10b426c56e220b5093bf8a2446ee47af47263b7b1a03f4b18e42326b231b111","affectsGlobalScope":true},"4e228e78c1e9b0a75c70588d59288f63a6258e8b1fe4a67b0c53fe03461421d9","b4635ef36bee17e1304337d591c3b6b461ecdbc1876d0effbe6a581e62201fe5","205d50c24359ead003dc537b9b65d2a64208dfdffe368f403cf9e0357831db9e","1265fddcd0c68be9d2a3b29805d0280484c961264dd95e0b675f7bd91f777e78",{"version":"e4507242542bd499238f693d88b2d32e22177cc508854625f87bcc9bc3fa1256","affectsGlobalScope":true},{"version":"d942354e4966a98d3a92d1b1af0b4ac06f33af3f88116743e2c304c027ca26ef","affectsGlobalScope":true},"39f0808e5be3cb38674726c21fe2eb453c55e48a901679b4ce30fef85549b892","6afd66a7432ef100027ea110449e874196381e019e30eda7e7d8ca390366b7a8","befb8a9a78ac99d8fbc3ed392810489a7b90760c7a58934e8f1c8538f581cff3","e670bdf01540d35c170fae68edfd2f288eff909936780c379d6a9103b787b22c","867f95abf1df444aab146b19847391fc2f922a55f6a970a27ed8226766cee29f",{"version":"ab9b9a36e5284fd8d3bf2f7d5fcbc60052f25f27e4d20954782099282c60d23e","affectsGlobalScope":true},"88003d9ab15507806f41b120be6d407c1afe566c2f6689ebe3a034dd5ec0c8dc","175323e2a79a6076e0bada8a390d535a3ea817158bf1b1f46e31efca9028a0a2","7a10053aadc19335532a4d02756db4865974fd69bea5439ddcc5bfdf062d9476","4967529644e391115ca5592184d4b63980569adf60ee685f968fd59ab1557188","aed9e712a9b168345362e8f3a949f16c99ca1e05d21328f05735dfdbb24414ef","b04fe6922ed3db93afdbd49cdda8576aa75f744592fceea96fb0d5f32158c4f5","ed8d6c8de90fc2a4faaebc28e91f2469928738efd5208fb75ade0fa607e892b7","d7c52b198d680fe65b1a8d1b001f0173ffa2536ca2e7082431d726ce1f6714cd","c07f251e1c4e415a838e5498380b55cfea94f3513229de292d2aa85ae52fc3e9","0ed401424892d6bf294a5374efe512d6951b54a71e5dd0290c55b6d0d915f6f7","b945be6da6a3616ef3a250bfe223362b1c7c6872e775b0c4d82a1bf7a28ff902","beea49237dd7c7110fabf3c7509919c9cb9da841d847c53cac162dc3479e2f87","0f45f8a529c450d8f394106cc622bff79e44a1716e1ac9c3cc68b43f7ecf65ee","c624ce90b04c27ce4f318ba6330d39bde3d4e306f0f497ce78d4bda5ab8e22ca","9b8253aa5cb2c82d505f72afdbf96e83b15cc6b9a6f4fadbbbab46210d5f1977","86a8f52e4b1ac49155e889376bcfa8528a634c90c27fec65aa0e949f77b740c5","aab5dd41c1e2316cc0b42a7dd15684f8582d5a1d16c0516276a2a8a7d0fecd9c","59948226626ee210045296ba1fc6cb0fe748d1ff613204e08e7157ab6862dee7","ec3e54d8b713c170fdc8110a7e4a6a97513a7ab6b05ac9e1100cb064d2bb7349","43beb30ecb39a603fde4376554887310b0699f25f7f39c5c91e3147b51bb3a26","666b77d7f06f49da114b090a399abbfa66d5b6c01a3fd9dc4f063a52ace28507","31997714a93fbc570f52d47d6a8ebfb021a34a68ea9ba58bbb69cdec9565657e","6032e4262822160128e644de3fc4410bcd7517c2f137525fd2623d2bb23cb0d3","8bd5c9b1016629c144fd228983395b9dbf0676a576716bc3d316cab612c33cd5","2ed90bd3925b23aed8f859ffd0e885250be0424ca2b57e9866dabef152e1d6b7","93f6bd17d92dab9db7897e1430a5aeaa03bcf51623156213d8397710367a76ce","3f62b770a42e8c47c7008726f95aa383e69d97e85e680d237b99fcb0ee601dd8","5b84cfe78028c35c3bb89c042f18bf08d09da11e82d275c378ae4d07d8477e6c","980d21b0081cbf81774083b1e3a46f4bbdcd2b68858df0f66d7fad9c82bc34bc","6a9c5127096b35264eb7cd21b2417bfc1d42cceca9ba4ce2bb0c3410b7816042","93b7325b49dfbf613d940ed0e471216657b2d77459dac34f1b5b1678f08f884c","b17f3bb7d8333479c7e45e5f3d876761b9bca58f97594eca3f6a944fd825e632","3c1f1236cce6d6e0c4e2c1b4371e6f72d7c14842ecd76a98ed0748ee5730c8f3","6d7f58d5ea72d7834946fd7104a734dc7d40661be8b2e1eaced1ddce3268ebaf","4c26222991e6c97d5a8f541d4f2c67585eda9e8b33cf9f52931b098045236e88","277983d414aa99d78655186c3ee1e1c38c302e336aff1d77b47fcdc39d8273fe","47383b45796d525a4039cd22d2840ac55a1ff03a43d027f7f867ba7314a9cf53","6548773b3abbc18de29176c2141f766d4e437e40596ee480447abf83575445ad","6ddd27af0436ce59dd4c1896e2bfdb2bdb2529847d078b83ce67a144dff05491","816264799aef3fd5a09a3b6c25217d5ec26a9dfc7465eac7d6073bcdc7d88f3f","4df0891b133884cd9ed752d31c7d0ec0a09234e9ed5394abffd3c660761598db","b603b62d3dcd31ef757dc7339b4fa8acdbca318b0fb9ac485f9a1351955615f9","e642bd47b75ad6b53cbf0dfd7ddfa0f120bd10193f0c58ec37d87b59bf604aca","be90b24d2ee6f875ce3aaa482e7c41a54278856b03d04212681c4032df62baf9","78f5ff400b3cb37e7b90eef1ff311253ed31c8cb66505e9828fad099bffde021","372c47090e1131305d163469a895ff2938f33fa73aad988df31cd31743f9efb6","71c67dc6987bdbd5599353f90009ff825dd7db0450ef9a0aee5bb0c574d18512","6f12403b5eca6ae7ca8e3efe3eeb9c683b06ce3e3844ccfd04098d83cd7e4957","282c535df88175d64d9df4550d2fd1176fd940c1c6822f1e7584003237f179d3","c3a4752cf103e4c6034d5bd449c8f9d5e7b352d22a5f8f9a41a8efb11646f9c2","11a9e38611ac3c77c74240c58b6bd64a0032128b29354e999650f1de1e034b1c","4ed103ca6fff9cb244f7c4b86d1eb28ce8069c32db720784329946731badb5bb","d738f282842970e058672663311c6875482ee36607c88b98ffb6604fba99cb2a","ec859cd8226aa623e41bbb47c249a55ee16dc1b8647359585244d57d3a5ed0c7","8891c6e959d253a66434ff5dc9ae46058fb3493e84b4ca39f710ef2d350656b1","c4463cf02535444dcbc3e67ecd29f1972490f74e49957d6fd4282a1013796ba6","0cb0a957ff02de0b25fd0f3f37130ca7f22d1e0dea256569c714c1f73c6791f8","2f5075dc512d51786b1ba3b1696565641dfaae3ac854f5f13d61fa12ef81a47e","ca3353cc82b1981f0d25d71d7432d583a6ef882ccdea82d65fbe49af37be51cb","50679a8e27aacf72f8c40bcab15d7ef5e83494089b4726b83eec4554344d5cdc","45351e0d51780b6f4088277a4457b9879506ee2720a887de232df0f1efcb33d8","5d697a4b315cc5bb3042ae869abffd10c3b0d7b182cda0e4c45d8819937e5796","563fa27fdaec8f195b84f71a7af0ef48d30d5cc830575db86da86a63a470c8e6","6ee58aa536dabb19b09bc036f1abe83feb51e13d63b23d30b2d0631a2de99b8f","8aceb205dcc6f814ad99635baf1e40b6e01d06d3fe27b72fd766c6d0b8c0c600","299567f84bfedd1468dca2755a829cb19e607a6811673788807dc8921e211bc9","795d9fb85aad92221504db74dd179b506bd189bba0c104426f7e7bb8a66ffee5","1311bc194e0a69fe61031e852c1c0b439e2a2a3d1d5e2d8ff795499b9f283459","4b7ce19369d7e7fae76720c2c6c7f671bf3fa0f7093edb864f1ac358ca7c456c","c972ef44deca1fa8fab465915ffa00f82e126aacf3dfc8979c03b1b066ce5bb6","30285a1011c6d6b52f3ba3abb0a984be8148c05cdefb8eb6eb562335a3991f35","8e7adb22c0adecf7464861fc58ae3fc617b41ffbd70c97aa8493dc0966a82273","755f3cd1d9c1b564cff090e3b0e29200ae55690a91b87cb9e7a64c2dbeb314d3","d6bb7e0a6877b7856c183bff13d09dd9ae599ea43c6f6b33d3d5f72a830ed460","f1b51ae93c762d7c43f559933cd4842dd870367e8d92e90704ffa685dd5b29a3","3f450762fd7c34ed545e738abccb0af6a703572a10521643cf8fc88e3724c99c","fcc8beef29f39f09b1d9c9f99c42f9fed605ab1c28d2a630185f732b9ba53763","d6e6620a30d582182acc3f0a992a0c311adc589f111096aea11ab83fc09a5ccc","6213b8f686f56beab22b59a0f468590fd3a4c5fa931236a017efeca91d7c9584","c451cec9a588b1f105a5ea2c6063d4fca112b9d70105cacdadda0e1ef67e9379","cb047832dc68f5a2c41c62c5e95ddcacbae3a8b034d40cd15319a8cb7f25104a","980336ccdfc3c08f3c3b201aa6662e6016e20f15847f8465b68f3e8e67b4665c","5a3493939995f46ff3d9073cd534fb8961c3bf4e08c71db27066ff03d906dea8","bb5a2ac327605ebebf831c469b05bd34a33a6a46ee8c1edd9f3310aad32cf6a1","bf5d041f2440b4a9391e2b5eb3b8d94cbf1e3b8ff4703b6539d4e65e758c8f37","8516469eb90e723b0eb03df1be098f7e6a4709f6f48fd4532868d20a0a934f6e","d60e9ab369a72d234aac49adbe2900d8ef1408a6ea4db552cf2a48c9d8d6a1bc","0ebb4698803f01e2e7df6acce572fff068f4a20c47221721dafd70a27e372831","a12eaa942232703a8a8477a2f240ad5a2c26c595012ea8f128224e77984099c4","4070c2f1c3434fcf84886e04d30d82cd650ee443e53b82b404b144175cf8741e","2cea9689efa8591732096235abe7f084fc29c92badd5b0897a5e876b77e71887","4ed4e504126014fee13aaef5e3fc140f2ff7031ff3a8b5386717905820ea2d09","8129a34006218a6f3cdc81bbd438d5429eb18b08b4338a26977ac3b4df129d75","30d2170e1a718b5035611af55e3618b4ba8f42f0749bb52ee593da6082c4e2ce","eee8bf8781733667d3d472bb48a0af62eaa2581609db03805d89a7fefbab56a2","a3b8b6be7620897d1e481e8650c980a210a138fceb6e710eaf95fd9dd0dfe94a","12c89d0e32758c120a569045f21cf5b77244f86792611ced8de7f86b37e77781","14bd47270e654c8eb3b1489fa8c095912ee62a0a29bb92743393203722347c53","4b9eaf9966b8ab466e4e0c9d76ec576abf9a48786c573d815a265f39a24f19fe","be090416e1845443f44d338247cfcc4f83ea61faf6ceb9f1f91e2653eba04400","92cb686a9ca5eb5dd7d5d8d43a3707194c1e91ea07a027b3bcb60b6011b24632","8e609bb71c20b858c77f0e9f90bb1319db8477b13f9f965f1a1e18524bf50881","25139d6a726e0e19d9fc4fa3197367b4a82ec34a08a5ecf23963e142c202c0f3","e3328bffc8eab74665a4fe9c59d6f12f4c8570c3d858497e241eb37efe17dfcf","29389551e426a46421134b55182d6fcf5b143670998bf81db2619c1228235392","c18f7e16982695bdd04e3e183a327d116185f77f1a37b9b2e849d7d93269cd74","2cfb37011989c21dc70b91d521a2d5a4e0f18507f5f536b5dfe504edb15916e8","bb5e02df7aaec7a4ea642639a9963b24b8d9fd6798351f07d8c58616942fbcbf","299a899cb4d061f5d83843ec453e936e9659b2c435746823f90c40eddaef4745","d5610c0fd12870f644b0f42c1bcc4fa2295ac3e3ca01916bdb42c3bdc4c80c36","2c56a8e249b1f45dbdf973100cd37fe2ea68709573cf1fdf2e3052c593be68d8","3553da417ee7b07e388b13bd12a70a1c03e65a6132ba5427fe68f5b362373e6f","612358502042d351c227ba779fdcf6d875d827e424930e60297c533524e50668","d2b5be376ef162aa0c24a826e7dd2d77671a045c085e16d1c1276db4bdccbac7","c4138d8dcccedaff6621e009cf0a54a7bed2a5ad4c509a3513bccc4f417ef939","ad8747fe978dff3e80f4b12b48d37cc8dff11b61d04c035aefbc982ce21201ce","b154f789fd65298e1ba6cbba6944ea892d564c95f3d3700ed85baf8f80748473","c660265aedd7c5b236e2017e53095cb98da66200eb0e8d023b5bf713c36494e8","0efc36bf5c0daca6217fec7063359ccdab8c3a23bb405d25340fae22cf72d74f","5abff0c87d4f9c89715107042d4c73b68ef7a128759f451c8a0fc450cbaaf660","5a03308fbd1af441065149a84c692931bebc7e7735afc23be8684f4e10d3aa06","c787bf4f8f0abbf815cfbd348be41046f2b8f270be24fe7aa8a8fcdd2b7df8c2","e7a5191c663a3228f30104961d548b372e51c5936c01ffc8eddd262bb98d7d7c","43fdc9abe6f8640fda4cdc55a1ee5f666d3fce554277043df925c383137ddf69","f0b09665c9d52de465687fbd3cfb65111d3ffc59ae00c6f42654150f3db05518","72f8c078d06cff690e24ff2b0e118a9de2833dcebf7c53e762dcb505ddf36a68","b7d190f58039b13408eba5edd7fc3305fa1b8f10f3cd90087bf21fcba33a8565","f9b9d0950fdfb90f57e3f045fe73dce7fa6e7921b37622fc12e64fcd90afbd0f","e61b36e7fde608f8bb4b9c973d81556553a715eaef42a181a16ddd7a28da4ac7","03b8389b222af729eae0fb3c33366dcbb1f5a0102ce319bf1d7d5ee987e59fd0","2bf6be7c04db280fdd9b786764f8650c23f9f4d533791cb25a11b25314b76a55","dbb5fc7edd36bfba95cc4dd564e4458276ced30eed18bc05fbda948b3fda8686","c2b556c7cff0dabce2e31cb373ac61c14d8ebc35f1086dff30b39e9ec5357d0d","f958af01131076e8af55d28c4835a51063226ab488ca8738fdee38aeef7d0d33","9f3797b01e3d83d4e4b875699ae984f380ca86aa0a0c9df43ac5bba1cb1f8b7b","752b15ad1b34887adeaa838fc55f5d4ca399026afd266d4ed4db0e3db02eae4e","778331eaea1093451e50be9844bd2b6937c3bb81b0b1ee700624c9774ecfcf2b","0ca0dfc9f657d0822eca9530c7870b22a1d2a5fc48182bdd4d0e6e88e4ad9c35","5c746f034288e6842dd1589b169dcfcc16c5ce5abbd928889ab67aea4fe0b501","92ce6dbbcc135cffd09a58e19fef34bf351391bec92c40d849e4e9997d475769","99e77d092fed72b6b8578d00c7af004f76e98b30ba99f1947535eb4c04a51676","fcc8beef29f39f09b1d9c9f99c42f9fed605ab1c28d2a630185f732b9ba53763","b5ef52a9f9083724decc5d060f0b34e3a480deed71c32d55ca16c214eb4cc928","5c9cadb9446d1868615558eda1fbf64df5b4fae5ef051d0d7ead6fd28544e3bd","ed7f49215f59f3f514efd4e6ffbdd66cc87d7ce03177e98d17416f34f32cc52c","f100912a3785eed4a3d29c12f5910b101af9353454de5ddba9b4d43456c56dd1","f0ae57a70e4297198722b8e777c7f738a797c4ee1485ab0afa6601f4a7160933","98034cd285344125f7165a3bb68246d38ab35fabe7f6d6a7c8f80407d31f548d","0ca0dfc9f657d0822eca9530c7870b22a1d2a5fc48182bdd4d0e6e88e4ad9c35","06b4a23064991251512df4edc12341d5bc69a17b942da18372312d383c90eee7","0f898802705f9a534b537f1be6c57265080e0abd6993d935554c255e6d56cc1a","745efa7b6e27b7216cccede166a822b56acc41b10a8090966c8cf2c96239cb83","6ab2a6257ae7bb05559841100c786c845fe465a90be7b904db9096c2fb14696b","50aa290ee8f3ba75c7a3653613ead6594e2e034a7627b249c9a400858cac79f5","c9f26fa63b17f3581e7cbcd68e6cf66e6f3e59feb91f6b54757d41355ddacbe5","6a8649609161e2794b383ba275b0a6cb4a072dde7b954648f83dc6cdf1bfe4a8","601d4a40a69c782addaf84185d4547568ec072095ab9976610d89922d1291f8b","d5c19655468e29f60c871b21e73af8ebc653f736e7123ade916f22c4a5f80ce5","55bdc187765b1f5006234e7bf15f911689a5119dcd02be11a798ecaf59d2b3d7","24b3bc595939a193945e81f7e34f4bcfc7efbd133e249878f82aae47a7c89694","85052c71d72b9b017c88179f57a464d66e22619c7acd7d83b117a79cf1608979","eaca2afa1bea4de1d06e0a388415bfdc142f784d709011964ac31aa65948d578","6d3101b183ea67ef606b93fe42127f30b2db5ac3b72c34ca9d6d8b00eb85d0f6","f5d7a36ff056cc314b0f61c89a03c4c36a24183b246e61d958e75e86521304cd","a3a497437625850c31a84c043b128740dd6d9991fa591e1809aa7b65f9056b9f","6c951235cbf3c324a20c0e2dfdd013d7b226b0c2a72dbd84925682a8d7199237","786c21e23b9ec59e984e24ea9bb2e5fcada9df7c7795ace4e00442172a9e9ecf","3a971ea3e36685b96f24fbd53a94ad8dc061711b84e51fde4cf201f7041e618d","9b6c162d20e2ad4abdcff61a24082564ac59e63092220618162aef6e440c9228","b0874729266d9f7fafb9ff1127fcbad2cf7972b5dcc1fdc104be79266a708bc2","e833ded303809728b25b45929e6e8d00dbc022dffde04fe751769df33eec2699","b2721e335ce1628f2785998a96f36e6b00a767199bc1d19e716861a5f0f45768",{"version":"801934aa449fe6df584bccdcc5d5b9280295cb7ac84918b6014fc5086e6f9ff6","affectsGlobalScope":true},"5e379df3d61561c2ed7789b5995b9ba2143bbba21a905e2381e16efe7d1fa424","f07a137bbe2de7a122c37bfea00e761975fb264c49f18003d398d71b3fb35a5f","2b7fc7318f5cd3e70f0ee1342bafb95cb60ee0beaf5d0929f59c704ff6c8877a","c62c4ba5e910b4523f7e7adf4a55ec45c2bac99d9d8e9b0fe0c2a800a6f641b9","2845be5c74adbf73439e0aef6ea2dddf3cf202d0f5afc3708dfbfafdb86b6acd","8cf023c0bd57992fdd2ce6a7030a1874f49c8edc62eaffa9bfffcf18d2a2a1a2","8ea8f3040e38fb50d7dc3653f3b8a0dbb5244e82111576f99ce096bdc0fbf94c","48ed788ad126545a6156fcc37cd3bcf17de18a3e3fe6b6ef62cfb8140d1a45a2","63c271a745f628ffd4bd7ad0a63b021c362c9bd6bf8b18441a7162892395a214","a867ba47f71fe3993cef54246893ff8f01411e12e411d8cf1bd038a448b36404","9f9e5bae412fa5909fae636d6733aee27a108cc2ed5b13980611016336774d3c","662fe197bba64bd3f17ee118058cd2d0d2dbe33d7c0c865fd6365d90bfc44e1e","030519c351f800551cac2658038804969ca4584d2c0175a710602ac234ca1340","0278a6939ca83cd040b08ff8c5fc7838b6693ddc52f22526bf158e6b10e0246c","c2d6206e5ba4fd3063b01218c2b3b997afc1cfbeb49fcee991fa8595842ce53d","6a8096993458a3d71229031aa7415974eb5b47b320213e29660adfb519d6a3f4","cb7996a1af5b1d276483cd0c9b9de6540eff021abc90a720511ff4464519a2ff","9df6ec68878d65bc690ea3a33ce3ef5aa8254c36bc5f8346c0c2fd1f3b88a35c","a4fad04c4acc8a4b195cbbccef4c55019104753d547d5c94441643ccc89108a0","0244c23ea642361f7c192c1f0cfff9c12cfa5f51f9b155edd5c0a89fef308d34","6548ab4b57eb9d092471a04513091673345f2fd95d5b876f600402ea8d603ee0","fe1e3bdc462ec1f6f49ccba12526577b1a3d21811c79b58faa7f229374828fd3","d0f11e830aa1350a31d9c00a0197243e9711e4882947aef53a96c629f405cb10","66a0a22b136711f411de6ad562edd8e1bcc9da32363537ec6f33a57afb1ed9b6","aee675bf4b257b67624c9007f7d8eb2e3007a9318bd27e8df4b6c133dccc7d5a","334e40b3530b0d92518444b2a0b2608b7988c7132febc93e04ca9c15d0e8a058","9b6aaeafd7d5c93f3eacc9ef727fd64dfd75a63274e5137f6ce182eee60cca71","6bb747ac019210ef62125c2f0f0f4129010c765e556f4ce072aa0fadc86542d2","99e1bb2aca37fd9d6b86d517896e05eba415987dd84610a2789514c0d93502f4","9a63cbcff42116cfd1b08fec44bce9dec6ee31aa549ff4b2e443f87bb6cdffda","65c506882b16993f4870c2d73fb48b6d34b7d91d73acc6cacc3307e99bec42bf","9aff8604f50c9ea7d547330c1d168a6eb3d53d65a1600701c4741241571b9e13","0678e68e3e976e5d3fbb7baabd63384a7f418f2bae941266c2e3fccd7010ca12","779805755635c2da3c6d52f0801c33ff8c48c4f14071d48acfae117f80abd1ac","915fec4d3d928e869bd8ded5443b4b1111719b2df43da11c32df79af0350eb27","dbcd1e6a411ad34dc94931d79df68c286ed932e17a504463aaf95f7e04f30ca8","080b1aa93227952b4dd74b9d2c6e4f6002eb8403533749116a1c53bb9961c02d","874087eec1d457f6e3baf5ac46c42ea200e55040b394fac667aa3a64c49f5f6c","0d18f7c85d38358bede081a0b7f4292e15a800a3d2195de0a3ac5956d2481e19","6610b9f45f1f71d2b1fb67df49cbcabe3f9e668a1ccb7d8328a51407b259ffb3","2785698f900fdfedd9c81879b7741d263c6d5853164aa5c214a280e633bba9d4","a1d8da0e8e6d3a85899f13ff11b2fa1f0d3539d26133dcebae1cd6daec39a8a7","8952dd3e4ad7e445743358eb0630e70dc6bdc3c06598a0fd4bf360e959a77c55","a22a9669b2d3c24bb7ccf110e1bc5c980dfcfea9f8ac4719382223843e8a032b","e6f6440893f51adcf17b8498224004a65448828e1d95f2a06244a34a7525ccae","193f3eeb12d0c70404fddd0d6c6d395a6721320284d0d4d39e0538e47ac6931e","ab408226026bb8f267f4b7578d9c853db182cd1a4e4a05cdbc4cc36103075142","a7d992c4e10ca67ded5ea1bd4b974a87bc5395b2f51ac038e89c09aa2c9b1ddc","a85b317beb9f4b26f5c25fdaf03d925f9545fadb3679d1366324e9212b416b96","e5423640cf93ef900af69ac6b4efdbe339b0b332d15ed5f0ac15209c5fd86b50","eaec27135176a532508108c395b02e36658b861398d67b071790a0cddd5f595f","a4a3de26bc39d380e4021163f89f4b2fbf82f2a712b010efac1698bfd8c288ce","21b3d5e502c3c1eed625d13559db2a8df2ccd4f9e15185b158d5de392153db2d","2ba6ea7729eb2976f3397e6c9f381796fbc458fc01b076c357210ec2cbbc5b99","417692489d8e511510cf1268f89374466d7ef8d9edb085adbacc7756ffceed73","963a49f6949886df3d3d3dffef6ac3dab5f33704b918edb519ea3c063ba8eb35","7bd08ed4a983c57145375265be7d27b8ee27adf462c10c3d328a993ca89d9e19","970b722b55e730c9a4f78633f83c7c7769920293e2dfd45a58452bfe3486c63e","6e795e6270d39e918c7a0e62ac73793cda06fcf4b3692ee46583e15f5bf57ab8","ddd8ba285f28cfceb77fbe36c45a51ed00b2ed41f29a26a77b73d403d82b87ec","5c09195ef359ffa9c6bbdb4fefb101d87ede4b9e9c28213faf5b45d102e4c609","80b4d93a4dcc90a12f6f4bb7c6851a8182ae29e556716d0d80b5c012a5ef554a","2556ef9d1820e0b6bbca6dd65a50ea64f525c4d8247ab50dff44c3f0d14a5643","cbd1c836db190d6e3add07165afc228f04e1f6170e1fe3aa5e6fc24a7e9573a3","9b13881feb958237232586d888a10a39d47cdffe3ee34688ed41888fa7baad94","122fe82cf5af80f0b26832b258b537b7dfe3ec28449c301b259ab10204b50d45","b1d4e95f74b44961c24ab656a9e18a8b048748d0ed0dac69c72f42128f1e6331","d74d2a92b54f95e47d2b76bd5ee516aab7ae93afb79cd34c6681dd29eb09e72a","747e6326a724bc54f799a466a5b5c4978a601a04a063a5bdabe150af2f25b9e2","b57e22e53b56cca7a57bfcfb234aa6a66f9b9e4c07159d7388f94f17a3eaee2c","e47709ec4d1618ef429648cd8ef967aef2005526b34fcbfac33037add347dc71","b81abb3e47fbbb3af41fa75bada89bbcfa4b0feed9a0d6d4b19ed1ce1033b53c","15b330546e9784461058e5fd6e2346bf272140fa6f0cda34e193ae501d8b17b1","4d8ce72fd080bf9a46bdcc274bcbacccedd66d84e203966b197ac25a96932183","73327e6ae34e3f6591877fb75b451cf620cbbd76ee2b678213a9f793633cd0d3","3f1ba2f69944fa346789db7f60d53c9bec00032de0d797967978dea42e77b941","3f5df31539fee4816b97d4e45b4344fbdaf3ca59f6df941f8d780ee441e92cc1","48e6290931da300900f1c3aa9c5894406a885d80e6e196c17f923a11a58a39b6","3857c1773b8503c3ca45b7bc09ac89c3930c85ce93021054503f73d5d9101b5c","72702bd07fd6fb3ef64aadbcb909103aadfe71ee76e9fdeb11e0c92693cff6cb","f0dd6f7c9783637655478db7d7caf6becd41a79d54482aa59578ce88ab38e9bf",{"version":"cd756ccdabf433dd02b84d755383e489f14b3c1aede0477783aa04830fd5d695","affectsGlobalScope":true},"a4c88dbecdf8ee0c79f5b7c2bf31cd77e593f5d78384e2b674f67d754a549a9e","9cbdff04326da794ba008c0fc977ab062d1fe3fa2e9759654c72ffbe54b64a7c","706233548b0f0e1574d7894bf34f9117f74681ecc35e4b66804f3260020bd6c7","150855f967a6490161d5aeed4cc4adf31fcb8f5dbe54b75799c12b8687fc9cc2","cf08b7139adc21b94204e3d4b3daf9946e3462a9e3fdc3e94c87e767e7936e20","47ddb601df40bfa01cebdd06ee8b87d0b72aa1259a4ceba3ad3b5cf68130112a","6b6392704ddb3f50e647dbbb716782bdd0cf8ea9cc134aae256a26223e632b47","da7959ca32b26af48c58c5f15a96125601bd38158382e14f67c5996bae6e561e","df90b0c6b1d81851364c4d97fa23b91a993482bcf4a7bed7c7a24aa41632d494","03c0bc80f67c6f75b02341fbeb9f6ee92c66b90597729377f478885e6ad15a88","11ee9ab699b4619d217c640d917ca198f58066a86bd58c2917197d62aa6601e0","cf9d589d9e73bf32c8e7a6cae6b4a1cf9bef39e5594072533fdce985581a6ddc","abbcc437e0792ab2fe08797ceca1ec85a95ec413c51612313b18ab8e75f690f6","e29d76ef1183ac0edf94b4712b6e51730c447c7e773e75ceb44a720b0c9a9fd9","a8f3ebc21132b1f4d2ce58c8952ba455ae891422a9ea46c6802ad13b10c6c1f6","c28258d89be3eca9d052a3689714f261722a47e2b22e891549ea7cd4e19f3b37","96f0d856b66d8af1242dea20c5eb182aaaa74be74b7fc6be91bcb5f6c16e405f","4749d39670f618849b640148c8164b52283b4a3be227f192a431fbf132d9d7c1","b682db93a241da3a145e40b75bff4e5f454c74bbb44af7cff2884847294f2ddb","53c7854f35e1d3fab9f0e95d7f7c70777a9f95e121d980269f17ae7d26b5fcce","960fccfbc730994718317411e9f75dac992f48d1645fbedb177f77bd4ee5eea4","2e28c01ab28f1c6d97e47def32e3df6a36c3848dd21520fff899b5c79b286659","8e0541de186545feaeb85671c27763206f0ac9a23b45c84acc6605a15ed64197","d42c6e985bdb10a2aaa3dae14d9b0d8589e74a7c2f9475bf543b855bb3c010ba","be11d1fd9568724e5fc8f6801bc7f92408cb6dc726c58782b4ebcda150bbca64","5cd6db16600b1b35aeabc394266dd1205d1fa8e0e826efd36fbe3b085758bc14","4b1b0fb8836d0f01909626e3e1b6542fb7a2e69f1a269ef5b676abcbae5770b5","72e7be5040a865e113cf78e17eba90499c44607a6a59d0d9b6f843369167523c","0d2acd3a3840418f280e10b2adc0154848f4a162ab6a6466cbf5d0210200a6f8","08417035838838db86f31bd576b1fe246be76c1507b8fc1f2eec744c0d0d125e","b78647f4fd09671f9e7502612cf5f0c072ab2ec917312810d36927fcdeeb5a7c","d6b58d955981bc1742501b792f1ab9f4cba0c4611f28dcf1c99376c1c33c9f9c","0cb9cfa126435d30332ff00441e0db904e55dccb5b1fa7220eaf024e7f425eeb","675e702f2032766a91eeadee64f51014c64688525da99dccd8178f0c599f13a8","458111fc89d11d2151277c822dfdc1a28fa5b6b2493cf942e37d4cd0a6ee5f22","19c816167e076e7c24f074389c6cf3ed87bdbb917d1ea439ca281f9d26db2439","187119ff4f9553676a884e296089e131e8cc01691c546273b1d0089c3533ce42","febf0b2de54781102b00f61653b21377390a048fbf5262718c91860d11ff34a6","98f9d826db9cd99d27a01a59ee5f22863df00ccf1aaf43e1d7db80ebf716f7c3","0aaef8cded245bf5036a7a40b65622dd6c4da71f7a35343112edbe112b348a1e","00baffbe8a2f2e4875367479489b5d43b5fc1429ecb4a4cc98cfc3009095f52a","dcd91d3b697cb650b95db5471189b99815af5db2a1cd28760f91e0b12ede8ed5","3c92b6dfd43cc1c2485d9eba5ff0b74a19bb8725b692773ef1d66dac48cda4bd","3cf0d343c2276842a5b617f22ba82af6322c7cfe8bb52238ffc0c491a3c21019","df996e25faa505f85aeb294d15ebe61b399cf1d1e49959cdfaf2cc0815c203f9",{"version":"f2eff8704452659641164876c1ef0df4174659ce7311b0665798ea3f556fa9ad","affectsGlobalScope":true},{"version":"27c33fb4f509b29317686c6ff123aba92074ff6c7bc4c36aaa5ce02e39aa5880","signature":"b3df1401040a165c0422c12ebb1f1b6804b6e474926e5cdc7a5883a56015ed5f"},"1fcb8b15db812281d69a3090d488903f9e93033004aef9d8889ca3ad0753a96f","bdf5a95eb0a2dd1d39805bdf51b46ba012bb9b92b2ddaae16219595bba7678a5","9f794a0e8550a03baff865a3961cc22afbd85bc4ba9672bdda036971928f85f4","66a697d1e4cdbf25cdce4644a8085a8563041fa8c7731d4d9f5e8f22e66ba72c","a0c8e17f4d1ea2704c62d7349bc3b8d9a12e3761b5960cb44144d3f0333b3fcb","3471c0df3d0391e1dffe6e8bf150294531b2b71a2afa5f2b86e52bf84a5db60a","5d4df4de055eddf3187094f938a640f8d96e4c551a47d6686596fdb6ba4c3014","8bc2cad630da1033c1fd8d7df2bffb18af0da6113bd086a8bbec04a2471a1e00","a1059d1bbc8ad46bfe668b8450e7e8002887c4ab987bdb96d6108d8023f8bb8f","5134885e9648e2c6745f8aa1c3e7f5ab3b3617258b3d81ca02de6655ede3d74e","4f1ae3f24125216cf07c5211a3f00d2bb4782d7cc76c0681603f8249f9232ff0","d3fb92a5640f83f7844d60b35317a0f95c27e3658a749d76d218c461ad091668","d1f8bfcd91b284657ef8187c55ace7db91a3c43e642c3f14e54364154932f7e4","f54c92bfcae54f360fe79514746efce4870e4ddabc064e95d406bba291e9f672","175fd7186fa6a70f9db9b270a04a503cae23cf01cb77e3905bac115c38424cf7","c993f7ed1b8e1023c1f2ee5b262dbc3b70b27475674e40a53a58591f9972dacc","c914014ab7c7001178663f29d31a495398234a41219af61f26d7e8e91b46af96","277afd6ab6ec72889e2988e0ddd7d138c1f512e68a1fa4e90eedfd71e2097a51","c0908f85f2b645d375127a3b53a17a65f782e17962d5c1eb68f08b1188acbf15","3fadac5d409cc2f27b1d2f4e7568600f02840205f301c9ae7a3068b46476438b","da6aae64ad559286830fd44c81e3d33303348f184af7db4fde8dd99ae9749407","3633f87c97d359cb55fa7bf0668fb2be8a23342951af6ec2d06e6d0cf7409371","cc3a5427d44fc77ff25e80b3edee4650a51f83de761faf5e633994ecf1ab1b44","b350eda75c6e47299b36002b31d5b220c405c21c365e708989829db013fadbb4","f421882756b6714834ae4687ab1aeadf344a1cc45437d2edffbac020ff3801c1","1d61d6ad832dabafbf63b86c5a79d704f2c8763ada9318e135b17a3cb2d09b32","e5cef5de3e5ad3436d414d20743231e284733b9cf4375dc79eff4fcca4282f99","e624419ba84e33e661e89a28083119ca41f6953dba09a4f82b660684087afe6d","942be430bd0feaced2e3e598273b17e50ea565ec9dac840b580b0b99e1a3cd5c","73350006cec5a0c6b71d53b0b0ddbfb82be96752a9c4e3c904c59e633bc9485e","a7df5c2e9594966c7e0d4a763b13ed5727506d892669df5f7bc9826f539c1d35","258cc5cd6891f6bcbaccefd953997038844e7f65d582cac987ffabf7181bcd4c","00a6db28fc4df6ddf10adbe630d9df620ec13af19039c1869653e60dafa739d2","649324d5abb5464aabe35d86cd0eef16562df811f0971481cee664afa5acbc88","930446bf32192f698b78f8ea4b309d8c2cfe02ab5ad78e4db907417405ebf5e7","5d3e07dbeabff37885262d9b4bd21c3185d95a09a268ab795f81135046a32bf4","7d309fbde13b5e30eff77c07a28b66451b0b50b83564d0cfa6a2a52c8b69aae6","f02da9dd36d7a9aa33c9b2e37ef1f54b0d9ad6a713bae372ae4b72890e40c168","29c188a2c660f99f1b4835022e011c4268d7af989d4b7dda33c0a69ca1a777f8","1ed0bf138e87912d741e28333b58cbf814ae863783b3b404d2454cbabb9c5fc0","3452ee7d8ef0b1bbd47b2a56924a1dc3c79dc84a19d212e9dc496f92e4943aa0","fab58e600970e66547644a44bc9918e3223aa2cbd9e8763cec004b2cfb48827e",{"version":"5943b853fbb3d54c14caf7190a70811ece9a04fd48a0a9f9694078ad9be5cd03","signature":"71e2431e82504b51217a255925d20a8758ad61230024650112b6d925e613b131"},{"version":"27b94a3360811c00d31465d0a7d933fa99b8cfc35c7171c22b7ededf7365743f","signature":"7647ca5b6dceccb21afdc7a2e235e039d263ad63a7755615475acde462191303"},{"version":"f63d139447816964edf9953fdb7e51fd42234356d0a963351c4438c01d8cd456","signature":"23912738b0aa7c07ac7a586ae47a5945a4954f42a8cb03da6bc8e2150ee3017a"},{"version":"a3dcfe57f16e3d01b7ca96290d7ca9ca2870b177a2d76a3673ce7017e181d031","signature":"88299bffcc7f4eee130d15c2af8935f051cf9c3a5c4e0b6f7f698a63077a4383"},"da04ea3f901991d8097ac63ef6fb5967726e3dc1924e2c8efef374b1db9487c6","96c42cfe5614d9f894078048dda1b53409774bd502d584ffa9bee3c1b39537fc","a49dd2c42f34a0f8fd8577340378112785f3a8fa44c5fe6522466421c68f66f2","7a3e0d544a45a2801f7b657fb931e5ceb749cac766560a4cde600c171b41079f","78edf86617005dfa5709c44024989d60398a21bbf865574680e0cdb29e93b88b","0dd44432ff360867ec9422c184e78973fec749dc96920c23aa02088a908cb0cd","06b1afe677e95808681e5260e9f567815e67c59d00eb5de7d21e4754581deb8c","58b3270f2e1111859e0f15c74d2a47b45471a6cda53bb61fadf2d17987ff4c0e","ff6139ad0ecc332393c72a42af66734c3104f775ceeb7af4533fd82df42dfa51","12597a7bb3fa105568418303af2376061d15f57f2d5f24059082043b358dee74","4c2291243804f0e8610c1f05f0d2a3c5a1497e34bf6314378a0857cd42472680","d2e012a1efa7115c2857284eb541e8b906c0d24c5918568e6dd77e2d6a9592f7","99d74aabcb821273945c9f8446f52b9fb27f666d7ee5b00b4814fc29ce72f307","3f1af437818017218c9a8afd6404d25ddb811482952a18c703acbf0889e5d5a4","f7478db71332be7f074506a83b8bd76d52569e022256c2088b27204f1b3b2f22","d4e4c606f38b8a083af300a9011d3bdf77dd63a5a98f05f1566dd84539df6562","e33dedae6123556e3052e6102b2bd64a3c99850b1eb21e27eaed328ccda6f611","391e793b760e7a3e504784021eab7b430a24a87821ad86ea1ae2da88fd2a413a","1356a2fbd07d5f9a5530f9658342bce4f0358f1620f0bba7a923f842ad8d0600","d2c0337f150e9d23259a20d6a6b1db9173f0171162adbd7c42b9a10d53b086b1","54586daaf9e77f8a26b27a4e3cb191f668c54abe9a402c2ce4be19c0b9d95207","95a276eeed4301374463a1725f4bd6a339a6e9dde5ba51910a17f65f8d0c2414","2094effba5caec56950d079ee0c08e175f38dd205d06a877e86cd4bf864fefa1","8c054d37f059c24bb3cc0f1a828009185ff690af19b5c68946074144f8c11904",{"version":"01edba9a90b7a79f2aa7099f7b66405a94d93fe9179e2de15728c1a775415769","signature":"1991a87fd9ce6a724003881138ca1320d26a5faffd436a5cf097d0c5ac8a47a9"},"53f6d74dbd78f08ed7b56f6b0a558b7f8d201852ebcde17e7a0be8816abafff2",{"version":"e70b434f94e9577074497973d65bfc8c940ee6b0cfd8869489bc701759c29f28","signature":"f1d217f36dbd97aaa1014006113535b447cce411dae240062350ffb9f8435b9e"},"14c94f7888c75007a94132f03caef0f6b58bcb136c2994213fd2d3b99f3d7f85","4695042a55a75a6c62dc57f2efe60ef3c7bbe19adedb5081f6e51dd664bbc3f7","b006ad8d854471e7a270bd8918508090961bdc1cfe77ed51f13f471fe682acac","310901df1081433ff7c3b7918496cabb92ded208b04294d3d2bd35acae2de836","c8646410cd2a6bf05eb7e7a51c881776410d07fd5d8f75092a2c815c9c6fda52","37a4a7a5aef4e6a9c652e636aefeef0df9a1cddc24d94dc00a32401a9c9cf8a6","deb2b8baebf3bb0d77453a950dc16dd3f51cbdc12efb69bf8bc4805fbf20fe7e","032108185be5a41a316b4a7872c74331bd574b13499f4b32ce7105ba1c12c339","bd05b91626fdf3e479751850b11e93c3d05ec9dc2afe6e0c1614dd34162aa970","b2ff62f5ded5dc3f30e89fd7d3bd1e5904085326e16ae71cec450b14bb0884e7","afbf3186ef8d68015006b1ed3bbaf54eece8908c27b146b0f7d522842f3210ac","09aea5c0044ff8161e00a9e874bfa5806652270d490dba2a914606f89351ef06","d42ca1c2dc79317b5fb8e14a7d85fc0addc9fe2b142355e34753d60ccc78007a","598b50b11b8daa1bee5f6c59c35ef8df93e05737ec541846634d79bdc60b8503","b40d2724b7cfa63ce888b2e6ebc269c9472109f65072ec9eddb97a83f4801897","2897ce01245d031ff94ec172a8537473ab88c56b139dfcf6d2f620b7b6d4a450","9bbe7d497d72552f0c13b88affff3b9c43dc16037e55ee342e9e7c11d15fc1c8","269867d10a8163319dd29262fcde46cdc275f60fc8750119fe71480474c2b66b","cf0c859d39a640beb86ecc33ec846c32d705f9982aa69e11009e23649934b95f","0e5e5794df0a788165de5a59e25ce055250360a36764e91b060cc1d05e9a9b59","04f00895ed87b76dcfeae85fd8389b10b363d86f08da4d5283f0be5dc42cbee4",{"version":"a254f5dc005eaffffb0afc0c42d168534fc959b2bde70b494afedfe20bfd7dc5","signature":"6a6747a61a1d968c53970b79f35641fba4a17005efc6d021240f3897ce2878fe"},{"version":"4e0094fc185fa5d4aeaacd5f525579bdfd8c2e10fc9ba2b349b312f329aa8b3c","signature":"3f1a08c5204101a5aee11207600d595a3e8cc24ee2b320e6c29edf198573e744"},{"version":"3af6e0f12e5a77347aafa0b38953f5909ac6c1ec9597ad26fd4e3def9dc43275","signature":"567f0f4dfb84be50ed306a03fee43efb0780d122d2b52170bbdb4e44874131f1"},{"version":"e9526437280f5cf11d114fc5df84f529ca142df90a320a56176e363ebed5c0b5","signature":"8ddb476321ecb63bfd236d0f4fd7f9b8965f1866dae46bd3168f559c302f4e2d"},{"version":"e8a9d476c45af9c0330983441deeb93c39e325ebb73b3385b7644630bbeacf6e","signature":"be5e1f61859b81be95fd171a61539d13e1e8b3bdfdea1a169b734d5c0862c408"},{"version":"2a0f41c5e876d5ffe17d4376660cbe9a4d3d9b1c4b70d5b00c2d5dfd33c9742b","signature":"89380172dd35719b05ff17ae673e21f267a1c0e6dcf82e3feb9a7ec215d6654a"},{"version":"57f05047b27a287520da059618d18c5e9be4d4372df6edfafa22cc4cee4129d3","signature":"5603161d52594be86fd7066626bef3b9166f10f9594fdda6a5e496d8ad56cfd0"},{"version":"c1d5dab3ed6d2e5d8986ce002d6341f49de45533444938cae2eb370e22b9cc7e","signature":"b9c4088f76376b9aa0005a67a2998bbe87c1222af2a62db949b6e5f006e3fb35"},{"version":"013344885a84af2fee522177a8409160cdaf87fec5523cec9a883d958d42785a","signature":"324a12bd7356b69c8f6cf1b75e02bc38cc167e2d4a2073ebffbd93388e224e09"},{"version":"3981b4f66c48b4c12898a051407a32d9d8ce84c6d7c476e83804a68270045e27","signature":"2d8e4effa6aa3bfff7d2cee7730b8f60e642ef0dd1a11b80e385738172eaa358"},{"version":"a04dd52280a45c96b6d9ac0af59246320e46f1925d3f0d7d481bdcd9f63927f5","signature":"c6c1d82d09e9b43209287e728d4a58d4d37f29cc774baa2a6538025eabd45c38"},"56c48fb5bb6316dfc27fbad065966b4ddbc38e9a0a1a5060d19b5da405ae7d6e","7091568b9a1b74b699ad09df6c130db712ed089d173a235e301a7a7ee0a4ca44","de33aa2a38affd9e71297ef7ec001a4525502878b09744308fb6518159f77d2d","57476e482c9b4e152bd23d0dc3c29375e48afee0de775674a3c1ea63cb4cf843","39554d914495ecc36b94d8bbc5076a6a891f12b7136cddb369a9a7083dd8522e","8fbe66a2959a393eb61b836224e0cd3983c89e5c2562d4875f36e3b61ee4cb77","c6695d874d1fd79c0f2266fc4943100b7b8d41d5e582408378763162679e8a92","ef69ca2ef1bd34fe5a447ccd3b055fbf12386487daff75bf109fb59e5eec06fc","ac9e28385721178e3e3f790128faf65baaf14191c070b2c9c5a50f337af5fb32","c244e83ebb4fe4d539d7f6d9405003d615e4bb7ba37629f0d5a0293c5f8bec7c","5716af400de6dc6ec6c90fa3d5b3dcb0ec1acd5156be0db4898f48796ad14f95","b22e4c25f0d8c8d0772da29fb1a697e4a7d118165f9217e9d2f7507a40633391","236dd26131e1ff9d6eb981e6865d6ef5e96f80f1353b6027800db9d3126282a1","37b51656ff8302a4556e29c775f311eb9ad813948d2c527405cea041dba3baf3","00abf32ca3af92f8be9ecbc9b63090b4909a756317d791927a83cffd24e9c8ac","cd28efe88fac7a92f3f5cfc7dd3c764f0b31bdaaa061ff044de1639810d6a7da","8b2100d3ba68063b7baf5038f26eefe46543dcebf1e7dbaf46277f24307cefcb","131b7f32092aa78e12fcb2a6db7c71e17f85e076c0635ad8d991b80d10130c19","d1c84af1e6d5fa4a5f4badd45b03b67c9255a675df235a3ec25307a0f5524278","aa4d6dc9282133162a76109d99c5795583276c4fd27284f128d484acf12b0841","3355c4c572f076ad963d95f0e28075b8558e2ab492c84eb94f9e2c48f1c2368b","5638cfd48b0c56bc9ed0c779d53a40b92c9cd9c9d6312e3a21c52542d38094f3","827eb54656695635a6e25543f711f0fe86d1083e5e1c0e84f394ffc122bd3ad7","2309cee540edc190aa607149b673b437cb8807f4e8d921bf7f5a50e6aa8d609c","703509e96cc30dce834ef8188c958c69306473b8a7e5cb3a6f324cee05a1f7bb","900daf04dc607dc3858c0f976d6f9e17b829a07de58d62dc6f730eaf06986075","08e0ac95e650bd4c87145b6ab2257b70c06254bf76a0b9f8a7d60c51fb8ed6b8","4b57ec505a035491c692b89af2c6902c312ec22f8fa9b6dae3e93686659fb7e0","7d796672940d3b2d37f2edea4d7bcf4c7993966286006228cbc8fa35ac92871d","132fd53917ed7f55275faa52c35e4d4d41e9576fea231d12740b723df2bade93","de2ecf9b1d6f60338f7b59b6f593ef77af9abd0e70ba8f2942953d0c6e1850af","f65593f26b317fcfb08789a72eca9a0785f0ee41efce6deaecfed6cf2d26b3a8","27ca878cf70b3030e8403f51ce65949d364fa776d6dae3527f91635a40836672","4c494db381ad1f479c137fdbb89dd32af10082cba7c11c2950a4e207bf4a3966","a45ee7555d019a67fbe092898d1aef0b1d02a9f6679ab84461ff515b4460d706","9990f9e566bc3c2c6e38df81294fb756e7f5b7b0e5bb17ab75384e190548b4b6","6fe7571c8a80808224648046008d1366ba4e29206ac79ce4c56d6fab3350492b","ae2fbee237555ff41daf5275bcc337870886f673b2f029815a8cb6802dfaf2ff","1a7cee6cce12f69f55f8fc7a55093a26a6618596399e25ccb7b29d86bc5df45f","a2f40a7fcef1f6040a09c9d7b9561d25d360917f80eb845b942dd6664dcb3830","a64568c16a5821575de4f6280ba1ea4686a1ceecd649fa90ba957c8b1b007013","11a8a3bf561b28e887819dec170064b63eaa3e08ab8c9385858a152f0764368b","1fdc3c9aa704209302fcb28c0afc62921b8e3de27160095495df3fe11ebf0468","a39c32b055d2e6103e5c49b9aed2d7bb5b06571c98fc31105264d280431bdbd7","618ebb93311695a13844118cdc9a7314dd3a2c6f35092d87f76828cac555ddc9","d36c3d116ce59a3f072c0014f0c020c76e916ba906066ddc4f193f546a43bceb","9bed8447acaa89be63540ec500b165442fcb0de020015175b5a5c66d42a61c4a","0df1434fa41979b81c7872ffdf6bb4890de5d3f1deddec785330ccfbd20928e5","a17e6861b709149f29a2bd896cee94526df2f06b24a2b60614b56649b5e9aabe","9c79ace686f720f4dd833740f7190e12cdce363362c982c164745527a412ef40","d14292ed4bd13d106adca4a774e71e21aa2c3d3c38135f4ec30650e33249d13d","75d48857bc4216880443a24d985071262bb8b89a9952c77fd430cb0caa21f9bf","33e40cf77499b3d9712db82e15683373925e85817dbe82a24ee0ee6e44bffb70","d5bbd453310990e851908183fbbef9e6e2db8e0c86d97b42b723fd5238f71c81","95e76bed30f6e993e1fcc1b90a4675682e4800ae43403547a775d6e3c7ab2b0f","8b206b995edc6dd849b85c1c56531b9780e3ba75302fd02a2d173f008028707e","97040b190f0daa10cf9a15e51a2fac66b26ddefd7b65998bd6027d1dd67647b7","877c25dfae100e555014e45d1d80364496a0c876201e5dea91a0fd0a6a4ff765","d53f9f96afd41359edeb2d5ad98559f3bfad261391d5aef95320fefb0c6a8742","23d98226adf3be74e1f0470f85e7fd154cd7aa979d60b43190a7437f0d0426eb","639f9321a98b734242a3573764d7f1de5369b0b0b10c768ae37639e8bda5dd03","05876912d3f60a58635248b50e37a20dedc89421f4a6d6ce6f13545fde7c6ed1","dc5fe5f6b39c3fdfaeba333bcd5f0cc98bb3068797a4d7010f585366f549ddf7","4a3ab8cb278bfd1f18f24cc45a02188b63afa6aef50035df6d79c4638f24059a","e724c9ce92f2a8a31ed260764c5455852a13d292e2a31d26acc6840ec0e83208","42cab173ca1afa1abcb1e10b7022fe302a496962746be5c2c8b700f738b463a7","257ef2776cb9f5e8b8330f8a92b409a4e9d1979898f845aa09aa4fa9125a71d2","773bf9af93b5027de9b5b4c779d5cda35f0eb92c7f43a97f2ef3ca081495a191","edb6d09bae4fe20b6c33b196e9d5fb5baa72c2277a55ab87b650e79c711eca15","59625b1fcc91f2686751fd5b623126f434d7b405bd8d866a555963ce2ac69846","2f505cf4e223d7f98e91fba72420ae2ac24adc330c1bf1e645c84a3c6d957d96","fc69ffd599d3e525aba38f80c7cc2ecd187dbf148287364c75f199c8294a00e6","2ad138be6972de52ed966e6402aa6403af79e9f183486e0a725ffa075a0555fb","fdac2512ddaa17ff3746ad7d7ac3a346c02e0fe50647a8472195aa43ef5823e3","967fb6e86b55db228ab50c81f85f39d6a23a0c15bcfa6e19d255e0952d33a65a","c39e7d32dddfcdaa93b18b99fa430ebb1d6ba366459563d400add22f92e3644b","e3932de252bbe43132ad3226865b2a376ad945dbc1d767540c01b7bddc6477c2","b2f52f3cbd863dc4e690614b5cddbf412dea435d0de099db6d8adfd3cbefcd65","557c93b35f3b58e6844a9b8817559da1e0641f7f08f918e3cd1a8efee126746f","80ad2ae93d57dadac5e377ec6743df5e0211ea30bafd4b648c52366af057bb2b","07f90213b5800a0b43a6d6f309517dcca5afc6ffeb4bed396878a29fc5d6ceb0","bb0e637020f81cb40d16f202c3a783f0e269e29547fb84ca9f187a5ea8556965","462da802b50ac0d94a3c8f7f58a6a0aa08108bfc1394449ea56f1e0f63f5132e","cd1d2f103b79002cd94b85a640a103f094227a2c4c53bc8af1fdbf4e13d9729e","dfef9c847826fac5c480b6d972d3a597b932a2308f330a4416eeeb81c63ba1b2","e2379c5dcbe61406e60d82709829a1d4adf0b16c20ad915a2f1caa987c5f6dbe","21f706150e32f03ecd1714d7a7ac55ce3caadc7c7a2a960ba57cc5d39ad84c9d","6442db17edc8cac7c6c2b39e11c15d7431ec351c1a852b61c7a354ef5166f6f5","da1963f37d566ff9f71bf8ca5c628656bae02fc9509050041547e9c7063cc58f","57e4bed825036f7f1328505bc512af492f28b1b57a48f1ff9b6d90b930041a52","3ef0957915b7719ac58153eaea6ce810ff8688276e570f8938455f3ec7930df7","05e0ad043fdd4e2d4874a97bd716174af64d63e43851c09830c00e819a80d395","2dff0ed1eb2046fbdbc2c13914117e1ff1112e217f90542ea5e7f41e39f0393e","a0ba1e2711c2520189ed980225e7a429b0706a1eabf9113e53f0e72550a1b23d","61ab2f2d7b5cd232e133561a389c2cf8886a1e676d22296d0f9a80e9a43d931d","75af0adbecda3923b456088ff716dd43b39f4a8be2db64b397bf21bf7eddcf77","badb4cfbfc6eca3a038be22c76297bec0b5c1478d8b73d60e8b50725b7dcc15c","21e7e0eddddc112f2b891d1066eac74680291db768d3ef9b908965935380ab98","dc6ad8b550645082ef77a01cdc9186360a6b805799963107be45a7a051a94d84","516efe800aaa0b7504b71f2d7e7e9bed5f28eb6c9c739bfdf237f09c7addea46","10ae729013e6620dc937df5dd7077c34e29ad313a28aa75cec39957640cdc8b0","ac5f95dee5e4787fa7c68a81a052cdfa0e03adec8331d3276389384df36cb849","25107bef30f920db282053349c8110a40c94d4d8352aeb9732f59647f2d39b9f","8d02c68113d52ea72bc03caaf2381d26d0507668713009067be7685fb86221d3","955a15609b0b382eaefedbe00bd7b669244b05692989a0bfb44e206f2479a7da",{"version":"cfd225912d5e550fa821bc397ac8677db3e7f2d58d2d2971248c9155ad9d0362","signature":"a5ac165a57188ab19afc0375d08a98fb8886cfdb95bfeccb7cdae09c0854cc2f"},{"version":"2e2b305ab2b21ebc58807acffa34c734b9550c62801adc37e872c98c8d0f6bdb","signature":"7818f30a8d867d32f67c0a0ce64b002fdf855f4150b1fb5735249ff126727c0a"},"a5aaeca001d2f69093d04aac4db321e4c338fd9b20cbc4f0b0af3dc6ae0f235b","cc957354aa3c94c9961ebf46282cfde1e81d107fc5785a61f62c67f1dd3ac2eb","8041cfce439ff29d339742389de04c136e3029d6b1817f07b2d7fcbfb7534990","93de1c6dab503f053efe8d304cb522bb3a89feab8c98f307a674a4fae04773e9","29a46d003ca3c721e6405f00dee7e3de91b14e09701eba5d887bf76fb2d47d38","069bebfee29864e3955378107e243508b163e77ab10de6a5ee03ae06939f0bb9",{"version":"64d4b35c5456adf258d2cf56c341e203a073253f229ef3208fc0d5020253b241","affectsGlobalScope":true},"ee7d8894904b465b072be0d2e4b45cf6b887cdba16a467645c4e200982ece7ea","f3d8c757e148ad968f0d98697987db363070abada5f503da3c06aefd9d4248c1","df95e00612c1faa5e0e7ef0dba589b18665bbeb3221db2b6cee1fe4d0e61921f","afe73051ff6a03a9565cbd8ebb0e956ee3df5e913ad5c1ded64218aabfa3dcb5","8b06ac3faeacb8484d84ddb44571d8f410697f98d7bfa86c0fda60373a9f5215","7eb06594824ada538b1d8b48c3925a83e7db792f47a081a62cf3e5c4e23cf0ee","f5638f7c2f12a9a1a57b5c41b3c1ea7db3876c003bab68e6a57afd6bcc169af0","0d14fa22c41fdc7277e6f71473b20ebc07f40f00e38875142335d5b63cdfc9d2","d8aab31ba8e618cc3eea10b0945de81cb93b7e8150a013a482332263b9305322","462bccdf75fcafc1ae8c30400c9425e1a4681db5d605d1a0edb4f990a54d8094","5923d8facbac6ecf7c84739a5c701a57af94a6f6648d6229a6c768cf28f0f8cb","7adecb2c3238794c378d336a8182d4c3dd2c4fa6fa1785e2797a3db550edea62","dc12dc0e5aa06f4e1a7692149b78f89116af823b9e1f1e4eae140cd3e0e674e6","1bfc6565b90c8771615cd8cfcf9b36efc0275e5e83ac7d9181307e96eb495161","8a8a96898906f065f296665e411f51010b51372fa260d5373bf9f64356703190","7f82ef88bdb67d9a850dd1c7cd2d690f33e0f0acd208e3c9eba086f3670d4f73",{"version":"ccfd8774cd9b929f63ff7dcf657977eb0652e3547f1fcac1b3a1dc5db22d4d58","affectsGlobalScope":true},"d92dc90fecd2552db74d8dc3c6fb4db9145b2aa0efe2c127236ba035969068d4","96d14f21b7652903852eef49379d04dbda28c16ed36468f8c9fa08f7c14c9538","8841e2aa774b89bd23302dede20663306dc1b9902431ac64b24be8b8d0e3f649","2b8264b2fefd7367e0f20e2c04eed5d3038831fe00f5efbc110ff0131aab899b","a73a445c1e0a6d0f8b48e8eb22dc9d647896783a7f8991cbbc31c0d94bf1f5a2","d88a5e779faf033be3d52142a04fbe1cb96009868e3bbdd296b2bc6c59e06c0e","3dce33e7eb25594863b8e615f14a45ab98190d85953436750644212d8a18c066","2b93035328f7778d200252681c1d86285d501ed424825a18f81e4c3028aa51d9","2ac9c8332c5f8510b8bdd571f8271e0f39b0577714d5e95c1e79a12b2616f069","42c21aa963e7b86fa00801d96e88b36803188018d5ad91db2a9101bccd40b3ff","d31eb848cdebb4c55b4893b335a7c0cca95ad66dee13cbb7d0893810c0a9c301","b9f96255e1048ed2ea33ec553122716f0e57fc1c3ad778e9aa15f5b46547bd23","7a9e0a564fee396cacf706523b5aeed96e04c6b871a8bebefad78499fbffc5bc","906c751ef5822ec0dadcea2f0e9db64a33fb4ee926cc9f7efa38afe5d5371b2a","5387c049e9702f2d2d7ece1a74836a14b47fbebe9bbeb19f94c580a37c855351","c68391fb9efad5d99ff332c65b1606248c4e4a9f1dd9a087204242b56c7126d6","e9cf02252d3a0ced987d24845dcb1f11c1be5541f17e5daa44c6de2d18138d0c","e8b02b879754d85f48489294f99147aeccc352c760d95a6fe2b6e49cd400b2fe","9f6908ab3d8a86c68b86e38578afc7095114e66b2fc36a2a96e9252aac3998e0","0eedb2344442b143ddcd788f87096961cd8572b64f10b4afc3356aa0460171c6","71405cc70f183d029cc5018375f6c35117ffdaf11846c35ebf85ee3956b1b2a6","c68baff4d8ba346130e9753cefe2e487a16731bf17e05fdacc81e8c9a26aae9d","2cd15528d8bb5d0453aa339b4b52e0696e8b07e790c153831c642c3dea5ac8af","479d622e66283ffa9883fbc33e441f7fc928b2277ff30aacbec7b7761b4e9579","ade307876dc5ca267ca308d09e737b611505e015c535863f22420a11fffc1c54","f8cdefa3e0dee639eccbe9794b46f90291e5fd3989fcba60d2f08fde56179fb9","86c5a62f99aac7053976e317dbe9acb2eaf903aaf3d2e5bb1cafe5c2df7b37a8","2b300954ce01a8343866f737656e13243e86e5baef51bd0631b21dcef1f6e954","a2d409a9ffd872d6b9d78ead00baa116bbc73cfa959fce9a2f29d3227876b2a1","b288936f560cd71f4a6002953290de9ff8dfbfbf37f5a9391be5c83322324898","61178a781ef82e0ff54f9430397e71e8f365fc1e3725e0e5346f2de7b0d50dfa","6a6ccb37feb3aad32d9be026a3337db195979cd5727a616fc0f557e974101a54","c649ea79205c029a02272ef55b7ab14ada0903db26144d2205021f24727ac7a3","38e2b02897c6357bbcff729ef84c736727b45cc152abe95a7567caccdfad2a1d","d6610ea7e0b1a7686dba062a1e5544dd7d34140f4545305b7c6afaebfb348341","3dee35db743bdba2c8d19aece7ac049bde6fa587e195d86547c882784e6ba34c","b15e55c5fa977c2f25ca0b1db52cfa2d1fd4bf0baf90a8b90d4a7678ca462ff1","f41d30972724714763a2698ae949fbc463afb203b5fa7c4ad7e4de0871129a17","843dd7b6a7c6269fd43827303f5cbe65c1fecabc30b4670a50d5a15d57daeeb9","f06d8b8567ee9fd799bf7f806efe93b67683ef24f4dea5b23ef12edff4434d9d","6017384f697ff38bc3ef6a546df5b230c3c31329db84cbfe686c83bec011e2b2","e1a5b30d9248549ca0c0bb1d653bafae20c64c4aa5928cc4cd3017b55c2177b0","a593632d5878f17295bd53e1c77f27bf4c15212822f764a2bfc1702f4b413fa0","a868a534ba1c2ca9060b8a13b0ffbbbf78b4be7b0ff80d8c75b02773f7192c29","da7545aba8f54a50fde23e2ede00158dc8112560d934cee58098dfb03aae9b9d","34baf65cfee92f110d6653322e2120c2d368ee64b3c7981dff08ed105c4f19b0","a1a261624efb3a00ff346b13580f70f3463b8cdcc58b60f5793ff11785d52cab","f83b320cceccfc48457a818d18fc9a006ab18d0bdd727aa2c2e73dc1b4a45e98","9d92b037978bb9525bc4b673ebddd443277542e010c0aef019c03a170ccdaa73","b0d10e46cfe3f6c476b69af02eaa38e4ccc7430221ce3109ae84bb9fb8282298","70e9a18da08294f75bf23e46c7d69e67634c0765d355887b9b41f0d959e1426e","ed44ba6b95f08b758748be7902e0cc54178b1337c56d0e2469c77b03f63ac73b"],"options":{"composite":true,"declaration":true,"declarationMap":true,"emitDeclarationOnly":true,"esModuleInterop":true,"inlineSources":true,"module":1,"outDir":"./types","rootDir":"../src","sourceMap":true,"strict":true,"target":7},"fileIdsList":[[120,641],[120],[91,120,127,128,129,144],[120,128,129,145,146],[120,127,128],[120,127,144,147,150],[120,127,147,150,151],[120,148,149,150,152,153],[120,127,150],[120,127,144,147,148,149,152],[120,127,135],[120,127],[91,120,127],[80,120,127],[120,131,132,133,134,135,136,137,138,139,140,141,142,143],[120,127,133,134],[120,127,133,135],[120,429,433,434],[120,429,432],[120,432],[120,433,435,437],[120,429,432,433,434,435,436],[120,429,432,436,440,441,442],[120,429,432,436,443],[120,429],[120,429,430],[120,430,431],[120,429,432,438,441,443,444],[120,439],[120,440,442,446,449,450],[120,440,442,450],[120,127,432,436,440,441,443,446],[120,440,450],[120,440,443,447],[120,432,441,443],[120,440,443,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461],[120,440,448],[120,127,448],[120,429,436,440,441,442,443,444,447],[120,440,442,446,448],[120,440,447,448],[120,127,154,264,265],[120,264],[120,265,266],[120,127,259],[120,259,260,261,262,263],[120,127,231,238,239],[120,127,231,238,239,259],[120,127,231,238,239,243],[120,127,231,238,239,240,242,243],[120,127,231,238,239,241],[120,127,231,238,239,244,245,247,248],[120,237,259],[120,229,238,239,244,245],[120,231,237,238],[120,127,231,238,239,244],[120,127,231,238,239,242],[120,127,231,238,239,255],[120,127,231,238,239,256],[120,130,228,231,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258],[120,229],[120,229,230],[91,120,127,264,267,274],[120,267,276],[120,276,277],[120,166,519],[120,166,517,519,520,521],[120,166,507],[120,507],[120,507,508,509,510,511,512,513,514,515,516],[120,517],[120,518],[120,342,348,349,352],[120,342,348,351],[120,342,348,350,352],[120,344,346],[120,343],[120,344,346,347],[120,345],[120,351,356],[120,342,348,351,356],[120,348,351,353,354,355],[120,342,348,349,350,351,352,356],[120,342,348],[64,120,166,280],[120,166,281,295],[120,166,295,296,307],[120,283],[64,120,280],[120,284,285],[64,120],[120,280,281,282,286,287,294,296,308,309,395],[64,120,166,396],[120,166,282,286],[120,289],[64,120,166],[120,288,290,291,292,293],[120,166,287,394],[58,64,120],[120,502,503,504,505],[120,127,301,534],[120,127,301,535],[120,535],[120,269],[120,268],[108,120,127,269],[120,269,270,271,272,273],[108,120,127],[120,301,537],[120,538],[120,537,538],[120,537,538,539,540,541,542,543,544,545,546],[81,120,127,537,538],[120,124,127,537,538],[120,166,203,210,297],[120,298],[120,127,166,298,301,302],[120,127,166,203,210,298,301],[120,302],[120,297,298,299,302,303,304,305,306],[120,127,299,301,304],[120,297,304],[120,166,210],[120,166,310],[120,310,311],[120,310,311,312,313],[120,166],[120,187,394,581,598,611,628,635],[120,633],[120,166,609,622,631,632,634],[120,187,394,620],[120,621],[120,127,210,301,536,547,598,599,611],[120,166,187,598,611],[120,166,547],[120,547,600],[120,602],[120,599,600,601,603,606,608],[120,600,604,609],[120,605],[120,547,600,601],[120,600,601],[120,607],[120,166,183,187,394,469,581,591,598,609,611,614,616,622,624,627,628],[120,614,627,629,630],[120,598,611],[120,610,611,612,613],[120,598,611,612],[120,166,598,610,611],[120,166,598,611],[120,625,626],[120,166,187,591,625],[120,166,394,591],[120,623],[120,166,394,598,611,628,631],[64,120,166,590],[120,127,166,315],[120,166,321],[120,338],[120,166,315,321,322,338,339,393],[120,127,166,314,315],[120,316,317,318,319,320],[58,64,120,318],[120,380],[120,383,384,385,386,387,388,389,390,391],[120,166,358],[120,321,338,389],[120,321,338,358],[120,358,359,366,369,379,380,381,392],[120,321,338],[120,357,359],[120,359],[120,321],[120,366],[120,166,369],[120,340,341,360,361,362,363,364,365,367,368,370,371,372,373,374,375,376,377,378],[120,166,371],[120,321,340,341,360,361,362,363,364,365,367,368,370,371,372,373,374,375,376,377],[120,307,379],[120,166,359],[120,336],[64,120,323],[120,324,325,326,327,328,329,330,331,332,333,334,335],[120,323,336,337],[64,120,336],[120,394],[120,551],[120,550],[64,120,166,557],[120,357],[120,166,314,394],[64,120,394,564],[120,548,549,551,552,553,554,555,558,559,560,561,562,563,564,565,566,567,582,583,585,586,587,588,589,592,593,594,595,596,597],[64,120,166,581],[64,120,166,394,551,585],[120,157],[120,584],[64,120,166,394,583],[64,120,394,583],[64,120,394,581,584,586,591,592],[64,120,166,551,554,565,585,586],[120,592],[120,198],[120,198,199,200],[67,120],[64,67,120],[65,66,67,68,69,70,71,72,73,74,75,120,155,158,159,160,161,162,163,164,165],[58,64,65,120],[67,73,75,120,154],[67,68,120],[64,120,161],[120,127,234],[120,232,233,236],[120,232,235],[120,127,232],[120,193,194],[120,641,642,643,644,645],[120,641,643],[120,156],[120,647,648,649],[92,120,127],[120,652],[120,653],[120,664],[120,658,663],[120,415,417,418,419,420,421,422,423,424,425,426,427],[120,415,416,418,419,420,421,422,423,424,425,426,427],[120,416,417,418,419,420,421,422,423,424,425,426,427],[120,415,416,417,419,420,421,422,423,424,425,426,427],[120,415,416,417,418,420,421,422,423,424,425,426,427],[120,415,416,417,418,419,421,422,423,424,425,426,427],[120,415,416,417,418,419,420,422,423,424,425,426,427],[120,415,416,417,418,419,420,421,423,424,425,426,427],[120,415,416,417,418,419,420,421,422,424,425,426,427],[120,415,416,417,418,419,420,421,422,423,425,426,427],[120,415,416,417,418,419,420,421,422,423,424,426,427],[120,415,416,417,418,419,420,421,422,423,424,425,427],[120,415,416,417,418,419,420,421,422,423,424,425,426],[76,120],[79,120],[80,85,111,120],[81,91,92,99,108,119,120],[81,82,91,99,120],[83,120],[84,85,92,100,120],[85,108,116,120],[86,88,91,99,120],[87,120],[88,89,120],[90,91,120],[91,120],[91,92,93,108,119,120],[91,92,93,108,120],[91,94,99,108,119,120],[91,92,94,95,99,108,116,119,120],[94,96,108,116,119,120],[76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126],[91,97,120],[98,119,120,124],[88,91,99,108,120],[100,120],[101,120],[79,102,120],[103,118,120,124],[104,120],[105,120],[91,106,120],[106,107,120,122],[80,91,108,109,110,120],[80,108,110,120],[108,109,120],[111,120],[112,120],[91,114,115,120],[114,115,120],[85,99,116,120],[117,120],[99,118,120],[80,94,105,119,120],[85,120],[108,120,121],[120,122],[120,123],[80,85,91,93,102,108,119,120,122,124],[108,120,125],[120,127,300],[120,672,711],[120,672,696,711],[120,711],[120,672],[120,672,697,711],[120,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710],[120,697,711],[120,712],[120,715],[120,615],[120,409],[120,411],[120,409,410,411,412,413],[120,409,411],[120,127,481,487],[120,127,481,487,488,492],[120,127,487,488,498],[120,127,487,498],[120,127,480,481,482,483,484,485,486,489,492],[120,127,480,481,487,488],[120,127,481,487,488],[120,475,476,477,478,479],[120,480],[120,477,480],[120,478],[120,489,490,491],[120,492],[120,489,492],[120,481,487],[120,493,494,495,496],[120,493],[120,480,481,482,483,484,485,486,487,489,492,497],[120,556],[120,203],[120,203,214,215],[120,215,216,217],[120,178],[120,178,179,180,181,182],[120,167,168,169,170,171,172,173,174,175,176,177],[120,656,659],[120,656,659,660,661],[120,658],[120,655,662],[120,463,464],[120,657],[57,59,60,61,62,63,120],[57,58,120],[59,120],[58,59,120],[57,59,120],[120,187,396,405,635],[120,636,637],[120,470],[120,166,187,314],[120,467,468],[120,166,187,190,197,223,227,408,414,427],[46,120,166,187,191,197,223,408,445,462,523,524,529,530],[120,187,197,223,227,414,501],[91,120,166,187,191,197,223,314,408,414,466,469,470,471,472,529,531],[120,166,187,197,223,227,408,471,473],[52,120,144,166,191,197,445,462,522,529],[52,120,191,197,445,462,529],[52,120,197,445,462,529],[120,187,197,408,527,528,531],[47,120,166,187,197,223,227,405,408,526,527,528,529,531,638],[120,166,187,197,223,227,414,525,529],[120,166,187,197,223,227,408,427,474,501,527,529],[47,52,91,120,166,183,187,197,223,314,408,414,445,462,469,470,523,524,525,526,528,529],[120,166,191,197,432,465,473,500,528],[120,197],[120,428,472,473,500,526,527,528,529,531,532,533,639],[120,166,197,474,498],[120,474,499],[120,166,197,529],[120,166,183,184,185],[120,184],[120,185],[56,120,184,185,186],[120,188],[120,188,189,192,196],[120,195],[120,166,190,191],[120,211,212,213],[120,210,211],[120,166,210,211],[120,166,203,210],[120,166,203],[120,166,204],[120,204,205,206,207,208,209],[120,154,166,183,187,278,279,396,403],[120,404],[91,120,127,166,187],[120,397],[120,197,397],[120,397,398,399,400,401,402],[120,166,187,190,197,201,202,219,220],[120,219],[120,202,219,221,222],[120,166,197,214,218],[120,166,573,574,575],[120,166,187,197,568,571,573,576],[120,166,183,187,197,314,469,568,569,570,571,572,574,575,576],[120,166,187,573],[120,314,574],[120,571,572,573,574,575,576,580],[120,166,210,573,575,581],[120,166,210,572,573,574],[120,577,578,579],[120,166,197,210,572,574,575],[120,166,210,572,574,575],[120,166,210,574,576],[55,120,187,197,617,618],[120,619],[120,166,187,223,224],[120,127,166,187,223,224],[120,224,225,226],[120,166,223],[120,187,405,406],[120,406,407],[187,190,223,227,408],[166,187,191,223,408,462,523,524,530],[187,223,227,501],[91,166,187,223,408,469,471,472,531],[166,187,223,227,408,471,473],[191,462],[462],[187,408,527,528,531],[187,223,227,405,408,526,527,531,638],[166,187,223,227],[166,187,223,227,408,474,527],[91,166,183,187,223,408,445,462,469,526,528],[166,191,432,473,500,528],[428,472,473,500,526,527,528,529,531,532,533,639],[166],[166,474]],"referencedMap":[[643,1],[641,2],[145,3],[128,2],[147,4],[129,5],[146,2],[151,6],[152,7],[148,7],[154,8],[149,7],[153,9],[150,10],[136,11],[133,12],[140,13],[134,11],[131,14],[139,2],[144,15],[141,2],[142,2],[143,2],[138,12],[135,16],[132,2],[137,17],[435,18],[434,19],[433,20],[438,21],[437,22],[443,23],[444,24],[466,19],[430,25],[431,26],[432,27],[429,2],[445,28],[440,29],[439,2],[436,2],[451,30],[452,31],[447,32],[453,33],[454,34],[455,34],[446,35],[462,36],[457,30],[456,37],[458,38],[448,39],[459,33],[460,31],[450,40],[461,37],[449,41],[441,19],[442,2],[266,42],[265,43],[267,44],[262,45],[260,45],[261,45],[264,46],[263,2],[246,47],[251,48],[240,47],[245,49],[244,50],[242,51],[249,52],[250,47],[252,53],[247,54],[241,2],[239,55],[238,2],[248,2],[254,2],[253,56],[255,57],[256,58],[257,59],[259,60],[229,2],[230,61],[231,62],[228,2],[243,2],[258,2],[276,63],[277,64],[278,65],[275,46],[520,66],[521,2],[522,67],[508,68],[509,69],[510,69],[511,68],[512,68],[513,69],[517,70],[514,68],[507,2],[515,69],[516,69],[518,71],[519,72],[279,2],[190,2],[350,73],[352,74],[351,75],[342,2],[347,76],[344,77],[348,78],[346,79],[353,80],[354,81],[356,82],[355,80],[357,83],[349,84],[295,85],[296,86],[308,87],[281,85],[282,2],[284,88],[283,89],[286,90],[285,91],[287,2],[396,92],[288,93],[289,94],[290,95],[291,96],[294,97],[292,2],[293,85],[309,86],[395,98],[280,99],[504,2],[502,2],[503,2],[505,2],[506,100],[535,101],[534,102],[536,103],[271,104],[272,104],[269,105],[270,106],[274,107],[273,108],[268,13],[538,109],[541,110],[540,111],[547,112],[543,111],[542,113],[545,111],[544,114],[546,110],[537,2],[539,110],[298,115],[299,116],[304,117],[302,118],[303,119],[307,120],[305,121],[306,122],[297,123],[311,124],[313,2],[312,125],[314,126],[310,127],[203,13],[633,128],[634,129],[635,130],[621,131],[622,132],[600,133],[599,134],[601,135],[602,136],[603,137],[609,138],[605,139],[606,140],[604,141],[607,142],[608,143],[629,144],[628,2],[631,145],[612,146],[614,147],[613,148],[611,149],[610,150],[627,151],[626,152],[625,153],[630,146],[623,127],[624,154],[632,155],[591,156],[590,96],[322,157],[315,158],[339,159],[394,160],[316,161],[317,127],[318,127],[321,162],[319,163],[320,2],[358,2],[381,164],[383,127],[384,159],[392,165],[385,127],[386,127],[387,166],[388,127],[390,167],[389,168],[391,91],[382,2],[393,169],[366,91],[340,159],[341,170],[360,171],[361,172],[362,171],[363,2],[364,127],[365,173],[367,174],[368,2],[370,175],[379,176],[372,177],[371,127],[373,127],[374,158],[378,178],[375,173],[376,175],[377,159],[359,166],[380,179],[369,180],[337,181],[324,182],[333,182],[325,182],[326,182],[335,182],[327,182],[328,182],[336,183],[334,182],[329,182],[332,182],[330,182],[331,182],[338,184],[323,185],[548,2],[549,186],[552,187],[553,188],[554,2],[555,187],[558,189],[559,2],[560,2],[561,190],[562,2],[563,191],[564,2],[565,192],[566,2],[598,193],[582,194],[567,127],[586,195],[587,196],[585,197],[584,198],[588,199],[589,2],[593,200],[594,2],[583,99],[592,201],[595,186],[596,202],[597,127],[550,2],[551,188],[199,203],[200,203],[201,204],[198,2],[65,91],[66,91],[68,205],[69,91],[70,91],[71,206],[72,2],[73,2],[74,2],[67,91],[166,207],[75,208],[155,209],[158,196],[159,2],[160,2],[161,2],[162,2],[163,2],[164,210],[165,211],[235,212],[234,12],[237,213],[232,12],[236,214],[233,215],[343,2],[345,2],[193,2],[195,216],[194,2],[646,217],[642,1],[644,218],[645,1],[191,12],[157,219],[569,2],[647,2],[650,220],[648,2],[651,221],[652,2],[653,222],[654,223],[665,224],[664,225],[649,2],[666,2],[416,226],[417,227],[415,228],[418,229],[419,230],[420,231],[421,232],[422,233],[423,234],[424,235],[425,236],[426,237],[427,238],[667,2],[156,2],[76,239],[77,239],[79,240],[80,241],[81,242],[82,243],[83,244],[84,245],[85,246],[86,247],[87,248],[88,249],[89,249],[90,250],[91,251],[92,252],[93,253],[78,2],[126,2],[94,254],[95,255],[96,256],[127,257],[97,258],[98,259],[99,260],[100,261],[101,262],[102,263],[103,264],[104,265],[105,266],[106,267],[107,268],[108,269],[110,270],[109,271],[111,272],[112,273],[113,2],[114,274],[115,275],[116,276],[117,277],[118,278],[119,279],[120,280],[121,281],[122,282],[123,283],[124,284],[125,285],[668,2],[669,12],[670,2],[617,2],[301,286],[300,2],[671,12],[696,287],[697,288],[672,289],[675,289],[694,287],[695,287],[685,287],[684,290],[682,287],[677,287],[690,287],[688,287],[692,287],[676,287],[689,287],[693,287],[678,287],[679,287],[691,287],[673,287],[680,287],[681,287],[683,287],[687,287],[698,291],[686,287],[674,287],[711,292],[710,2],[705,291],[707,293],[706,291],[699,291],[700,291],[702,291],[704,291],[708,293],[709,293],[701,293],[703,293],[713,294],[712,2],[714,2],[470,2],[715,2],[716,295],[616,296],[615,2],[410,297],[409,2],[412,298],[411,2],[414,299],[413,300],[130,2],[655,2],[482,301],[489,302],[483,303],[484,304],[487,305],[485,306],[486,307],[480,308],[475,309],[476,309],[478,310],[477,311],[479,309],[492,312],[491,313],[490,314],[481,12],[488,315],[493,2],[494,2],[497,316],[495,317],[496,2],[498,318],[556,2],[557,319],[215,320],[216,321],[217,321],[218,322],[177,2],[174,323],[176,323],[175,323],[173,323],[183,324],[178,325],[182,2],[179,2],[181,2],[180,2],[169,323],[170,323],[171,323],[167,2],[168,2],[172,323],[656,2],[660,326],[662,327],[661,326],[659,328],[663,329],[463,2],[465,330],[464,2],[568,2],[658,331],[657,2],[57,2],[64,332],[59,333],[60,334],[61,334],[62,335],[63,335],[58,336],[8,2],[10,2],[9,2],[2,2],[11,2],[12,2],[13,2],[14,2],[15,2],[16,2],[17,2],[18,2],[3,2],[4,2],[22,2],[19,2],[20,2],[21,2],[23,2],[24,2],[25,2],[5,2],[26,2],[27,2],[28,2],[29,2],[6,2],[33,2],[30,2],[31,2],[32,2],[34,2],[7,2],[35,2],[40,2],[41,2],[36,2],[37,2],[38,2],[39,2],[1,2],[42,2],[636,337],[638,338],[637,339],[467,340],[468,2],[469,341],[428,342],[531,343],[532,344],[473,345],[472,346],[523,347],[524,348],[530,349],[533,350],[639,351],[526,352],[528,353],[527,354],[529,355],[471,2],[501,356],[640,357],[474,127],[499,358],[500,359],[525,360],[56,2],[186,361],[185,362],[184,363],[187,364],[189,365],[197,366],[196,367],[188,2],[192,368],[214,369],[212,370],[213,371],[211,372],[204,373],[205,374],[206,374],[207,2],[208,374],[210,375],[209,374],[404,376],[405,377],[397,378],[402,379],[401,379],[398,379],[399,380],[400,379],[403,381],[221,382],[202,2],[220,383],[222,383],[223,384],[219,385],[576,386],[574,387],[573,388],[571,389],[575,390],[581,391],[570,392],[577,393],[580,394],[578,395],[579,396],[572,397],[619,398],[620,399],[618,399],[225,400],[226,401],[227,402],[224,403],[407,404],[406,2],[408,405],[47,2],[48,2],[49,2],[50,2],[51,2],[52,2],[43,2],[53,2],[54,2],[55,2],[44,2],[45,2],[46,2]],"exportedModulesMap":[[643,1],[641,2],[145,3],[128,2],[147,4],[129,5],[146,2],[151,6],[152,7],[148,7],[154,8],[149,7],[153,9],[150,10],[136,11],[133,12],[140,13],[134,11],[131,14],[139,2],[144,15],[141,2],[142,2],[143,2],[138,12],[135,16],[132,2],[137,17],[435,18],[434,19],[433,20],[438,21],[437,22],[443,23],[444,24],[466,19],[430,25],[431,26],[432,27],[429,2],[445,28],[440,29],[439,2],[436,2],[451,30],[452,31],[447,32],[453,33],[454,34],[455,34],[446,35],[462,36],[457,30],[456,37],[458,38],[448,39],[459,33],[460,31],[450,40],[461,37],[449,41],[441,19],[442,2],[266,42],[265,43],[267,44],[262,45],[260,45],[261,45],[264,46],[263,2],[246,47],[251,48],[240,47],[245,49],[244,50],[242,51],[249,52],[250,47],[252,53],[247,54],[241,2],[239,55],[238,2],[248,2],[254,2],[253,56],[255,57],[256,58],[257,59],[259,60],[229,2],[230,61],[231,62],[228,2],[243,2],[258,2],[276,63],[277,64],[278,65],[275,46],[520,66],[521,2],[522,67],[508,68],[509,69],[510,69],[511,68],[512,68],[513,69],[517,70],[514,68],[507,2],[515,69],[516,69],[518,71],[519,72],[279,2],[190,2],[350,73],[352,74],[351,75],[342,2],[347,76],[344,77],[348,78],[346,79],[353,80],[354,81],[356,82],[355,80],[357,83],[349,84],[295,85],[296,86],[308,87],[281,85],[282,2],[284,88],[283,89],[286,90],[285,91],[287,2],[396,92],[288,93],[289,94],[290,95],[291,96],[294,97],[292,2],[293,85],[309,86],[395,98],[280,99],[504,2],[502,2],[503,2],[505,2],[506,100],[535,101],[534,102],[536,103],[271,104],[272,104],[269,105],[270,106],[274,107],[273,108],[268,13],[538,109],[541,110],[540,111],[547,112],[543,111],[542,113],[545,111],[544,114],[546,110],[537,2],[539,110],[298,115],[299,116],[304,117],[302,118],[303,119],[307,120],[305,121],[306,122],[297,123],[311,124],[313,2],[312,125],[314,126],[310,127],[203,13],[633,128],[634,129],[635,130],[621,131],[622,132],[600,133],[599,134],[601,135],[602,136],[603,137],[609,138],[605,139],[606,140],[604,141],[607,142],[608,143],[629,144],[628,2],[631,145],[612,146],[614,147],[613,148],[611,149],[610,150],[627,151],[626,152],[625,153],[630,146],[623,127],[624,154],[632,155],[591,156],[590,96],[322,157],[315,158],[339,159],[394,160],[316,161],[317,127],[318,127],[321,162],[319,163],[320,2],[358,2],[381,164],[383,127],[384,159],[392,165],[385,127],[386,127],[387,166],[388,127],[390,167],[389,168],[391,91],[382,2],[393,169],[366,91],[340,159],[341,170],[360,171],[361,172],[362,171],[363,2],[364,127],[365,173],[367,174],[368,2],[370,175],[379,176],[372,177],[371,127],[373,127],[374,158],[378,178],[375,173],[376,175],[377,159],[359,166],[380,179],[369,180],[337,181],[324,182],[333,182],[325,182],[326,182],[335,182],[327,182],[328,182],[336,183],[334,182],[329,182],[332,182],[330,182],[331,182],[338,184],[323,185],[548,2],[549,186],[552,187],[553,188],[554,2],[555,187],[558,189],[559,2],[560,2],[561,190],[562,2],[563,191],[564,2],[565,192],[566,2],[598,193],[582,194],[567,127],[586,195],[587,196],[585,197],[584,198],[588,199],[589,2],[593,200],[594,2],[583,99],[592,201],[595,186],[596,202],[597,127],[550,2],[551,188],[199,203],[200,203],[201,204],[198,2],[65,91],[66,91],[68,205],[69,91],[70,91],[71,206],[72,2],[73,2],[74,2],[67,91],[166,207],[75,208],[155,209],[158,196],[159,2],[160,2],[161,2],[162,2],[163,2],[164,210],[165,211],[235,212],[234,12],[237,213],[232,12],[236,214],[233,215],[343,2],[345,2],[193,2],[195,216],[194,2],[646,217],[642,1],[644,218],[645,1],[191,12],[157,219],[569,2],[647,2],[650,220],[648,2],[651,221],[652,2],[653,222],[654,223],[665,224],[664,225],[649,2],[666,2],[416,226],[417,227],[415,228],[418,229],[419,230],[420,231],[421,232],[422,233],[423,234],[424,235],[425,236],[426,237],[427,238],[667,2],[156,2],[76,239],[77,239],[79,240],[80,241],[81,242],[82,243],[83,244],[84,245],[85,246],[86,247],[87,248],[88,249],[89,249],[90,250],[91,251],[92,252],[93,253],[78,2],[126,2],[94,254],[95,255],[96,256],[127,257],[97,258],[98,259],[99,260],[100,261],[101,262],[102,263],[103,264],[104,265],[105,266],[106,267],[107,268],[108,269],[110,270],[109,271],[111,272],[112,273],[113,2],[114,274],[115,275],[116,276],[117,277],[118,278],[119,279],[120,280],[121,281],[122,282],[123,283],[124,284],[125,285],[668,2],[669,12],[670,2],[617,2],[301,286],[300,2],[671,12],[696,287],[697,288],[672,289],[675,289],[694,287],[695,287],[685,287],[684,290],[682,287],[677,287],[690,287],[688,287],[692,287],[676,287],[689,287],[693,287],[678,287],[679,287],[691,287],[673,287],[680,287],[681,287],[683,287],[687,287],[698,291],[686,287],[674,287],[711,292],[710,2],[705,291],[707,293],[706,291],[699,291],[700,291],[702,291],[704,291],[708,293],[709,293],[701,293],[703,293],[713,294],[712,2],[714,2],[470,2],[715,2],[716,295],[616,296],[615,2],[410,297],[409,2],[412,298],[411,2],[414,299],[413,300],[130,2],[655,2],[482,301],[489,302],[483,303],[484,304],[487,305],[485,306],[486,307],[480,308],[475,309],[476,309],[478,310],[477,311],[479,309],[492,312],[491,313],[490,314],[481,12],[488,315],[493,2],[494,2],[497,316],[495,317],[496,2],[498,318],[556,2],[557,319],[215,320],[216,321],[217,321],[218,322],[177,2],[174,323],[176,323],[175,323],[173,323],[183,324],[178,325],[182,2],[179,2],[181,2],[180,2],[169,323],[170,323],[171,323],[167,2],[168,2],[172,323],[656,2],[660,326],[662,327],[661,326],[659,328],[663,329],[463,2],[465,330],[464,2],[568,2],[658,331],[657,2],[57,2],[64,332],[59,333],[60,334],[61,334],[62,335],[63,335],[58,336],[8,2],[10,2],[9,2],[2,2],[11,2],[12,2],[13,2],[14,2],[15,2],[16,2],[17,2],[18,2],[3,2],[4,2],[22,2],[19,2],[20,2],[21,2],[23,2],[24,2],[25,2],[5,2],[26,2],[27,2],[28,2],[29,2],[6,2],[33,2],[30,2],[31,2],[32,2],[34,2],[7,2],[35,2],[40,2],[41,2],[36,2],[37,2],[38,2],[39,2],[1,2],[42,2],[636,337],[638,338],[637,339],[467,340],[468,2],[469,341],[428,406],[531,407],[532,408],[473,409],[472,410],[523,411],[524,411],[530,412],[533,413],[639,414],[526,415],[528,416],[527,417],[529,418],[640,419],[474,420],[499,421],[500,359],[525,420],[56,2],[186,361],[185,362],[184,363],[187,364],[189,365],[197,366],[196,367],[188,2],[192,368],[214,369],[212,370],[213,371],[211,372],[204,373],[205,374],[206,374],[207,2],[208,374],[210,375],[209,374],[404,376],[405,377],[397,378],[402,379],[401,379],[398,379],[399,380],[400,379],[403,381],[221,382],[202,2],[220,383],[222,383],[223,384],[219,385],[576,386],[574,387],[573,388],[571,389],[575,390],[581,391],[570,392],[577,393],[580,394],[578,395],[579,396],[572,397],[619,398],[620,399],[618,399],[225,400],[226,401],[227,402],[224,403],[407,404],[406,2],[408,405],[47,2],[48,2],[49,2],[50,2],[51,2],[52,2],[43,2],[53,2],[54,2],[55,2],[44,2],[45,2],[46,2]],"semanticDiagnosticsPerFile":[643,641,145,128,147,129,146,151,152,148,154,149,153,150,136,133,140,134,131,139,144,141,142,143,138,135,132,137,435,434,433,438,437,443,444,466,430,431,432,429,445,440,439,436,451,452,447,453,454,455,446,462,457,456,458,448,459,460,450,461,449,441,442,266,265,267,262,260,261,264,263,246,251,240,245,244,242,249,250,252,247,241,239,238,248,254,253,255,256,257,259,229,230,231,228,243,258,276,277,278,275,520,521,522,508,509,510,511,512,513,517,514,507,515,516,518,519,279,190,350,352,351,342,347,344,348,346,353,354,356,355,357,349,295,296,308,281,282,284,283,286,285,287,396,288,289,290,291,294,292,293,309,395,280,504,502,503,505,506,535,534,536,271,272,269,270,274,273,268,538,541,540,547,543,542,545,544,546,537,539,298,299,304,302,303,307,305,306,297,311,313,312,314,310,203,633,634,635,621,622,600,599,601,602,603,609,605,606,604,607,608,629,628,631,612,614,613,611,610,627,626,625,630,623,624,632,591,590,322,315,339,394,316,317,318,321,319,320,358,381,383,384,392,385,386,387,388,390,389,391,382,393,366,340,341,360,361,362,363,364,365,367,368,370,379,372,371,373,374,378,375,376,377,359,380,369,337,324,333,325,326,335,327,328,336,334,329,332,330,331,338,323,548,549,552,553,554,555,558,559,560,561,562,563,564,565,566,598,582,567,586,587,585,584,588,589,593,594,583,592,595,596,597,550,551,199,200,201,198,65,66,68,69,70,71,72,73,74,67,166,75,155,158,159,160,161,162,163,164,165,235,234,237,232,236,233,343,345,193,195,194,646,642,644,645,191,157,569,647,650,648,651,652,653,654,665,664,649,666,416,417,415,418,419,420,421,422,423,424,425,426,427,667,156,76,77,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,78,126,94,95,96,127,97,98,99,100,101,102,103,104,105,106,107,108,110,109,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,668,669,670,617,301,300,671,696,697,672,675,694,695,685,684,682,677,690,688,692,676,689,693,678,679,691,673,680,681,683,687,698,686,674,711,710,705,707,706,699,700,702,704,708,709,701,703,713,712,714,470,715,716,616,615,410,409,412,411,414,413,130,655,482,489,483,484,487,485,486,480,475,476,478,477,479,492,491,490,481,488,493,494,497,495,496,498,556,557,215,216,217,218,177,174,176,175,173,183,178,182,179,181,180,169,170,171,167,168,172,656,660,662,661,659,663,463,465,464,568,658,657,57,64,59,60,61,62,63,58,8,10,9,2,11,12,13,14,15,16,17,18,3,4,22,19,20,21,23,24,25,5,26,27,28,29,6,33,30,31,32,34,7,35,40,41,36,37,38,39,1,42,636,638,637,467,468,469,428,531,532,473,472,523,524,530,533,639,526,528,527,529,471,501,640,474,499,500,525,56,186,185,184,187,189,197,196,188,192,214,212,213,211,204,205,206,207,208,210,209,404,405,397,402,401,398,399,400,403,221,202,220,222,223,219,576,574,573,571,575,581,570,577,580,578,579,572,619,620,618,225,226,227,224,407,406,408,47,48,49,50,51,52,43,53,54,55,44,45,46],"latestChangedDtsFile":"./types/index.d.ts"},"version":"4.9.5"}
\ No newline at end of file
+{"program":{"fileNames":["../../../node_modules/typescript/lib/lib.es5.d.ts","../../../node_modules/typescript/lib/lib.es2015.d.ts","../../../node_modules/typescript/lib/lib.es2016.d.ts","../../../node_modules/typescript/lib/lib.es2017.d.ts","../../../node_modules/typescript/lib/lib.es2018.d.ts","../../../node_modules/typescript/lib/lib.es2019.d.ts","../../../node_modules/typescript/lib/lib.es2020.d.ts","../../../node_modules/typescript/lib/lib.dom.d.ts","../../../node_modules/typescript/lib/lib.es2015.core.d.ts","../../../node_modules/typescript/lib/lib.es2015.collection.d.ts","../../../node_modules/typescript/lib/lib.es2015.generator.d.ts","../../../node_modules/typescript/lib/lib.es2015.iterable.d.ts","../../../node_modules/typescript/lib/lib.es2015.promise.d.ts","../../../node_modules/typescript/lib/lib.es2015.proxy.d.ts","../../../node_modules/typescript/lib/lib.es2015.reflect.d.ts","../../../node_modules/typescript/lib/lib.es2015.symbol.d.ts","../../../node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts","../../../node_modules/typescript/lib/lib.es2016.array.include.d.ts","../../../node_modules/typescript/lib/lib.es2017.object.d.ts","../../../node_modules/typescript/lib/lib.es2017.sharedmemory.d.ts","../../../node_modules/typescript/lib/lib.es2017.string.d.ts","../../../node_modules/typescript/lib/lib.es2017.intl.d.ts","../../../node_modules/typescript/lib/lib.es2017.typedarrays.d.ts","../../../node_modules/typescript/lib/lib.es2018.asyncgenerator.d.ts","../../../node_modules/typescript/lib/lib.es2018.asynciterable.d.ts","../../../node_modules/typescript/lib/lib.es2018.intl.d.ts","../../../node_modules/typescript/lib/lib.es2018.promise.d.ts","../../../node_modules/typescript/lib/lib.es2018.regexp.d.ts","../../../node_modules/typescript/lib/lib.es2019.array.d.ts","../../../node_modules/typescript/lib/lib.es2019.object.d.ts","../../../node_modules/typescript/lib/lib.es2019.string.d.ts","../../../node_modules/typescript/lib/lib.es2019.symbol.d.ts","../../../node_modules/typescript/lib/lib.es2019.intl.d.ts","../../../node_modules/typescript/lib/lib.es2020.bigint.d.ts","../../../node_modules/typescript/lib/lib.es2020.date.d.ts","../../../node_modules/typescript/lib/lib.es2020.promise.d.ts","../../../node_modules/typescript/lib/lib.es2020.sharedmemory.d.ts","../../../node_modules/typescript/lib/lib.es2020.string.d.ts","../../../node_modules/typescript/lib/lib.es2020.symbol.wellknown.d.ts","../../../node_modules/typescript/lib/lib.es2020.intl.d.ts","../../../node_modules/typescript/lib/lib.es2020.number.d.ts","../../../node_modules/typescript/lib/lib.esnext.intl.d.ts","../../../types/eth-ens-namehash.d.ts","../../../types/ethereum-ens-network-map.d.ts","../../../types/global.d.ts","../../../types/single-call-balance-checker-abi.d.ts","../../../types/@metamask/contract-metadata.d.ts","../../../types/@metamask/eth-hd-keyring.d.ts","../../../types/@metamask/eth-simple-keyring.d.ts","../../../types/@metamask/ethjs-provider-http.d.ts","../../../types/@metamask/ethjs-unit.d.ts","../../../types/@metamask/metamask-eth-abis.d.ts","../../../types/eth-json-rpc-infura/src/createprovider.d.ts","../../../types/eth-phishing-detect/src/config.json.d.ts","../../../types/eth-phishing-detect/src/detector.d.ts","../../base-controller/dist/types/basecontrollerv1.d.ts","../../../node_modules/superstruct/dist/error.d.ts","../../../node_modules/superstruct/dist/utils.d.ts","../../../node_modules/superstruct/dist/struct.d.ts","../../../node_modules/superstruct/dist/structs/coercions.d.ts","../../../node_modules/superstruct/dist/structs/refinements.d.ts","../../../node_modules/superstruct/dist/structs/types.d.ts","../../../node_modules/superstruct/dist/structs/utilities.d.ts","../../../node_modules/superstruct/dist/index.d.ts","../../../node_modules/@metamask/utils/dist/types/assert.d.ts","../../../node_modules/@metamask/utils/dist/types/base64.d.ts","../../../node_modules/@metamask/utils/dist/types/hex.d.ts","../../../node_modules/@metamask/utils/dist/types/bytes.d.ts","../../../node_modules/@metamask/utils/dist/types/caip-types.d.ts","../../../node_modules/@metamask/utils/dist/types/checksum.d.ts","../../../node_modules/@metamask/utils/dist/types/coercers.d.ts","../../../node_modules/@metamask/utils/dist/types/collections.d.ts","../../../node_modules/@metamask/utils/dist/types/encryption-types.d.ts","../../../node_modules/@metamask/utils/dist/types/errors.d.ts","../../../node_modules/@metamask/utils/dist/types/json.d.ts","../../../node_modules/@types/node/assert.d.ts","../../../node_modules/@types/node/assert/strict.d.ts","../../../node_modules/@types/node/globals.d.ts","../../../node_modules/@types/node/async_hooks.d.ts","../../../node_modules/@types/node/buffer.d.ts","../../../node_modules/@types/node/child_process.d.ts","../../../node_modules/@types/node/cluster.d.ts","../../../node_modules/@types/node/console.d.ts","../../../node_modules/@types/node/constants.d.ts","../../../node_modules/@types/node/crypto.d.ts","../../../node_modules/@types/node/dgram.d.ts","../../../node_modules/@types/node/diagnostics_channel.d.ts","../../../node_modules/@types/node/dns.d.ts","../../../node_modules/@types/node/dns/promises.d.ts","../../../node_modules/@types/node/dom-events.d.ts","../../../node_modules/@types/node/domain.d.ts","../../../node_modules/@types/node/events.d.ts","../../../node_modules/@types/node/fs.d.ts","../../../node_modules/@types/node/fs/promises.d.ts","../../../node_modules/@types/node/http.d.ts","../../../node_modules/@types/node/http2.d.ts","../../../node_modules/@types/node/https.d.ts","../../../node_modules/@types/node/inspector.d.ts","../../../node_modules/@types/node/module.d.ts","../../../node_modules/@types/node/net.d.ts","../../../node_modules/@types/node/os.d.ts","../../../node_modules/@types/node/path.d.ts","../../../node_modules/@types/node/perf_hooks.d.ts","../../../node_modules/@types/node/process.d.ts","../../../node_modules/@types/node/punycode.d.ts","../../../node_modules/@types/node/querystring.d.ts","../../../node_modules/@types/node/readline.d.ts","../../../node_modules/@types/node/repl.d.ts","../../../node_modules/@types/node/stream.d.ts","../../../node_modules/@types/node/stream/promises.d.ts","../../../node_modules/@types/node/stream/consumers.d.ts","../../../node_modules/@types/node/stream/web.d.ts","../../../node_modules/@types/node/string_decoder.d.ts","../../../node_modules/@types/node/test.d.ts","../../../node_modules/@types/node/timers.d.ts","../../../node_modules/@types/node/timers/promises.d.ts","../../../node_modules/@types/node/tls.d.ts","../../../node_modules/@types/node/trace_events.d.ts","../../../node_modules/@types/node/tty.d.ts","../../../node_modules/@types/node/url.d.ts","../../../node_modules/@types/node/util.d.ts","../../../node_modules/@types/node/v8.d.ts","../../../node_modules/@types/node/vm.d.ts","../../../node_modules/@types/node/wasi.d.ts","../../../node_modules/@types/node/worker_threads.d.ts","../../../node_modules/@types/node/zlib.d.ts","../../../node_modules/@types/node/globals.global.d.ts","../../../node_modules/@types/node/index.d.ts","../../../node_modules/@ethereumjs/common/dist/enums.d.ts","../../../node_modules/@ethereumjs/common/dist/types.d.ts","../../../node_modules/buffer/index.d.ts","../../../node_modules/@ethereumjs/util/dist/constants.d.ts","../../../node_modules/@ethereumjs/util/dist/units.d.ts","../../../node_modules/@ethereumjs/util/dist/address.d.ts","../../../node_modules/@ethereumjs/util/dist/bytes.d.ts","../../../node_modules/@ethereumjs/util/dist/types.d.ts","../../../node_modules/@ethereumjs/util/dist/account.d.ts","../../../node_modules/@ethereumjs/util/dist/withdrawal.d.ts","../../../node_modules/@ethereumjs/util/dist/signature.d.ts","../../../node_modules/@ethereumjs/util/dist/encoding.d.ts","../../../node_modules/@ethereumjs/util/dist/asynceventemitter.d.ts","../../../node_modules/@ethereumjs/util/dist/internal.d.ts","../../../node_modules/@ethereumjs/util/dist/lock.d.ts","../../../node_modules/@ethereumjs/util/dist/provider.d.ts","../../../node_modules/@ethereumjs/util/dist/index.d.ts","../../../node_modules/@ethereumjs/common/dist/common.d.ts","../../../node_modules/@ethereumjs/common/dist/utils.d.ts","../../../node_modules/@ethereumjs/common/dist/index.d.ts","../../../node_modules/@ethereumjs/tx/dist/eip2930transaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/legacytransaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/types.d.ts","../../../node_modules/@ethereumjs/tx/dist/basetransaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/eip1559transaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/transactionfactory.d.ts","../../../node_modules/@ethereumjs/tx/dist/index.d.ts","../../../node_modules/@metamask/utils/dist/types/keyring.d.ts","../../../node_modules/@types/ms/index.d.ts","../../../node_modules/@types/debug/index.d.ts","../../../node_modules/@metamask/utils/dist/types/logging.d.ts","../../../node_modules/@metamask/utils/dist/types/misc.d.ts","../../../node_modules/@metamask/utils/dist/types/number.d.ts","../../../node_modules/@metamask/utils/dist/types/opaque.d.ts","../../../node_modules/@metamask/utils/dist/types/promise.d.ts","../../../node_modules/@metamask/utils/dist/types/time.d.ts","../../../node_modules/@metamask/utils/dist/types/transaction-types.d.ts","../../../node_modules/@metamask/utils/dist/types/versions.d.ts","../../../node_modules/@metamask/utils/dist/types/index.d.ts","../../../node_modules/immer/dist/utils/env.d.ts","../../../node_modules/immer/dist/utils/errors.d.ts","../../../node_modules/immer/dist/types/types-external.d.ts","../../../node_modules/immer/dist/types/types-internal.d.ts","../../../node_modules/immer/dist/utils/common.d.ts","../../../node_modules/immer/dist/utils/plugins.d.ts","../../../node_modules/immer/dist/core/scope.d.ts","../../../node_modules/immer/dist/core/finalize.d.ts","../../../node_modules/immer/dist/core/proxy.d.ts","../../../node_modules/immer/dist/core/immerclass.d.ts","../../../node_modules/immer/dist/core/current.d.ts","../../../node_modules/immer/dist/internal.d.ts","../../../node_modules/immer/dist/plugins/es5.d.ts","../../../node_modules/immer/dist/plugins/patches.d.ts","../../../node_modules/immer/dist/plugins/mapset.d.ts","../../../node_modules/immer/dist/plugins/all.d.ts","../../../node_modules/immer/dist/immer.d.ts","../../base-controller/dist/types/restrictedcontrollermessenger.d.ts","../../base-controller/dist/types/controllermessenger.d.ts","../../base-controller/dist/types/basecontrollerv2.d.ts","../../base-controller/dist/types/index.d.ts","../../controller-utils/dist/types/types.d.ts","../../controller-utils/dist/types/constants.d.ts","../../../node_modules/@metamask/eth-query/index.d.ts","../../../node_modules/@types/bn.js/index.d.ts","../../controller-utils/dist/types/util.d.ts","../../../node_modules/@spruceid/siwe-parser/dist/abnf.d.ts","../../../node_modules/@spruceid/siwe-parser/dist/utils.d.ts","../../../node_modules/@spruceid/siwe-parser/dist/parsers.d.ts","../../controller-utils/dist/types/siwe.d.ts","../../controller-utils/dist/types/index.d.ts","../../../node_modules/@metamask/swappable-obj-proxy/dist/types.d.ts","../../../node_modules/@metamask/swappable-obj-proxy/dist/createeventemitterproxy.d.ts","../../../node_modules/@metamask/swappable-obj-proxy/dist/createswappableproxy.d.ts","../../../node_modules/@metamask/swappable-obj-proxy/dist/index.d.ts","../../network-controller/dist/types/constants.d.ts","../../../node_modules/@metamask/safe-event-emitter/dist/cjs/index.d.ts","../../json-rpc-engine/dist/types/jsonrpcengine.d.ts","../../json-rpc-engine/dist/types/createasyncmiddleware.d.ts","../../json-rpc-engine/dist/types/createscaffoldmiddleware.d.ts","../../json-rpc-engine/dist/types/getuniqueid.d.ts","../../json-rpc-engine/dist/types/idremapmiddleware.d.ts","../../json-rpc-engine/dist/types/mergemiddleware.d.ts","../../json-rpc-engine/dist/types/index.d.ts","../../eth-json-rpc-provider/dist/types/safe-event-emitter-provider.d.ts","../../eth-json-rpc-provider/dist/types/provider-from-engine.d.ts","../../eth-json-rpc-provider/dist/types/provider-from-middleware.d.ts","../../eth-json-rpc-provider/dist/types/index.d.ts","../../../node_modules/eth-block-tracker/dist/blocktracker.d.ts","../../../node_modules/eth-block-tracker/dist/pollingblocktracker.d.ts","../../../node_modules/eth-block-tracker/dist/subscribeblocktracker.d.ts","../../../node_modules/eth-block-tracker/dist/index.d.ts","../../network-controller/dist/types/types.d.ts","../../network-controller/dist/types/create-auto-managed-network-client.d.ts","../../network-controller/dist/types/networkcontroller.d.ts","../../network-controller/dist/types/create-network-client.d.ts","../../network-controller/dist/types/index.d.ts","../../polling-controller/dist/types/types.d.ts","../../polling-controller/dist/types/blocktrackerpollingcontroller.d.ts","../../polling-controller/dist/types/staticintervalpollingcontroller.d.ts","../../polling-controller/dist/types/index.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/patchcbor.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/lib/dataitem.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/lib/cbor-sync.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/lib/index.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/ur.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/urencoder.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/fountainencoder.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/fountaindecoder.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/urdecoder.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/index.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/registrytype.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/registryitem.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/cryptocoininfo.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/pathcomponent.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/cryptokeypath.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/types.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/cryptohdkey.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/cryptoeckey.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/bytes.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/multikey.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/scriptexpression.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/cryptooutput.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/cryptopsbt.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/cryptoaccount.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/decoder/index.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/extended/cryptomultiaccounts.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/errors/index.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/extended/derivationschema.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/extended/keyderivation.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/extended/qrhardwarecall.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/utils.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry/dist/index.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/ethsignrequest.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/ethsignature.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/ethnftitem.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/utlis.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/index.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/dist/interactionprovider.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/dist/basekeyring.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/dist/index.d.ts","../../../node_modules/@metamask/obs-store/node_modules/@metamask/safe-event-emitter/index.d.ts","../../../node_modules/@metamask/obs-store/dist/observablestore.d.ts","../../../node_modules/@metamask/obs-store/dist/asstream.d.ts","../../../node_modules/@metamask/obs-store/dist/composedstore.d.ts","../../../node_modules/@metamask/obs-store/dist/mergedstore.d.ts","../../../node_modules/@metamask/obs-store/dist/transform.d.ts","../../../node_modules/@metamask/obs-store/dist/index.d.ts","../../../node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/index.d.ts","../../../node_modules/@keystonehq/metamask-airgapped-keyring/dist/metamaskinteractionprovider.d.ts","../../../node_modules/@keystonehq/metamask-airgapped-keyring/dist/metamaskkeyring.d.ts","../../../node_modules/@keystonehq/metamask-airgapped-keyring/dist/index.d.ts","../../../node_modules/@metamask/browser-passworder/dist/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/superstruct.d.ts","../../../node_modules/@metamask/keyring-api/dist/api.d.ts","../../../node_modules/@metamask/keyring-api/dist/contexts.d.ts","../../../node_modules/@metamask/keyring-api/dist/eth/erc4337/types.d.ts","../../../node_modules/@metamask/keyring-api/dist/eth/erc4337/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/eth/types.d.ts","../../../node_modules/@metamask/keyring-api/dist/eth/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/events.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/api.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/eth/ethkeyring.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/eth/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/events.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/rpc.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/types.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/jsonrpcrequest.d.ts","../../../node_modules/@metamask/keyring-api/dist/keyringclient.d.ts","../../../node_modules/@metamask/providers/dist/types/utils.d.ts","../../../node_modules/@metamask/providers/dist/types/baseprovider.d.ts","../../../node_modules/@metamask/providers/dist/types/eip6963.d.ts","../../../node_modules/@types/readable-stream/node_modules/safe-buffer/index.d.ts","../../../node_modules/@types/readable-stream/index.d.ts","../../../node_modules/@metamask/providers/dist/types/streamprovider.d.ts","../../../node_modules/@metamask/providers/dist/types/extension-provider/createexternalextensionprovider.d.ts","../../../node_modules/@metamask/providers/dist/types/metamaskinpageprovider.d.ts","../../../node_modules/@metamask/providers/dist/types/initializeinpageprovider.d.ts","../../../node_modules/@metamask/providers/dist/types/shimweb3.d.ts","../../../node_modules/@metamask/providers/dist/types/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/keyringsnaprpcclient.d.ts","../../../node_modules/@metamask/keyring-api/dist/rpc-handler.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/utils.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/classes.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/errors.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/error-constants.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/errors.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/error-wrappers.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/errors.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/helpers.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/structs.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/svg.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/error-wrappers.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/nodes.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/address.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/copyable.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/divider.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/heading.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/image.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/panel.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/spinner.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/text.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/row.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/button.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/input.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/form.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/component.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/images.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/create-interface.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/dialog.d.ts","../../../node_modules/@metamask/key-tree/dist/types/constants.d.ts","../../../node_modules/@noble/ed25519/lib/index.d.ts","../../../node_modules/@metamask/key-tree/dist/types/curves/ed25519.d.ts","../../../node_modules/@noble/secp256k1/lib/index.d.ts","../../../node_modules/@metamask/key-tree/dist/types/curves/secp256k1.d.ts","../../../node_modules/@metamask/key-tree/dist/types/curves/curve.d.ts","../../../node_modules/@metamask/key-tree/dist/types/curves/index.d.ts","../../../node_modules/@metamask/key-tree/dist/types/utils.d.ts","../../../node_modules/@metamask/key-tree/dist/types/bip44cointypenode.d.ts","../../../node_modules/@metamask/key-tree/dist/types/slip10node.d.ts","../../../node_modules/@metamask/key-tree/dist/types/bip44node.d.ts","../../../node_modules/@metamask/key-tree/dist/types/derivers/bip32.d.ts","../../../node_modules/@metamask/key-tree/dist/types/derivers/bip39.d.ts","../../../node_modules/@metamask/key-tree/dist/types/derivers/slip10.d.ts","../../../node_modules/@metamask/key-tree/dist/types/derivers/index.d.ts","../../../node_modules/@metamask/key-tree/dist/types/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/caip.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/permissions.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-bip32-entropy.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-bip32-public-key.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-bip44-entropy.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-client-status.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-entropy.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-file.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/interface.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-interface-state.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-locale.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/snap.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-snaps.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/invoke-snap.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/invoke-keyring.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/manage-accounts.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/manage-state.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/notify.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/request-snaps.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/update-interface.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/methods.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/provider.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/global.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/images.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/cronjob.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/home-page.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/keyring.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/lifecycle.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/name-lookup.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/rpc-request.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/transaction.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/signature.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/user-input.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/snap-utils.d.ts","../../../node_modules/@metamask/keyring-api/dist/index.d.ts","../../message-manager/dist/types/abstractmessagemanager.d.ts","../../message-manager/dist/types/messagemanager.d.ts","../../message-manager/dist/types/personalmessagemanager.d.ts","../../message-manager/dist/types/typedmessagemanager.d.ts","../../message-manager/dist/types/encryptionpublickeymanager.d.ts","../../message-manager/dist/types/decryptmessagemanager.d.ts","../../message-manager/dist/types/index.d.ts","../../keyring-controller/dist/types/keyringcontroller.d.ts","../../keyring-controller/dist/types/index.d.ts","../../preferences-controller/dist/types/constants.d.ts","../../preferences-controller/dist/types/preferencescontroller.d.ts","../../preferences-controller/dist/types/index.d.ts","../../../node_modules/async-mutex/lib/mutexinterface.d.ts","../../../node_modules/async-mutex/lib/mutex.d.ts","../../../node_modules/async-mutex/lib/semaphoreinterface.d.ts","../../../node_modules/async-mutex/lib/semaphore.d.ts","../../../node_modules/async-mutex/lib/withtimeout.d.ts","../../../node_modules/async-mutex/lib/index.d.ts","../../../node_modules/@types/lodash/common/common.d.ts","../../../node_modules/@types/lodash/common/array.d.ts","../../../node_modules/@types/lodash/common/collection.d.ts","../../../node_modules/@types/lodash/common/date.d.ts","../../../node_modules/@types/lodash/common/function.d.ts","../../../node_modules/@types/lodash/common/lang.d.ts","../../../node_modules/@types/lodash/common/math.d.ts","../../../node_modules/@types/lodash/common/number.d.ts","../../../node_modules/@types/lodash/common/object.d.ts","../../../node_modules/@types/lodash/common/seq.d.ts","../../../node_modules/@types/lodash/common/string.d.ts","../../../node_modules/@types/lodash/common/util.d.ts","../../../node_modules/@types/lodash/index.d.ts","../src/accounttrackercontroller.ts","../../../node_modules/@ethersproject/bytes/lib/index.d.ts","../../../node_modules/@ethersproject/bignumber/lib/bignumber.d.ts","../../../node_modules/@ethersproject/bignumber/lib/fixednumber.d.ts","../../../node_modules/@ethersproject/bignumber/lib/index.d.ts","../../../node_modules/@ethersproject/abi/lib/fragments.d.ts","../../../node_modules/@ethersproject/abi/lib/coders/abstract-coder.d.ts","../../../node_modules/@ethersproject/abi/lib/abi-coder.d.ts","../../../node_modules/@ethersproject/properties/lib/index.d.ts","../../../node_modules/@ethersproject/abi/lib/interface.d.ts","../../../node_modules/@ethersproject/abi/lib/index.d.ts","../../../node_modules/@ethersproject/networks/lib/types.d.ts","../../../node_modules/@ethersproject/networks/lib/index.d.ts","../../../node_modules/@ethersproject/transactions/lib/index.d.ts","../../../node_modules/@ethersproject/web/lib/index.d.ts","../../../node_modules/@ethersproject/abstract-provider/lib/index.d.ts","../../../node_modules/@ethersproject/abstract-signer/lib/index.d.ts","../../../node_modules/@ethersproject/contracts/lib/index.d.ts","../../../node_modules/@ethersproject/providers/lib/formatter.d.ts","../../../node_modules/@ethersproject/providers/lib/base-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/json-rpc-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/websocket-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/url-json-rpc-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/alchemy-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/ankr-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/cloudflare-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/etherscan-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/fallback-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/ipc-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/infura-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/json-rpc-batch-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/nodesmith-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/pocket-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/web3-provider.d.ts","../../../node_modules/@ethersproject/providers/lib/index.d.ts","../../../node_modules/multiformats/types/src/bases/interface.d.ts","../../../node_modules/multiformats/types/src/hashes/interface.d.ts","../../../node_modules/multiformats/types/src/cid.d.ts","../../../node_modules/@ethersproject/address/lib/index.d.ts","../../approval-controller/dist/types/approvalcontroller.d.ts","../../approval-controller/dist/types/errors.d.ts","../../approval-controller/dist/types/index.d.ts","../../../node_modules/@types/uuid/index.d.ts","../src/constants.ts","../src/nftdetectioncontroller.ts","../src/nftcontroller.ts","../src/token-prices-service/abstract-token-prices-service.ts","../../../node_modules/cockatiel/dist/backoff/constantbackoff.d.ts","../../../node_modules/cockatiel/dist/backoff/delegatebackoff.d.ts","../../../node_modules/cockatiel/dist/backoff/exponentialbackoffgenerators.d.ts","../../../node_modules/cockatiel/dist/backoff/exponentialbackoff.d.ts","../../../node_modules/cockatiel/dist/backoff/iterablebackoff.d.ts","../../../node_modules/cockatiel/dist/backoff/backoff.d.ts","../../../node_modules/cockatiel/dist/common/event.d.ts","../../../node_modules/cockatiel/dist/bulkheadpolicy.d.ts","../../../node_modules/cockatiel/dist/fallbackpolicy.d.ts","../../../node_modules/cockatiel/dist/nooppolicy.d.ts","../../../node_modules/cockatiel/dist/retrypolicy.d.ts","../../../node_modules/cockatiel/dist/timeoutpolicy.d.ts","../../../node_modules/cockatiel/dist/policy.d.ts","../../../node_modules/cockatiel/dist/common/executor.d.ts","../../../node_modules/cockatiel/dist/circuitbreakerpolicy.d.ts","../../../node_modules/cockatiel/dist/breaker/samplingbreaker.d.ts","../../../node_modules/cockatiel/dist/breaker/consecutivebreaker.d.ts","../../../node_modules/cockatiel/dist/breaker/breaker.d.ts","../../../node_modules/cockatiel/dist/errors/brokencircuiterror.d.ts","../../../node_modules/cockatiel/dist/errors/bulkheadrejectederror.d.ts","../../../node_modules/cockatiel/dist/errors/isolatedcircuiterror.d.ts","../../../node_modules/cockatiel/dist/errors/taskcancellederror.d.ts","../../../node_modules/cockatiel/dist/errors/errors.d.ts","../../../node_modules/cockatiel/dist/index.d.ts","../src/token-prices-service/codefi-v2.ts","../src/token-prices-service/index.ts","../src/crypto-compare.ts","../../../node_modules/@metamask/metamask-eth-abis/dist/abis/abierc20.d.ts","../../../node_modules/@metamask/metamask-eth-abis/dist/abis/abierc721.d.ts","../../../node_modules/@metamask/metamask-eth-abis/dist/abis/abierc1155.d.ts","../../../node_modules/@metamask/metamask-eth-abis/dist/abis/fiattokenv2.d.ts","../../../node_modules/@metamask/metamask-eth-abis/dist/index.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/parser.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/address.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/array.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/bool.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/bytes.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/fixed-bytes.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/function.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/number.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/string.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/tuple.d.ts","../../../node_modules/@metamask/abi-utils/dist/parsers/index.d.ts","../../../node_modules/@metamask/abi-utils/dist/types/abi.d.ts","../../../node_modules/@metamask/abi-utils/dist/types/index.d.ts","../../../node_modules/@metamask/abi-utils/dist/abi.d.ts","../../../node_modules/@metamask/abi-utils/dist/errors.d.ts","../../../node_modules/@metamask/abi-utils/dist/index.d.ts","../src/standards/erc20standard.ts","../src/standards/nftstandards/erc1155/erc1155standard.ts","../src/token-service.ts","../src/tokenlistcontroller.ts","../src/tokenscontroller.ts","../src/tokenratescontroller.ts","../src/assetsutil.ts","../src/standards/nftstandards/erc721/erc721standard.ts","../src/assetscontractcontroller.ts","../src/currencyratecontroller.ts","../src/tokenbalancescontroller.ts","../../../node_modules/@metamask/object-multiplex/dist/substream.d.ts","../../../node_modules/@metamask/object-multiplex/dist/objectmultiplex.d.ts","../../../node_modules/@metamask/object-multiplex/dist/index.d.ts","../../../node_modules/@metamask/post-message-stream/dist/utils.d.ts","../../../node_modules/@metamask/post-message-stream/dist/basepostmessagestream.d.ts","../../../node_modules/@metamask/post-message-stream/dist/window/windowpostmessagestream.d.ts","../../../node_modules/@metamask/post-message-stream/dist/webworker/webworkerpostmessagestream.d.ts","../../../node_modules/@metamask/post-message-stream/dist/webworker/webworkerparentpostmessagestream.d.ts","../../../node_modules/@metamask/post-message-stream/dist/node-process/processparentmessagestream.d.ts","../../../node_modules/@metamask/post-message-stream/dist/node-process/processmessagestream.d.ts","../../../node_modules/@metamask/post-message-stream/dist/node-thread/threadparentmessagestream.d.ts","../../../node_modules/@metamask/post-message-stream/dist/node-thread/threadmessagestream.d.ts","../../../node_modules/@metamask/post-message-stream/dist/runtime/browserruntimepostmessagestream.d.ts","../../../node_modules/@metamask/post-message-stream/dist/index.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/array.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/auxiliary-files.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/virtual-file/virtualfile.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/virtual-file/index.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/base64.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/bytes.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/caveats.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/checksum.d.ts","../../../node_modules/cron-parser/types/common.d.ts","../../../node_modules/cron-parser/types/index.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/cronjob.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/deep-clone.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/default-endowments.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/derivation-paths.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/entropy.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/errors.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/handler-types.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/handlers.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/iframe.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/json.d.ts","../../../node_modules/nanoid/index.d.ts","../../../node_modules/@types/deep-freeze-strict/index.d.ts","../../permission-controller/src/permission-middleware.ts","../../permission-controller/src/subjectmetadatacontroller.ts","../../permission-controller/src/utils.ts","../../permission-controller/src/permissioncontroller.ts","../../permission-controller/src/permission.ts","../../permission-controller/src/errors.ts","../../permission-controller/src/caveat.ts","../../permission-controller/src/rpc-methods/getpermissions.ts","../../permission-controller/src/rpc-methods/requestpermissions.ts","../../permission-controller/src/rpc-methods/revokepermissions.ts","../../permission-controller/src/rpc-methods/index.ts","../../permission-controller/src/index.ts","../../../node_modules/@metamask/snaps-utils/dist/types/json-rpc.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/structs.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/manifest/validation.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/manifest/index.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/localization.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/logging.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/namespace.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/path.d.ts","../../../node_modules/@metamask/snaps-registry/dist/verify.d.ts","../../../node_modules/@metamask/snaps-registry/dist/index.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/types.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/snaps.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/strings.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/ui.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/validation.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/versions.d.ts","../../../node_modules/@metamask/snaps-utils/dist/types/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/executionservice.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/abstractexecutionservice.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/proxypostmessagestream.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/iframe/iframeexecutionservice.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/iframe/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/proxy/proxyexecutionservice.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/offscreen/offscreenexecutionservice.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/offscreen/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/webworker/webworkerexecutionservice.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/webworker/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/services/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/location/npm.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/location/location.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/location/http.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/location/local.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/location/index.d.ts","../../../node_modules/@xstate/fsm/lib/types.d.ts","../../../node_modules/@xstate/fsm/lib/index.d.ts","../../../node_modules/@types/punycode/index.d.ts","../../phishing-controller/src/utils.ts","../../phishing-controller/src/phishingcontroller.ts","../../phishing-controller/src/index.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/interface/snapinterfacecontroller.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/interface/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/types/encryptor.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/types/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/registry/registry.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/registry/json.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/registry/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/timer.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/snapcontroller.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/selectors.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/snaps/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/utils.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/cronjob/cronjobcontroller.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/cronjob/index.d.ts","../../../node_modules/@metamask/snaps-controllers/dist/types/index.d.ts","../../accounts-controller/dist/types/accountscontroller.d.ts","../../accounts-controller/dist/types/utils.d.ts","../../accounts-controller/dist/types/index.d.ts","../src/tokendetectioncontroller.ts","../src/index.ts","../../../node_modules/@babel/types/lib/index.d.ts","../../../node_modules/@types/babel__generator/index.d.ts","../../../node_modules/@babel/parser/typings/babel-parser.d.ts","../../../node_modules/@types/babel__template/index.d.ts","../../../node_modules/@types/babel__traverse/index.d.ts","../../../node_modules/@types/babel__core/index.d.ts","../../../node_modules/@types/eslint/helpers.d.ts","../../../node_modules/@types/estree/index.d.ts","../../../node_modules/@types/json-schema/index.d.ts","../../../node_modules/@types/eslint/index.d.ts","../../../node_modules/@types/graceful-fs/index.d.ts","../../../node_modules/@types/istanbul-lib-coverage/index.d.ts","../../../node_modules/@types/istanbul-lib-report/index.d.ts","../../../node_modules/@types/istanbul-reports/index.d.ts","../../../node_modules/chalk/index.d.ts","../../../node_modules/jest-diff/build/cleanupsemantic.d.ts","../../../node_modules/pretty-format/build/types.d.ts","../../../node_modules/pretty-format/build/index.d.ts","../../../node_modules/jest-diff/build/types.d.ts","../../../node_modules/jest-diff/build/difflines.d.ts","../../../node_modules/jest-diff/build/printdiffs.d.ts","../../../node_modules/jest-diff/build/index.d.ts","../../../node_modules/jest-matcher-utils/build/index.d.ts","../../../node_modules/@types/jest/index.d.ts","../../../node_modules/@types/jest-when/index.d.ts","../../../node_modules/@types/json5/index.d.ts","../../../node_modules/@types/minimatch/index.d.ts","../../../node_modules/@types/parse-json/index.d.ts","../../../node_modules/@types/pbkdf2/index.d.ts","../../../node_modules/@types/prettier/index.d.ts","../../../node_modules/@types/secp256k1/index.d.ts","../../../node_modules/@types/semver/classes/semver.d.ts","../../../node_modules/@types/semver/functions/parse.d.ts","../../../node_modules/@types/semver/functions/valid.d.ts","../../../node_modules/@types/semver/functions/clean.d.ts","../../../node_modules/@types/semver/functions/inc.d.ts","../../../node_modules/@types/semver/functions/diff.d.ts","../../../node_modules/@types/semver/functions/major.d.ts","../../../node_modules/@types/semver/functions/minor.d.ts","../../../node_modules/@types/semver/functions/patch.d.ts","../../../node_modules/@types/semver/functions/prerelease.d.ts","../../../node_modules/@types/semver/functions/compare.d.ts","../../../node_modules/@types/semver/functions/rcompare.d.ts","../../../node_modules/@types/semver/functions/compare-loose.d.ts","../../../node_modules/@types/semver/functions/compare-build.d.ts","../../../node_modules/@types/semver/functions/sort.d.ts","../../../node_modules/@types/semver/functions/rsort.d.ts","../../../node_modules/@types/semver/functions/gt.d.ts","../../../node_modules/@types/semver/functions/lt.d.ts","../../../node_modules/@types/semver/functions/eq.d.ts","../../../node_modules/@types/semver/functions/neq.d.ts","../../../node_modules/@types/semver/functions/gte.d.ts","../../../node_modules/@types/semver/functions/lte.d.ts","../../../node_modules/@types/semver/functions/cmp.d.ts","../../../node_modules/@types/semver/functions/coerce.d.ts","../../../node_modules/@types/semver/classes/comparator.d.ts","../../../node_modules/@types/semver/classes/range.d.ts","../../../node_modules/@types/semver/functions/satisfies.d.ts","../../../node_modules/@types/semver/ranges/max-satisfying.d.ts","../../../node_modules/@types/semver/ranges/min-satisfying.d.ts","../../../node_modules/@types/semver/ranges/to-comparators.d.ts","../../../node_modules/@types/semver/ranges/min-version.d.ts","../../../node_modules/@types/semver/ranges/valid.d.ts","../../../node_modules/@types/semver/ranges/outside.d.ts","../../../node_modules/@types/semver/ranges/gtr.d.ts","../../../node_modules/@types/semver/ranges/ltr.d.ts","../../../node_modules/@types/semver/ranges/intersects.d.ts","../../../node_modules/@types/semver/ranges/simplify.d.ts","../../../node_modules/@types/semver/ranges/subset.d.ts","../../../node_modules/@types/semver/internals/identifiers.d.ts","../../../node_modules/@types/semver/index.d.ts","../../../node_modules/@types/sinonjs__fake-timers/index.d.ts","../../../node_modules/@types/sinon/index.d.ts","../../../node_modules/@types/stack-utils/index.d.ts","../../../node_modules/@types/yargs-parser/index.d.ts","../../../node_modules/@types/yargs/index.d.ts"],"fileInfos":[{"version":"8730f4bf322026ff5229336391a18bcaa1f94d4f82416c8b2f3954e2ccaae2ba","affectsGlobalScope":true},"dc47c4fa66b9b9890cf076304de2a9c5201e94b740cffdf09f87296d877d71f6","7a387c58583dfca701b6c85e0adaf43fb17d590fb16d5b2dc0a2fbd89f35c467","8a12173c586e95f4433e0c6dc446bc88346be73ffe9ca6eec7aa63c8f3dca7f9","5f4e733ced4e129482ae2186aae29fde948ab7182844c3a5a51dd346182c7b06","4b421cbfb3a38a27c279dec1e9112c3d1da296f77a1a85ddadf7e7a425d45d18","1fc5ab7a764205c68fa10d381b08417795fc73111d6dd16b5b1ed36badb743d9",{"version":"3aafcb693fe5b5c3bd277bd4c3a617b53db474fe498fc5df067c5603b1eebde7","affectsGlobalScope":true},{"version":"adb996790133eb33b33aadb9c09f15c2c575e71fb57a62de8bf74dbf59ec7dfb","affectsGlobalScope":true},{"version":"8cc8c5a3bac513368b0157f3d8b31cfdcfe78b56d3724f30f80ed9715e404af8","affectsGlobalScope":true},{"version":"cdccba9a388c2ee3fd6ad4018c640a471a6c060e96f1232062223063b0a5ac6a","affectsGlobalScope":true},{"version":"c5c05907c02476e4bde6b7e76a79ffcd948aedd14b6a8f56e4674221b0417398","affectsGlobalScope":true},{"version":"5f406584aef28a331c36523df688ca3650288d14f39c5d2e555c95f0d2ff8f6f","affectsGlobalScope":true},{"version":"22f230e544b35349cfb3bd9110b6ef37b41c6d6c43c3314a31bd0d9652fcec72","affectsGlobalScope":true},{"version":"7ea0b55f6b315cf9ac2ad622b0a7813315bb6e97bf4bb3fbf8f8affbca7dc695","affectsGlobalScope":true},{"version":"3013574108c36fd3aaca79764002b3717da09725a36a6fc02eac386593110f93","affectsGlobalScope":true},{"version":"eb26de841c52236d8222f87e9e6a235332e0788af8c87a71e9e210314300410a","affectsGlobalScope":true},{"version":"3be5a1453daa63e031d266bf342f3943603873d890ab8b9ada95e22389389006","affectsGlobalScope":true},{"version":"17bb1fc99591b00515502d264fa55dc8370c45c5298f4a5c2083557dccba5a2a","affectsGlobalScope":true},{"version":"7ce9f0bde3307ca1f944119f6365f2d776d281a393b576a18a2f2893a2d75c98","affectsGlobalScope":true},{"version":"6a6b173e739a6a99629a8594bfb294cc7329bfb7b227f12e1f7c11bc163b8577","affectsGlobalScope":true},{"version":"81cac4cbc92c0c839c70f8ffb94eb61e2d32dc1c3cf6d95844ca099463cf37ea","affectsGlobalScope":true},{"version":"b0124885ef82641903d232172577f2ceb5d3e60aed4da1153bab4221e1f6dd4e","affectsGlobalScope":true},{"version":"0eb85d6c590b0d577919a79e0084fa1744c1beba6fd0d4e951432fa1ede5510a","affectsGlobalScope":true},{"version":"da233fc1c8a377ba9e0bed690a73c290d843c2c3d23a7bd7ec5cd3d7d73ba1e0","affectsGlobalScope":true},{"version":"d154ea5bb7f7f9001ed9153e876b2d5b8f5c2bb9ec02b3ae0d239ec769f1f2ae","affectsGlobalScope":true},{"version":"bb2d3fb05a1d2ffbca947cc7cbc95d23e1d053d6595391bd325deb265a18d36c","affectsGlobalScope":true},{"version":"c80df75850fea5caa2afe43b9949338ce4e2de086f91713e9af1a06f973872b8","affectsGlobalScope":true},{"version":"9d57b2b5d15838ed094aa9ff1299eecef40b190722eb619bac4616657a05f951","affectsGlobalScope":true},{"version":"6c51b5dd26a2c31dbf37f00cfc32b2aa6a92e19c995aefb5b97a3a64f1ac99de","affectsGlobalScope":true},{"version":"6e7997ef61de3132e4d4b2250e75343f487903ddf5370e7ce33cf1b9db9a63ed","affectsGlobalScope":true},{"version":"2ad234885a4240522efccd77de6c7d99eecf9b4de0914adb9a35c0c22433f993","affectsGlobalScope":true},{"version":"5e5e095c4470c8bab227dbbc61374878ecead104c74ab9960d3adcccfee23205","affectsGlobalScope":true},{"version":"09aa50414b80c023553090e2f53827f007a301bc34b0495bfb2c3c08ab9ad1eb","affectsGlobalScope":true},{"version":"d7f680a43f8cd12a6b6122c07c54ba40952b0c8aa140dcfcf32eb9e6cb028596","affectsGlobalScope":true},{"version":"3787b83e297de7c315d55d4a7c546ae28e5f6c0a361b7a1dcec1f1f50a54ef11","affectsGlobalScope":true},{"version":"e7e8e1d368290e9295ef18ca23f405cf40d5456fa9f20db6373a61ca45f75f40","affectsGlobalScope":true},{"version":"faf0221ae0465363c842ce6aa8a0cbda5d9296940a8e26c86e04cc4081eea21e","affectsGlobalScope":true},{"version":"06393d13ea207a1bfe08ec8d7be562549c5e2da8983f2ee074e00002629d1871","affectsGlobalScope":true},{"version":"2768ef564cfc0689a1b76106c421a2909bdff0acbe87da010785adab80efdd5c","affectsGlobalScope":true},{"version":"b248e32ca52e8f5571390a4142558ae4f203ae2f94d5bac38a3084d529ef4e58","affectsGlobalScope":true},{"version":"52d1bb7ab7a3306fd0375c8bff560feed26ed676a5b0457fa8027b563aecb9a4","affectsGlobalScope":true},"70bbfaec021ac4a0c805374225b55d70887f987df8b8dd7711d79464bb7b4385","869089d60b67219f63e6aca810284c89bae1b384b5cbc7ce64e53d82ad223ed5",{"version":"18338b6a4b920ec7d49b4ffafcbf0fa8a86b4bfd432966efd722dab611157cf4","affectsGlobalScope":true},"62a0875a0397b35a2364f1d401c0ce17975dfa4d47bf6844de858ae04da349f9","ee7491d0318d1fafcba97d5b72b450eb52671570f7a4ecd9e8898d40eaae9472","e3e7d217d89b380c1f34395eadc9289542851b0f0a64007dfe1fb7cf7423d24e","fd79909e93b4d50fd0ed9f3d39ddf8ba0653290bac25c295aac49f6befbd081b","345a9cc2945406f53051cd0e9b51f82e1e53929848eab046fdda91ee8aa7da31","9debe2de883da37a914e5e784a7be54c201b8f1d783822ad6f443ff409a5ea21","dee5d5c5440cda1f3668f11809a5503c30db0476ad117dd450f7ba5a45300e8f","f5e396c1424c391078c866d6f84afe0b4d2f7f85a160b9c756cd63b5b1775d93","5caa6f4fff16066d377d4e254f6c34c16540da3809cd66cd626a303bc33c419f","730d055528bdf12c8524870bb33d237991be9084c57634e56e5d8075f6605e02","75b22c74010ba649de1a1676a4c4b8b5bb4294fecd05089e2094429b16d7840c","5615ccf831db2ffc82145243081ebdb60ea8e1005ee8f975d1c0c1401a9c894e","38682ed3630bb6ecdace80d5a9adc811fc20a419f1940446e306c3a020d083b9","cc182e6e4f691cd6f7bf7cb491247a4c7818f9f1cb2db1d45c65ff906e3f741b","a50599c08934a62f11657bdbe0dc929ab66da1b1f09974408fd9a33ec1bb8060","5a20e7d6c630b91be15e9b837853173829d00273197481dc8d3e94df61105a71","8d478048d71cc16f806d4b71b252ecb67c7444ccf4f4b09b29a312712184f859","e0eda929c6b9b628cdeb0e54cd3582cb97e64f28aab34612fc1431c545899584","9df4662ca3dbc2522bc115833ee04faa1afbb4e249a85ef4a0a09c621346bd08","b25d9065cf1c1f537a140bbc508e953ed2262f77134574c432d206ff36f4bdbf","1b103313097041aa9cd705a682c652f08613cb5cf8663321061c0902f845e81c","68ccec8662818911d8a12b8ed028bc5729fb4f1d34793c4701265ba60bc73cf4","5f85b8b79dc4d36af672c035b2beb71545de63a5d60bccbeee64c260941672ab","b3d48529ae61dc27d0bfbfa2cb3e0dff8189644bd155bdf5df1e8e14669f7043","40fe4b689225816b31fe5794c0fbf3534568819709e40295ead998a2bc1ab237","f65b5e33b9ad545a1eebbd6afe857314725ad42aaf069913e33f928ab3e4990a","fb6f2a87beb7fb1f4c2b762d0c76a9459fc91f557231569b0ee21399e22aa13d","31c858dc85996fac4b7fa944e1016d5c72f514930a72357ab5001097bf6511c7","3de30a871b3340be8b679c52aa12f90dd1c8c60874517be58968fdbcc4d79445","6fd985bd31eaf77542625306fb0404d32bff978990f0a06428e5f0b9a3b58109","5b3cd03ae354ea96eff1f74d7c410fe4852e6382227e8b0ecf87ab5e3a5bbcd4","7394959e5a741b185456e1ef5d64599c36c60a323207450991e7a42e08911419",{"version":"056097110efd16869ec118cedb44ecbac9a019576eee808d61304ca6d5cb2cbe","affectsGlobalScope":true},"f51b4042a3ac86f1f707500a9768f88d0b0c1fc3f3e45a73333283dea720cdc6",{"version":"6fb8358e10ed92a7f515b7d79da3904c955a3ffd4e14aa9df6f0ea113041f1cf","affectsGlobalScope":true},"45c831238c6dac21c72da5f335747736a56a3847192bf03c84b958a7e9ec93e2","661a11d16ad2e3543a77c53bcd4017ee9a450f47ab7def3ab493a86eae4d550c",{"version":"8cdc646cec7819581ef343b83855b1bfe4fe674f2c84f4fb8dc90d82fb56bd3a","affectsGlobalScope":true},"a40826e8476694e90da94aa008283a7de50d1dafd37beada623863f1901cb7fb","9dd56225cc2d8cb8fe5ceb0043ff386987637e12fecc6078896058a99deae284","2375ed4b439215aa3b6d0c6fd175c78a4384b30cb43cbadaecbf0a18954c98cb","7693b90b3075deaccafd5efb467bf9f2b747a3075be888652ef73e64396d8628","41231da15bb5e3e806a8395bd15c7befd2ec90f9f4e3c9d0ae1356bccb76dbb0","fccfef201d057cb407fa515311bd608549bab6c7b8adcf8f2df31f5d3b796478",{"version":"ee1ee365d88c4c6c0c0a5a5701d66ebc27ccd0bcfcfaa482c6e2e7fe7b98edf7","affectsGlobalScope":true},"5f20d20b7607174caf1a6da9141aeb9f2142159ae2410ca30c7a0fccd1d19c99",{"version":"464762c6213566d072f1ced5e8e9a954785ec5e53883b7397198abb5ef5b8f71","affectsGlobalScope":true},"6387920dc3e18927335b086deec75bf8e50f879a5e273d32ee7bb7a55ba50572","9bba37424094688c4663c177a1379b229f919b8912889a472f32fdc5f08ddb4d","29a4be13b3a30d3e66667b75c58ec61fb2df8fa0422534fdee3cfb30c5dbf450","83366d901beda79d6eb37aaaf6ca248dcd88946302b2a7d975590783be51e88e","bf268a0aea37ad4ae3b7a9b58559190b6fc01ea16a31e35cd05817a0a60f895a","43ec77c369473e92e2ecebf0554a0fdaa9c256644a6070f28228dfcceec77351",{"version":"d7dad6db394a3d9f7b49755e4b610fbf8ed6eb0c9810ae5f1a119f6b5d76de45","affectsGlobalScope":true},"95ed02bacb4502c985b69742ec82a4576d4ff4a6620ecc91593f611d502ae546","bf755525c4e6f85a970b98c4755d98e8aa1b6dbd83a5d8fcc57d3d497351b936","dd67d2b5e4e8a182a38de8e69fb736945eaa4588e0909c14e01a14bd3cc1fd1e",{"version":"28084e15b63e6211769db2fe646d8bc5c4c6776321e0deffe2d12eefd52cb6b9","affectsGlobalScope":true},{"version":"aed37dabf86c99d6c8508700576ecede86688397bc12523541858705a0c737c2","affectsGlobalScope":true},"cc6ef5733d4ea6d2e06310a32dffd2c16418b467c5033d49cecc4f3a25de7497","94768454c3348b6ebe48e45fbad8c92e2bb7af4a35243edbe2b90823d0bd7f9a","0be79b3ff0f16b6c2f9bc8c4cc7097ea417d8d67f8267f7e1eec8e32b548c2ff","1c61ffa3a71b77363b30d19832c269ef62fba787f5610cac7254728d3b69ab2e","84da3c28344e621fd1d591f2c09e9595292d2b70018da28a553268ac122597d4","269929a24b2816343a178008ac9ae9248304d92a8ba8e233055e0ed6dbe6ef71","6e191fea1db6e9e4fa828259cf489e820ec9170effff57fb081a2f3295db4722","aed943465fbce1efe49ee16b5ea409050f15cd8eaf116f6fadb64ef0772e7d95","70d08483a67bf7050dbedace398ef3fee9f436fcd60517c97c4c1e22e3c6f3e8","c40fdf7b2e18df49ce0568e37f0292c12807a0748be79e272745e7216bed2606",{"version":"e933de8143e1d12dd51d89b398760fd5a9081896be366dad88a922d0b29f3c69","affectsGlobalScope":true},"4e228e78c1e9b0a75c70588d59288f63a6258e8b1fe4a67b0c53fe03461421d9","b38d55d08708c2410a3039687db70b4a5bfa69fc4845617c313b5a10d9c5c637","205d50c24359ead003dc537b9b65d2a64208dfdffe368f403cf9e0357831db9e","1265fddcd0c68be9d2a3b29805d0280484c961264dd95e0b675f7bd91f777e78",{"version":"a05e2d784c9be7051c4ac87a407c66d2106e23490c18c038bbd0712bde7602fd","affectsGlobalScope":true},{"version":"df90b9d0e9980762da8daf8adf6ffa0c853e76bfd269c377be0d07a9ad87acd2","affectsGlobalScope":true},"cf434b5c04792f62d6f4bdd5e2c8673f36e638e910333c172614d5def9b17f98","1d65d4798df9c2df008884035c41d3e67731f29db5ecb64cd7378797c7c53a2f","0faee6b555890a1cb106e2adc5d3ffd89545b1da894d474e9d436596d654998f","c6c01ea1c42508edf11a36d13b70f6e35774f74355ba5d358354d4a77cc67ea1","867f95abf1df444aab146b19847391fc2f922a55f6a970a27ed8226766cee29f",{"version":"ab9b9a36e5284fd8d3bf2f7d5fcbc60052f25f27e4d20954782099282c60d23e","affectsGlobalScope":true},"b0297b09e607bec9698cac7cf55463d6731406efb1161ee4d448293b47397c84","175323e2a79a6076e0bada8a390d535a3ea817158bf1b1f46e31efca9028a0a2","7a10053aadc19335532a4d02756db4865974fd69bea5439ddcc5bfdf062d9476","4967529644e391115ca5592184d4b63980569adf60ee685f968fd59ab1557188","aed9e712a9b168345362e8f3a949f16c99ca1e05d21328f05735dfdbb24414ef","b04fe6922ed3db93afdbd49cdda8576aa75f744592fceea96fb0d5f32158c4f5","ed8d6c8de90fc2a4faaebc28e91f2469928738efd5208fb75ade0fa607e892b7","d7c52b198d680fe65b1a8d1b001f0173ffa2536ca2e7082431d726ce1f6714cd","c07f251e1c4e415a838e5498380b55cfea94f3513229de292d2aa85ae52fc3e9","0ed401424892d6bf294a5374efe512d6951b54a71e5dd0290c55b6d0d915f6f7","b945be6da6a3616ef3a250bfe223362b1c7c6872e775b0c4d82a1bf7a28ff902","beea49237dd7c7110fabf3c7509919c9cb9da841d847c53cac162dc3479e2f87","0f45f8a529c450d8f394106cc622bff79e44a1716e1ac9c3cc68b43f7ecf65ee","c624ce90b04c27ce4f318ba6330d39bde3d4e306f0f497ce78d4bda5ab8e22ca","9b8253aa5cb2c82d505f72afdbf96e83b15cc6b9a6f4fadbbbab46210d5f1977","86a8f52e4b1ac49155e889376bcfa8528a634c90c27fec65aa0e949f77b740c5","aab5dd41c1e2316cc0b42a7dd15684f8582d5a1d16c0516276a2a8a7d0fecd9c","59948226626ee210045296ba1fc6cb0fe748d1ff613204e08e7157ab6862dee7","ec3e54d8b713c170fdc8110a7e4a6a97513a7ab6b05ac9e1100cb064d2bb7349","43beb30ecb39a603fde4376554887310b0699f25f7f39c5c91e3147b51bb3a26","666b77d7f06f49da114b090a399abbfa66d5b6c01a3fd9dc4f063a52ace28507","31997714a93fbc570f52d47d6a8ebfb021a34a68ea9ba58bbb69cdec9565657e","6032e4262822160128e644de3fc4410bcd7517c2f137525fd2623d2bb23cb0d3","8bd5c9b1016629c144fd228983395b9dbf0676a576716bc3d316cab612c33cd5","2ed90bd3925b23aed8f859ffd0e885250be0424ca2b57e9866dabef152e1d6b7","93f6bd17d92dab9db7897e1430a5aeaa03bcf51623156213d8397710367a76ce","3f62b770a42e8c47c7008726f95aa383e69d97e85e680d237b99fcb0ee601dd8","5b84cfe78028c35c3bb89c042f18bf08d09da11e82d275c378ae4d07d8477e6c","980d21b0081cbf81774083b1e3a46f4bbdcd2b68858df0f66d7fad9c82bc34bc","68cc8d6fcc2f270d7108f02f3ebc59480a54615be3e09a47e14527f349e9d53e","3eb11dbf3489064a47a2e1cf9d261b1f100ef0b3b50ffca6c44dd99d6dd81ac1","b17f3bb7d8333479c7e45e5f3d876761b9bca58f97594eca3f6a944fd825e632","3c1f1236cce6d6e0c4e2c1b4371e6f72d7c14842ecd76a98ed0748ee5730c8f3","6d7f58d5ea72d7834946fd7104a734dc7d40661be8b2e1eaced1ddce3268ebaf","4c26222991e6c97d5a8f541d4f2c67585eda9e8b33cf9f52931b098045236e88","277983d414aa99d78655186c3ee1e1c38c302e336aff1d77b47fcdc39d8273fe","47383b45796d525a4039cd22d2840ac55a1ff03a43d027f7f867ba7314a9cf53","6548773b3abbc18de29176c2141f766d4e437e40596ee480447abf83575445ad","6ddd27af0436ce59dd4c1896e2bfdb2bdb2529847d078b83ce67a144dff05491","816264799aef3fd5a09a3b6c25217d5ec26a9dfc7465eac7d6073bcdc7d88f3f","4df0891b133884cd9ed752d31c7d0ec0a09234e9ed5394abffd3c660761598db","b603b62d3dcd31ef757dc7339b4fa8acdbca318b0fb9ac485f9a1351955615f9","e642bd47b75ad6b53cbf0dfd7ddfa0f120bd10193f0c58ec37d87b59bf604aca","be90b24d2ee6f875ce3aaa482e7c41a54278856b03d04212681c4032df62baf9","78f5ff400b3cb37e7b90eef1ff311253ed31c8cb66505e9828fad099bffde021","372c47090e1131305d163469a895ff2938f33fa73aad988df31cd31743f9efb6","71c67dc6987bdbd5599353f90009ff825dd7db0450ef9a0aee5bb0c574d18512","6f12403b5eca6ae7ca8e3efe3eeb9c683b06ce3e3844ccfd04098d83cd7e4957","282c535df88175d64d9df4550d2fd1176fd940c1c6822f1e7584003237f179d3","c3a4752cf103e4c6034d5bd449c8f9d5e7b352d22a5f8f9a41a8efb11646f9c2","11a9e38611ac3c77c74240c58b6bd64a0032128b29354e999650f1de1e034b1c","4ed103ca6fff9cb244f7c4b86d1eb28ce8069c32db720784329946731badb5bb","d738f282842970e058672663311c6875482ee36607c88b98ffb6604fba99cb2a","ec859cd8226aa623e41bbb47c249a55ee16dc1b8647359585244d57d3a5ed0c7","8891c6e959d253a66434ff5dc9ae46058fb3493e84b4ca39f710ef2d350656b1","c4463cf02535444dcbc3e67ecd29f1972490f74e49957d6fd4282a1013796ba6","0cb0a957ff02de0b25fd0f3f37130ca7f22d1e0dea256569c714c1f73c6791f8","2f5075dc512d51786b1ba3b1696565641dfaae3ac854f5f13d61fa12ef81a47e","ca3353cc82b1981f0d25d71d7432d583a6ef882ccdea82d65fbe49af37be51cb","50679a8e27aacf72f8c40bcab15d7ef5e83494089b4726b83eec4554344d5cdc","45351e0d51780b6f4088277a4457b9879506ee2720a887de232df0f1efcb33d8","5d697a4b315cc5bb3042ae869abffd10c3b0d7b182cda0e4c45d8819937e5796","563fa27fdaec8f195b84f71a7af0ef48d30d5cc830575db86da86a63a470c8e6","6ee58aa536dabb19b09bc036f1abe83feb51e13d63b23d30b2d0631a2de99b8f","8aceb205dcc6f814ad99635baf1e40b6e01d06d3fe27b72fd766c6d0b8c0c600","299567f84bfedd1468dca2755a829cb19e607a6811673788807dc8921e211bc9","795d9fb85aad92221504db74dd179b506bd189bba0c104426f7e7bb8a66ffee5","1311bc194e0a69fe61031e852c1c0b439e2a2a3d1d5e2d8ff795499b9f283459","4b7ce19369d7e7fae76720c2c6c7f671bf3fa0f7093edb864f1ac358ca7c456c","c972ef44deca1fa8fab465915ffa00f82e126aacf3dfc8979c03b1b066ce5bb6","30285a1011c6d6b52f3ba3abb0a984be8148c05cdefb8eb6eb562335a3991f35","8e7adb22c0adecf7464861fc58ae3fc617b41ffbd70c97aa8493dc0966a82273","755f3cd1d9c1b564cff090e3b0e29200ae55690a91b87cb9e7a64c2dbeb314d3","d6bb7e0a6877b7856c183bff13d09dd9ae599ea43c6f6b33d3d5f72a830ed460","f1b51ae93c762d7c43f559933cd4842dd870367e8d92e90704ffa685dd5b29a3","3f450762fd7c34ed545e738abccb0af6a703572a10521643cf8fc88e3724c99c","fcc8beef29f39f09b1d9c9f99c42f9fed605ab1c28d2a630185f732b9ba53763","d6e6620a30d582182acc3f0a992a0c311adc589f111096aea11ab83fc09a5ccc","6213b8f686f56beab22b59a0f468590fd3a4c5fa931236a017efeca91d7c9584","c451cec9a588b1f105a5ea2c6063d4fca112b9d70105cacdadda0e1ef67e9379","cb047832dc68f5a2c41c62c5e95ddcacbae3a8b034d40cd15319a8cb7f25104a","980336ccdfc3c08f3c3b201aa6662e6016e20f15847f8465b68f3e8e67b4665c","5a3493939995f46ff3d9073cd534fb8961c3bf4e08c71db27066ff03d906dea8","bb5a2ac327605ebebf831c469b05bd34a33a6a46ee8c1edd9f3310aad32cf6a1","bf5d041f2440b4a9391e2b5eb3b8d94cbf1e3b8ff4703b6539d4e65e758c8f37","8516469eb90e723b0eb03df1be098f7e6a4709f6f48fd4532868d20a0a934f6e","d60e9ab369a72d234aac49adbe2900d8ef1408a6ea4db552cf2a48c9d8d6a1bc","0ebb4698803f01e2e7df6acce572fff068f4a20c47221721dafd70a27e372831","03460a54d0e0481d1e11097f66ad43f054bc95efdafe5f81bbc7a82be181af75","4070c2f1c3434fcf84886e04d30d82cd650ee443e53b82b404b144175cf8741e","2cea9689efa8591732096235abe7f084fc29c92badd5b0897a5e876b77e71887","4ed4e504126014fee13aaef5e3fc140f2ff7031ff3a8b5386717905820ea2d09","8129a34006218a6f3cdc81bbd438d5429eb18b08b4338a26977ac3b4df129d75","30d2170e1a718b5035611af55e3618b4ba8f42f0749bb52ee593da6082c4e2ce","98ef38666d88ec9699a722053e07ede65d3042f693fe7ff8c786e53dbb6fd43b","a3b8b6be7620897d1e481e8650c980a210a138fceb6e710eaf95fd9dd0dfe94a","12c89d0e32758c120a569045f21cf5b77244f86792611ced8de7f86b37e77781","14bd47270e654c8eb3b1489fa8c095912ee62a0a29bb92743393203722347c53","3d9297165e67fd59d9821cc93a9808213e33c56a8ac1c4273171f6afaaa2d4d5","e7af7d288b89287ad031b19583c597fcd9f5edc0b0d579b7b492f06cf57e058c","92cb686a9ca5eb5dd7d5d8d43a3707194c1e91ea07a027b3bcb60b6011b24632","8e609bb71c20b858c77f0e9f90bb1319db8477b13f9f965f1a1e18524bf50881","25139d6a726e0e19d9fc4fa3197367b4a82ec34a08a5ecf23963e142c202c0f3","e3328bffc8eab74665a4fe9c59d6f12f4c8570c3d858497e241eb37efe17dfcf","29389551e426a46421134b55182d6fcf5b143670998bf81db2619c1228235392","c18f7e16982695bdd04e3e183a327d116185f77f1a37b9b2e849d7d93269cd74","2cfb37011989c21dc70b91d521a2d5a4e0f18507f5f536b5dfe504edb15916e8","bb5e02df7aaec7a4ea642639a9963b24b8d9fd6798351f07d8c58616942fbcbf","299a899cb4d061f5d83843ec453e936e9659b2c435746823f90c40eddaef4745","d5610c0fd12870f644b0f42c1bcc4fa2295ac3e3ca01916bdb42c3bdc4c80c36","2c56a8e249b1f45dbdf973100cd37fe2ea68709573cf1fdf2e3052c593be68d8","3553da417ee7b07e388b13bd12a70a1c03e65a6132ba5427fe68f5b362373e6f","612358502042d351c227ba779fdcf6d875d827e424930e60297c533524e50668","d2b5be376ef162aa0c24a826e7dd2d77671a045c085e16d1c1276db4bdccbac7","c4138d8dcccedaff6621e009cf0a54a7bed2a5ad4c509a3513bccc4f417ef939","ad8747fe978dff3e80f4b12b48d37cc8dff11b61d04c035aefbc982ce21201ce","b154f789fd65298e1ba6cbba6944ea892d564c95f3d3700ed85baf8f80748473","c660265aedd7c5b236e2017e53095cb98da66200eb0e8d023b5bf713c36494e8","0efc36bf5c0daca6217fec7063359ccdab8c3a23bb405d25340fae22cf72d74f","5abff0c87d4f9c89715107042d4c73b68ef7a128759f451c8a0fc450cbaaf660","5a03308fbd1af441065149a84c692931bebc7e7735afc23be8684f4e10d3aa06","c787bf4f8f0abbf815cfbd348be41046f2b8f270be24fe7aa8a8fcdd2b7df8c2","e7a5191c663a3228f30104961d548b372e51c5936c01ffc8eddd262bb98d7d7c","43fdc9abe6f8640fda4cdc55a1ee5f666d3fce554277043df925c383137ddf69","f0b09665c9d52de465687fbd3cfb65111d3ffc59ae00c6f42654150f3db05518","72f8c078d06cff690e24ff2b0e118a9de2833dcebf7c53e762dcb505ddf36a68","9705efb0fd901180de84ca4dd11d86f87fd73f99d6a5660a664c048a7487e385","f9b9d0950fdfb90f57e3f045fe73dce7fa6e7921b37622fc12e64fcd90afbd0f","e61b36e7fde608f8bb4b9c973d81556553a715eaef42a181a16ddd7a28da4ac7","03b8389b222af729eae0fb3c33366dcbb1f5a0102ce319bf1d7d5ee987e59fd0","2bf6be7c04db280fdd9b786764f8650c23f9f4d533791cb25a11b25314b76a55","dbb5fc7edd36bfba95cc4dd564e4458276ced30eed18bc05fbda948b3fda8686","c2b556c7cff0dabce2e31cb373ac61c14d8ebc35f1086dff30b39e9ec5357d0d","f958af01131076e8af55d28c4835a51063226ab488ca8738fdee38aeef7d0d33","9f3797b01e3d83d4e4b875699ae984f380ca86aa0a0c9df43ac5bba1cb1f8b7b","752b15ad1b34887adeaa838fc55f5d4ca399026afd266d4ed4db0e3db02eae4e","778331eaea1093451e50be9844bd2b6937c3bb81b0b1ee700624c9774ecfcf2b","0ca0dfc9f657d0822eca9530c7870b22a1d2a5fc48182bdd4d0e6e88e4ad9c35","5c746f034288e6842dd1589b169dcfcc16c5ce5abbd928889ab67aea4fe0b501","92ce6dbbcc135cffd09a58e19fef34bf351391bec92c40d849e4e9997d475769","99e77d092fed72b6b8578d00c7af004f76e98b30ba99f1947535eb4c04a51676","fcc8beef29f39f09b1d9c9f99c42f9fed605ab1c28d2a630185f732b9ba53763","b5ef52a9f9083724decc5d060f0b34e3a480deed71c32d55ca16c214eb4cc928","5c9cadb9446d1868615558eda1fbf64df5b4fae5ef051d0d7ead6fd28544e3bd","ed7f49215f59f3f514efd4e6ffbdd66cc87d7ce03177e98d17416f34f32cc52c","f100912a3785eed4a3d29c12f5910b101af9353454de5ddba9b4d43456c56dd1","f0ae57a70e4297198722b8e777c7f738a797c4ee1485ab0afa6601f4a7160933","98034cd285344125f7165a3bb68246d38ab35fabe7f6d6a7c8f80407d31f548d","0ca0dfc9f657d0822eca9530c7870b22a1d2a5fc48182bdd4d0e6e88e4ad9c35","06b4a23064991251512df4edc12341d5bc69a17b942da18372312d383c90eee7","0f898802705f9a534b537f1be6c57265080e0abd6993d935554c255e6d56cc1a","745efa7b6e27b7216cccede166a822b56acc41b10a8090966c8cf2c96239cb83","6ab2a6257ae7bb05559841100c786c845fe465a90be7b904db9096c2fb14696b","50aa290ee8f3ba75c7a3653613ead6594e2e034a7627b249c9a400858cac79f5","c9f26fa63b17f3581e7cbcd68e6cf66e6f3e59feb91f6b54757d41355ddacbe5","6a8649609161e2794b383ba275b0a6cb4a072dde7b954648f83dc6cdf1bfe4a8","601d4a40a69c782addaf84185d4547568ec072095ab9976610d89922d1291f8b","d5c19655468e29f60c871b21e73af8ebc653f736e7123ade916f22c4a5f80ce5","55bdc187765b1f5006234e7bf15f911689a5119dcd02be11a798ecaf59d2b3d7","24b3bc595939a193945e81f7e34f4bcfc7efbd133e249878f82aae47a7c89694","85052c71d72b9b017c88179f57a464d66e22619c7acd7d83b117a79cf1608979","eaca2afa1bea4de1d06e0a388415bfdc142f784d709011964ac31aa65948d578","6d3101b183ea67ef606b93fe42127f30b2db5ac3b72c34ca9d6d8b00eb85d0f6","f5d7a36ff056cc314b0f61c89a03c4c36a24183b246e61d958e75e86521304cd","a3a497437625850c31a84c043b128740dd6d9991fa591e1809aa7b65f9056b9f","6c951235cbf3c324a20c0e2dfdd013d7b226b0c2a72dbd84925682a8d7199237","786c21e23b9ec59e984e24ea9bb2e5fcada9df7c7795ace4e00442172a9e9ecf","3a971ea3e36685b96f24fbd53a94ad8dc061711b84e51fde4cf201f7041e618d","9b6c162d20e2ad4abdcff61a24082564ac59e63092220618162aef6e440c9228","b0874729266d9f7fafb9ff1127fcbad2cf7972b5dcc1fdc104be79266a708bc2","e833ded303809728b25b45929e6e8d00dbc022dffde04fe751769df33eec2699","b2721e335ce1628f2785998a96f36e6b00a767199bc1d19e716861a5f0f45768",{"version":"801934aa449fe6df584bccdcc5d5b9280295cb7ac84918b6014fc5086e6f9ff6","affectsGlobalScope":true},"5e379df3d61561c2ed7789b5995b9ba2143bbba21a905e2381e16efe7d1fa424","f07a137bbe2de7a122c37bfea00e761975fb264c49f18003d398d71b3fb35a5f","2b7fc7318f5cd3e70f0ee1342bafb95cb60ee0beaf5d0929f59c704ff6c8877a","c62c4ba5e910b4523f7e7adf4a55ec45c2bac99d9d8e9b0fe0c2a800a6f641b9","2845be5c74adbf73439e0aef6ea2dddf3cf202d0f5afc3708dfbfafdb86b6acd","8cf023c0bd57992fdd2ce6a7030a1874f49c8edc62eaffa9bfffcf18d2a2a1a2","8ea8f3040e38fb50d7dc3653f3b8a0dbb5244e82111576f99ce096bdc0fbf94c","48ed788ad126545a6156fcc37cd3bcf17de18a3e3fe6b6ef62cfb8140d1a45a2","63c271a745f628ffd4bd7ad0a63b021c362c9bd6bf8b18441a7162892395a214","a867ba47f71fe3993cef54246893ff8f01411e12e411d8cf1bd038a448b36404","9f9e5bae412fa5909fae636d6733aee27a108cc2ed5b13980611016336774d3c","662fe197bba64bd3f17ee118058cd2d0d2dbe33d7c0c865fd6365d90bfc44e1e","030519c351f800551cac2658038804969ca4584d2c0175a710602ac234ca1340","0278a6939ca83cd040b08ff8c5fc7838b6693ddc52f22526bf158e6b10e0246c","c2d6206e5ba4fd3063b01218c2b3b997afc1cfbeb49fcee991fa8595842ce53d","6a8096993458a3d71229031aa7415974eb5b47b320213e29660adfb519d6a3f4","cb7996a1af5b1d276483cd0c9b9de6540eff021abc90a720511ff4464519a2ff","9df6ec68878d65bc690ea3a33ce3ef5aa8254c36bc5f8346c0c2fd1f3b88a35c","a4fad04c4acc8a4b195cbbccef4c55019104753d547d5c94441643ccc89108a0","0244c23ea642361f7c192c1f0cfff9c12cfa5f51f9b155edd5c0a89fef308d34","6548ab4b57eb9d092471a04513091673345f2fd95d5b876f600402ea8d603ee0","fe1e3bdc462ec1f6f49ccba12526577b1a3d21811c79b58faa7f229374828fd3","d0f11e830aa1350a31d9c00a0197243e9711e4882947aef53a96c629f405cb10","66a0a22b136711f411de6ad562edd8e1bcc9da32363537ec6f33a57afb1ed9b6","aee675bf4b257b67624c9007f7d8eb2e3007a9318bd27e8df4b6c133dccc7d5a","334e40b3530b0d92518444b2a0b2608b7988c7132febc93e04ca9c15d0e8a058","9b6aaeafd7d5c93f3eacc9ef727fd64dfd75a63274e5137f6ce182eee60cca71","6bb747ac019210ef62125c2f0f0f4129010c765e556f4ce072aa0fadc86542d2","99e1bb2aca37fd9d6b86d517896e05eba415987dd84610a2789514c0d93502f4","9a63cbcff42116cfd1b08fec44bce9dec6ee31aa549ff4b2e443f87bb6cdffda","65c506882b16993f4870c2d73fb48b6d34b7d91d73acc6cacc3307e99bec42bf","9aff8604f50c9ea7d547330c1d168a6eb3d53d65a1600701c4741241571b9e13","0678e68e3e976e5d3fbb7baabd63384a7f418f2bae941266c2e3fccd7010ca12","779805755635c2da3c6d52f0801c33ff8c48c4f14071d48acfae117f80abd1ac","915fec4d3d928e869bd8ded5443b4b1111719b2df43da11c32df79af0350eb27","dbcd1e6a411ad34dc94931d79df68c286ed932e17a504463aaf95f7e04f30ca8","080b1aa93227952b4dd74b9d2c6e4f6002eb8403533749116a1c53bb9961c02d","874087eec1d457f6e3baf5ac46c42ea200e55040b394fac667aa3a64c49f5f6c","0d18f7c85d38358bede081a0b7f4292e15a800a3d2195de0a3ac5956d2481e19","6610b9f45f1f71d2b1fb67df49cbcabe3f9e668a1ccb7d8328a51407b259ffb3","2785698f900fdfedd9c81879b7741d263c6d5853164aa5c214a280e633bba9d4","a1d8da0e8e6d3a85899f13ff11b2fa1f0d3539d26133dcebae1cd6daec39a8a7","8952dd3e4ad7e445743358eb0630e70dc6bdc3c06598a0fd4bf360e959a77c55","a22a9669b2d3c24bb7ccf110e1bc5c980dfcfea9f8ac4719382223843e8a032b","e6f6440893f51adcf17b8498224004a65448828e1d95f2a06244a34a7525ccae","193f3eeb12d0c70404fddd0d6c6d395a6721320284d0d4d39e0538e47ac6931e","ab408226026bb8f267f4b7578d9c853db182cd1a4e4a05cdbc4cc36103075142","a7d992c4e10ca67ded5ea1bd4b974a87bc5395b2f51ac038e89c09aa2c9b1ddc","a85b317beb9f4b26f5c25fdaf03d925f9545fadb3679d1366324e9212b416b96","e5423640cf93ef900af69ac6b4efdbe339b0b332d15ed5f0ac15209c5fd86b50","eaec27135176a532508108c395b02e36658b861398d67b071790a0cddd5f595f","a4a3de26bc39d380e4021163f89f4b2fbf82f2a712b010efac1698bfd8c288ce","21b3d5e502c3c1eed625d13559db2a8df2ccd4f9e15185b158d5de392153db2d","2ba6ea7729eb2976f3397e6c9f381796fbc458fc01b076c357210ec2cbbc5b99","417692489d8e511510cf1268f89374466d7ef8d9edb085adbacc7756ffceed73","963a49f6949886df3d3d3dffef6ac3dab5f33704b918edb519ea3c063ba8eb35","7bd08ed4a983c57145375265be7d27b8ee27adf462c10c3d328a993ca89d9e19","970b722b55e730c9a4f78633f83c7c7769920293e2dfd45a58452bfe3486c63e","6e795e6270d39e918c7a0e62ac73793cda06fcf4b3692ee46583e15f5bf57ab8","ddd8ba285f28cfceb77fbe36c45a51ed00b2ed41f29a26a77b73d403d82b87ec","5c09195ef359ffa9c6bbdb4fefb101d87ede4b9e9c28213faf5b45d102e4c609","80b4d93a4dcc90a12f6f4bb7c6851a8182ae29e556716d0d80b5c012a5ef554a","2556ef9d1820e0b6bbca6dd65a50ea64f525c4d8247ab50dff44c3f0d14a5643","cbd1c836db190d6e3add07165afc228f04e1f6170e1fe3aa5e6fc24a7e9573a3","9b13881feb958237232586d888a10a39d47cdffe3ee34688ed41888fa7baad94","122fe82cf5af80f0b26832b258b537b7dfe3ec28449c301b259ab10204b50d45","b1d4e95f74b44961c24ab656a9e18a8b048748d0ed0dac69c72f42128f1e6331","d74d2a92b54f95e47d2b76bd5ee516aab7ae93afb79cd34c6681dd29eb09e72a","747e6326a724bc54f799a466a5b5c4978a601a04a063a5bdabe150af2f25b9e2","b57e22e53b56cca7a57bfcfb234aa6a66f9b9e4c07159d7388f94f17a3eaee2c","e47709ec4d1618ef429648cd8ef967aef2005526b34fcbfac33037add347dc71","b81abb3e47fbbb3af41fa75bada89bbcfa4b0feed9a0d6d4b19ed1ce1033b53c","15b330546e9784461058e5fd6e2346bf272140fa6f0cda34e193ae501d8b17b1","4d8ce72fd080bf9a46bdcc274bcbacccedd66d84e203966b197ac25a96932183","73327e6ae34e3f6591877fb75b451cf620cbbd76ee2b678213a9f793633cd0d3","3f1ba2f69944fa346789db7f60d53c9bec00032de0d797967978dea42e77b941","3f5df31539fee4816b97d4e45b4344fbdaf3ca59f6df941f8d780ee441e92cc1","48e6290931da300900f1c3aa9c5894406a885d80e6e196c17f923a11a58a39b6","3857c1773b8503c3ca45b7bc09ac89c3930c85ce93021054503f73d5d9101b5c","72702bd07fd6fb3ef64aadbcb909103aadfe71ee76e9fdeb11e0c92693cff6cb","f0dd6f7c9783637655478db7d7caf6becd41a79d54482aa59578ce88ab38e9bf",{"version":"cd756ccdabf433dd02b84d755383e489f14b3c1aede0477783aa04830fd5d695","affectsGlobalScope":true},"a4c88dbecdf8ee0c79f5b7c2bf31cd77e593f5d78384e2b674f67d754a549a9e","9cbdff04326da794ba008c0fc977ab062d1fe3fa2e9759654c72ffbe54b64a7c","706233548b0f0e1574d7894bf34f9117f74681ecc35e4b66804f3260020bd6c7","150855f967a6490161d5aeed4cc4adf31fcb8f5dbe54b75799c12b8687fc9cc2","cf08b7139adc21b94204e3d4b3daf9946e3462a9e3fdc3e94c87e767e7936e20","47ddb601df40bfa01cebdd06ee8b87d0b72aa1259a4ceba3ad3b5cf68130112a","6b6392704ddb3f50e647dbbb716782bdd0cf8ea9cc134aae256a26223e632b47","da7959ca32b26af48c58c5f15a96125601bd38158382e14f67c5996bae6e561e","df90b0c6b1d81851364c4d97fa23b91a993482bcf4a7bed7c7a24aa41632d494","03c0bc80f67c6f75b02341fbeb9f6ee92c66b90597729377f478885e6ad15a88","11ee9ab699b4619d217c640d917ca198f58066a86bd58c2917197d62aa6601e0","cf9d589d9e73bf32c8e7a6cae6b4a1cf9bef39e5594072533fdce985581a6ddc","abbcc437e0792ab2fe08797ceca1ec85a95ec413c51612313b18ab8e75f690f6","e29d76ef1183ac0edf94b4712b6e51730c447c7e773e75ceb44a720b0c9a9fd9","a8f3ebc21132b1f4d2ce58c8952ba455ae891422a9ea46c6802ad13b10c6c1f6","613c7d49928c9ad45ec4882a75472111a4497c4a7de9d6c9c843bd889be7f8aa","96f0d856b66d8af1242dea20c5eb182aaaa74be74b7fc6be91bcb5f6c16e405f","4749d39670f618849b640148c8164b52283b4a3be227f192a431fbf132d9d7c1","b682db93a241da3a145e40b75bff4e5f454c74bbb44af7cff2884847294f2ddb","53c7854f35e1d3fab9f0e95d7f7c70777a9f95e121d980269f17ae7d26b5fcce","960fccfbc730994718317411e9f75dac992f48d1645fbedb177f77bd4ee5eea4","2e28c01ab28f1c6d97e47def32e3df6a36c3848dd21520fff899b5c79b286659","8e0541de186545feaeb85671c27763206f0ac9a23b45c84acc6605a15ed64197","d42c6e985bdb10a2aaa3dae14d9b0d8589e74a7c2f9475bf543b855bb3c010ba","be11d1fd9568724e5fc8f6801bc7f92408cb6dc726c58782b4ebcda150bbca64","5cd6db16600b1b35aeabc394266dd1205d1fa8e0e826efd36fbe3b085758bc14","4b1b0fb8836d0f01909626e3e1b6542fb7a2e69f1a269ef5b676abcbae5770b5","72e7be5040a865e113cf78e17eba90499c44607a6a59d0d9b6f843369167523c","0d2acd3a3840418f280e10b2adc0154848f4a162ab6a6466cbf5d0210200a6f8","08417035838838db86f31bd576b1fe246be76c1507b8fc1f2eec744c0d0d125e","b78647f4fd09671f9e7502612cf5f0c072ab2ec917312810d36927fcdeeb5a7c","d6b58d955981bc1742501b792f1ab9f4cba0c4611f28dcf1c99376c1c33c9f9c","0cb9cfa126435d30332ff00441e0db904e55dccb5b1fa7220eaf024e7f425eeb","b8442e9db28157344d1bc5d8a5a256f1692de213f0c0ddeb84359834015a008c","458111fc89d11d2151277c822dfdc1a28fa5b6b2493cf942e37d4cd0a6ee5f22","da2b6356b84a40111aaecb18304ea4e4fcb43d70efb1c13ca7d7a906445ee0d3","187119ff4f9553676a884e296089e131e8cc01691c546273b1d0089c3533ce42","febf0b2de54781102b00f61653b21377390a048fbf5262718c91860d11ff34a6","6f294731b495c65ecf46a5694f0082954b961cf05463bea823f8014098eaffa0","0aaef8cded245bf5036a7a40b65622dd6c4da71f7a35343112edbe112b348a1e","00baffbe8a2f2e4875367479489b5d43b5fc1429ecb4a4cc98cfc3009095f52a","68a0d0c508e1b6d8d23a519a8a0a3303dc5baa4849ca049f21e5bad41945e3fc","3c92b6dfd43cc1c2485d9eba5ff0b74a19bb8725b692773ef1d66dac48cda4bd","b03afe4bec768ae333582915146f48b161e567a81b5ebc31c4d78af089770ac9","df996e25faa505f85aeb294d15ebe61b399cf1d1e49959cdfaf2cc0815c203f9","4f6a12044ee6f458db11964153830abbc499e73d065c51c329ec97407f4b13dd",{"version":"27c33fb4f509b29317686c6ff123aba92074ff6c7bc4c36aaa5ce02e39aa5880","signature":"b3df1401040a165c0422c12ebb1f1b6804b6e474926e5cdc7a5883a56015ed5f"},"1fcb8b15db812281d69a3090d488903f9e93033004aef9d8889ca3ad0753a96f","bdf5a95eb0a2dd1d39805bdf51b46ba012bb9b92b2ddaae16219595bba7678a5","9f794a0e8550a03baff865a3961cc22afbd85bc4ba9672bdda036971928f85f4","66a697d1e4cdbf25cdce4644a8085a8563041fa8c7731d4d9f5e8f22e66ba72c","a0c8e17f4d1ea2704c62d7349bc3b8d9a12e3761b5960cb44144d3f0333b3fcb","3471c0df3d0391e1dffe6e8bf150294531b2b71a2afa5f2b86e52bf84a5db60a","5d4df4de055eddf3187094f938a640f8d96e4c551a47d6686596fdb6ba4c3014","8bc2cad630da1033c1fd8d7df2bffb18af0da6113bd086a8bbec04a2471a1e00","a1059d1bbc8ad46bfe668b8450e7e8002887c4ab987bdb96d6108d8023f8bb8f","5134885e9648e2c6745f8aa1c3e7f5ab3b3617258b3d81ca02de6655ede3d74e","4f1ae3f24125216cf07c5211a3f00d2bb4782d7cc76c0681603f8249f9232ff0","d3fb92a5640f83f7844d60b35317a0f95c27e3658a749d76d218c461ad091668","d1f8bfcd91b284657ef8187c55ace7db91a3c43e642c3f14e54364154932f7e4","f54c92bfcae54f360fe79514746efce4870e4ddabc064e95d406bba291e9f672","175fd7186fa6a70f9db9b270a04a503cae23cf01cb77e3905bac115c38424cf7","c993f7ed1b8e1023c1f2ee5b262dbc3b70b27475674e40a53a58591f9972dacc","c914014ab7c7001178663f29d31a495398234a41219af61f26d7e8e91b46af96","277afd6ab6ec72889e2988e0ddd7d138c1f512e68a1fa4e90eedfd71e2097a51","c0908f85f2b645d375127a3b53a17a65f782e17962d5c1eb68f08b1188acbf15","3fadac5d409cc2f27b1d2f4e7568600f02840205f301c9ae7a3068b46476438b","da6aae64ad559286830fd44c81e3d33303348f184af7db4fde8dd99ae9749407","3633f87c97d359cb55fa7bf0668fb2be8a23342951af6ec2d06e6d0cf7409371","cc3a5427d44fc77ff25e80b3edee4650a51f83de761faf5e633994ecf1ab1b44","b350eda75c6e47299b36002b31d5b220c405c21c365e708989829db013fadbb4","f421882756b6714834ae4687ab1aeadf344a1cc45437d2edffbac020ff3801c1","1d61d6ad832dabafbf63b86c5a79d704f2c8763ada9318e135b17a3cb2d09b32","e5cef5de3e5ad3436d414d20743231e284733b9cf4375dc79eff4fcca4282f99","e624419ba84e33e661e89a28083119ca41f6953dba09a4f82b660684087afe6d","942be430bd0feaced2e3e598273b17e50ea565ec9dac840b580b0b99e1a3cd5c","73350006cec5a0c6b71d53b0b0ddbfb82be96752a9c4e3c904c59e633bc9485e","a7df5c2e9594966c7e0d4a763b13ed5727506d892669df5f7bc9826f539c1d35","258cc5cd6891f6bcbaccefd953997038844e7f65d582cac987ffabf7181bcd4c","00a6db28fc4df6ddf10adbe630d9df620ec13af19039c1869653e60dafa739d2","649324d5abb5464aabe35d86cd0eef16562df811f0971481cee664afa5acbc88","930446bf32192f698b78f8ea4b309d8c2cfe02ab5ad78e4db907417405ebf5e7","5d3e07dbeabff37885262d9b4bd21c3185d95a09a268ab795f81135046a32bf4","7d309fbde13b5e30eff77c07a28b66451b0b50b83564d0cfa6a2a52c8b69aae6","f02da9dd36d7a9aa33c9b2e37ef1f54b0d9ad6a713bae372ae4b72890e40c168","29c188a2c660f99f1b4835022e011c4268d7af989d4b7dda33c0a69ca1a777f8","1ed0bf138e87912d741e28333b58cbf814ae863783b3b404d2454cbabb9c5fc0","3452ee7d8ef0b1bbd47b2a56924a1dc3c79dc84a19d212e9dc496f92e4943aa0","fab58e600970e66547644a44bc9918e3223aa2cbd9e8763cec004b2cfb48827e",{"version":"5943b853fbb3d54c14caf7190a70811ece9a04fd48a0a9f9694078ad9be5cd03","signature":"71e2431e82504b51217a255925d20a8758ad61230024650112b6d925e613b131"},{"version":"27b94a3360811c00d31465d0a7d933fa99b8cfc35c7171c22b7ededf7365743f","signature":"7647ca5b6dceccb21afdc7a2e235e039d263ad63a7755615475acde462191303"},{"version":"af308fa8bc4c9a7c7119b80178db71aa9505cc8e30abf8b08f8dba29f13c2da6","signature":"81fd56fe7184f4ed76f8e77a28d55c65c658bf236bf29641ecae539af316ac11"},{"version":"f6dd5225cdffc53362c00c27356916cfefb1aec0103d83498e8c60660211a6d1","signature":"844fc48aee32b6984d89f632c8f2093697308819d958ad09bd9485061b484a2d"},"da04ea3f901991d8097ac63ef6fb5967726e3dc1924e2c8efef374b1db9487c6","96c42cfe5614d9f894078048dda1b53409774bd502d584ffa9bee3c1b39537fc","a49dd2c42f34a0f8fd8577340378112785f3a8fa44c5fe6522466421c68f66f2","7a3e0d544a45a2801f7b657fb931e5ceb749cac766560a4cde600c171b41079f","78edf86617005dfa5709c44024989d60398a21bbf865574680e0cdb29e93b88b","0dd44432ff360867ec9422c184e78973fec749dc96920c23aa02088a908cb0cd","06b1afe677e95808681e5260e9f567815e67c59d00eb5de7d21e4754581deb8c","58b3270f2e1111859e0f15c74d2a47b45471a6cda53bb61fadf2d17987ff4c0e","ff6139ad0ecc332393c72a42af66734c3104f775ceeb7af4533fd82df42dfa51","12597a7bb3fa105568418303af2376061d15f57f2d5f24059082043b358dee74","4c2291243804f0e8610c1f05f0d2a3c5a1497e34bf6314378a0857cd42472680","d2e012a1efa7115c2857284eb541e8b906c0d24c5918568e6dd77e2d6a9592f7","99d74aabcb821273945c9f8446f52b9fb27f666d7ee5b00b4814fc29ce72f307","3f1af437818017218c9a8afd6404d25ddb811482952a18c703acbf0889e5d5a4","f7478db71332be7f074506a83b8bd76d52569e022256c2088b27204f1b3b2f22","d4e4c606f38b8a083af300a9011d3bdf77dd63a5a98f05f1566dd84539df6562","e33dedae6123556e3052e6102b2bd64a3c99850b1eb21e27eaed328ccda6f611","391e793b760e7a3e504784021eab7b430a24a87821ad86ea1ae2da88fd2a413a","1356a2fbd07d5f9a5530f9658342bce4f0358f1620f0bba7a923f842ad8d0600","d2c0337f150e9d23259a20d6a6b1db9173f0171162adbd7c42b9a10d53b086b1","54586daaf9e77f8a26b27a4e3cb191f668c54abe9a402c2ce4be19c0b9d95207","95a276eeed4301374463a1725f4bd6a339a6e9dde5ba51910a17f65f8d0c2414","2094effba5caec56950d079ee0c08e175f38dd205d06a877e86cd4bf864fefa1","8c054d37f059c24bb3cc0f1a828009185ff690af19b5c68946074144f8c11904",{"version":"e373335267f87da95f743241e0b215a4833fb705465504fb2a443c64c6e4a925","signature":"1991a87fd9ce6a724003881138ca1320d26a5faffd436a5cf097d0c5ac8a47a9"},"53f6d74dbd78f08ed7b56f6b0a558b7f8d201852ebcde17e7a0be8816abafff2",{"version":"e70b434f94e9577074497973d65bfc8c940ee6b0cfd8869489bc701759c29f28","signature":"f1d217f36dbd97aaa1014006113535b447cce411dae240062350ffb9f8435b9e"},"14c94f7888c75007a94132f03caef0f6b58bcb136c2994213fd2d3b99f3d7f85","4695042a55a75a6c62dc57f2efe60ef3c7bbe19adedb5081f6e51dd664bbc3f7","b006ad8d854471e7a270bd8918508090961bdc1cfe77ed51f13f471fe682acac","310901df1081433ff7c3b7918496cabb92ded208b04294d3d2bd35acae2de836","c8646410cd2a6bf05eb7e7a51c881776410d07fd5d8f75092a2c815c9c6fda52","37a4a7a5aef4e6a9c652e636aefeef0df9a1cddc24d94dc00a32401a9c9cf8a6","deb2b8baebf3bb0d77453a950dc16dd3f51cbdc12efb69bf8bc4805fbf20fe7e","032108185be5a41a316b4a7872c74331bd574b13499f4b32ce7105ba1c12c339","bd05b91626fdf3e479751850b11e93c3d05ec9dc2afe6e0c1614dd34162aa970","b2ff62f5ded5dc3f30e89fd7d3bd1e5904085326e16ae71cec450b14bb0884e7","afbf3186ef8d68015006b1ed3bbaf54eece8908c27b146b0f7d522842f3210ac","09aea5c0044ff8161e00a9e874bfa5806652270d490dba2a914606f89351ef06","d42ca1c2dc79317b5fb8e14a7d85fc0addc9fe2b142355e34753d60ccc78007a","598b50b11b8daa1bee5f6c59c35ef8df93e05737ec541846634d79bdc60b8503","b40d2724b7cfa63ce888b2e6ebc269c9472109f65072ec9eddb97a83f4801897","2897ce01245d031ff94ec172a8537473ab88c56b139dfcf6d2f620b7b6d4a450","9bbe7d497d72552f0c13b88affff3b9c43dc16037e55ee342e9e7c11d15fc1c8","269867d10a8163319dd29262fcde46cdc275f60fc8750119fe71480474c2b66b","cf0c859d39a640beb86ecc33ec846c32d705f9982aa69e11009e23649934b95f","0e5e5794df0a788165de5a59e25ce055250360a36764e91b060cc1d05e9a9b59","04f00895ed87b76dcfeae85fd8389b10b363d86f08da4d5283f0be5dc42cbee4",{"version":"a254f5dc005eaffffb0afc0c42d168534fc959b2bde70b494afedfe20bfd7dc5","signature":"6a6747a61a1d968c53970b79f35641fba4a17005efc6d021240f3897ce2878fe"},{"version":"4e0094fc185fa5d4aeaacd5f525579bdfd8c2e10fc9ba2b349b312f329aa8b3c","signature":"3f1a08c5204101a5aee11207600d595a3e8cc24ee2b320e6c29edf198573e744"},{"version":"a5a0fce9cab2c30d206b05b0f63d37fd9a0b8000051bff946984f818fc2ea6bd","signature":"567f0f4dfb84be50ed306a03fee43efb0780d122d2b52170bbdb4e44874131f1"},{"version":"e9526437280f5cf11d114fc5df84f529ca142df90a320a56176e363ebed5c0b5","signature":"8ddb476321ecb63bfd236d0f4fd7f9b8965f1866dae46bd3168f559c302f4e2d"},{"version":"e8a9d476c45af9c0330983441deeb93c39e325ebb73b3385b7644630bbeacf6e","signature":"1daa834e9f98c8e116c64ced04a0d81b7de730466b0d466a2e0b9538bb2eddc7"},{"version":"fda966faf72defd020e8015c802433c0411499b2e951f1e84e56d2363a3cc3f4","signature":"6ca03cf277f1e7faea10a346b1a62f195c0deb16d010723f6e3a5edd6e445b6c"},{"version":"57f05047b27a287520da059618d18c5e9be4d4372df6edfafa22cc4cee4129d3","signature":"5603161d52594be86fd7066626bef3b9166f10f9594fdda6a5e496d8ad56cfd0"},{"version":"c1d5dab3ed6d2e5d8986ce002d6341f49de45533444938cae2eb370e22b9cc7e","signature":"b9c4088f76376b9aa0005a67a2998bbe87c1222af2a62db949b6e5f006e3fb35"},{"version":"013344885a84af2fee522177a8409160cdaf87fec5523cec9a883d958d42785a","signature":"324a12bd7356b69c8f6cf1b75e02bc38cc167e2d4a2073ebffbd93388e224e09"},{"version":"3981b4f66c48b4c12898a051407a32d9d8ce84c6d7c476e83804a68270045e27","signature":"2d8e4effa6aa3bfff7d2cee7730b8f60e642ef0dd1a11b80e385738172eaa358"},{"version":"a04dd52280a45c96b6d9ac0af59246320e46f1925d3f0d7d481bdcd9f63927f5","signature":"c6c1d82d09e9b43209287e728d4a58d4d37f29cc774baa2a6538025eabd45c38"},"56c48fb5bb6316dfc27fbad065966b4ddbc38e9a0a1a5060d19b5da405ae7d6e","7091568b9a1b74b699ad09df6c130db712ed089d173a235e301a7a7ee0a4ca44","de33aa2a38affd9e71297ef7ec001a4525502878b09744308fb6518159f77d2d","57476e482c9b4e152bd23d0dc3c29375e48afee0de775674a3c1ea63cb4cf843","39554d914495ecc36b94d8bbc5076a6a891f12b7136cddb369a9a7083dd8522e","8fbe66a2959a393eb61b836224e0cd3983c89e5c2562d4875f36e3b61ee4cb77","c6695d874d1fd79c0f2266fc4943100b7b8d41d5e582408378763162679e8a92","ef69ca2ef1bd34fe5a447ccd3b055fbf12386487daff75bf109fb59e5eec06fc","ac9e28385721178e3e3f790128faf65baaf14191c070b2c9c5a50f337af5fb32","c244e83ebb4fe4d539d7f6d9405003d615e4bb7ba37629f0d5a0293c5f8bec7c","5716af400de6dc6ec6c90fa3d5b3dcb0ec1acd5156be0db4898f48796ad14f95","b22e4c25f0d8c8d0772da29fb1a697e4a7d118165f9217e9d2f7507a40633391","236dd26131e1ff9d6eb981e6865d6ef5e96f80f1353b6027800db9d3126282a1","37b51656ff8302a4556e29c775f311eb9ad813948d2c527405cea041dba3baf3","00abf32ca3af92f8be9ecbc9b63090b4909a756317d791927a83cffd24e9c8ac","cd28efe88fac7a92f3f5cfc7dd3c764f0b31bdaaa061ff044de1639810d6a7da","8b2100d3ba68063b7baf5038f26eefe46543dcebf1e7dbaf46277f24307cefcb","131b7f32092aa78e12fcb2a6db7c71e17f85e076c0635ad8d991b80d10130c19","d1c84af1e6d5fa4a5f4badd45b03b67c9255a675df235a3ec25307a0f5524278","aa4d6dc9282133162a76109d99c5795583276c4fd27284f128d484acf12b0841","3355c4c572f076ad963d95f0e28075b8558e2ab492c84eb94f9e2c48f1c2368b","5638cfd48b0c56bc9ed0c779d53a40b92c9cd9c9d6312e3a21c52542d38094f3","827eb54656695635a6e25543f711f0fe86d1083e5e1c0e84f394ffc122bd3ad7","2309cee540edc190aa607149b673b437cb8807f4e8d921bf7f5a50e6aa8d609c","703509e96cc30dce834ef8188c958c69306473b8a7e5cb3a6f324cee05a1f7bb","900daf04dc607dc3858c0f976d6f9e17b829a07de58d62dc6f730eaf06986075","08e0ac95e650bd4c87145b6ab2257b70c06254bf76a0b9f8a7d60c51fb8ed6b8","4b57ec505a035491c692b89af2c6902c312ec22f8fa9b6dae3e93686659fb7e0","7d796672940d3b2d37f2edea4d7bcf4c7993966286006228cbc8fa35ac92871d","132fd53917ed7f55275faa52c35e4d4d41e9576fea231d12740b723df2bade93","de2ecf9b1d6f60338f7b59b6f593ef77af9abd0e70ba8f2942953d0c6e1850af","f65593f26b317fcfb08789a72eca9a0785f0ee41efce6deaecfed6cf2d26b3a8","27ca878cf70b3030e8403f51ce65949d364fa776d6dae3527f91635a40836672","4c494db381ad1f479c137fdbb89dd32af10082cba7c11c2950a4e207bf4a3966","a45ee7555d019a67fbe092898d1aef0b1d02a9f6679ab84461ff515b4460d706","8c95f96ccd4be0674944077aec1e4f2cccd515ca06d4327562dd017250e7d3fc","6fe7571c8a80808224648046008d1366ba4e29206ac79ce4c56d6fab3350492b","ae2fbee237555ff41daf5275bcc337870886f673b2f029815a8cb6802dfaf2ff","1a7cee6cce12f69f55f8fc7a55093a26a6618596399e25ccb7b29d86bc5df45f","a2f40a7fcef1f6040a09c9d7b9561d25d360917f80eb845b942dd6664dcb3830","a64568c16a5821575de4f6280ba1ea4686a1ceecd649fa90ba957c8b1b007013","11a8a3bf561b28e887819dec170064b63eaa3e08ab8c9385858a152f0764368b","1fdc3c9aa704209302fcb28c0afc62921b8e3de27160095495df3fe11ebf0468","a39c32b055d2e6103e5c49b9aed2d7bb5b06571c98fc31105264d280431bdbd7","618ebb93311695a13844118cdc9a7314dd3a2c6f35092d87f76828cac555ddc9","d36c3d116ce59a3f072c0014f0c020c76e916ba906066ddc4f193f546a43bceb","9bed8447acaa89be63540ec500b165442fcb0de020015175b5a5c66d42a61c4a","0df1434fa41979b81c7872ffdf6bb4890de5d3f1deddec785330ccfbd20928e5","a17e6861b709149f29a2bd896cee94526df2f06b24a2b60614b56649b5e9aabe","9c79ace686f720f4dd833740f7190e12cdce363362c982c164745527a412ef40","d14292ed4bd13d106adca4a774e71e21aa2c3d3c38135f4ec30650e33249d13d","75d48857bc4216880443a24d985071262bb8b89a9952c77fd430cb0caa21f9bf","33e40cf77499b3d9712db82e15683373925e85817dbe82a24ee0ee6e44bffb70","d5bbd453310990e851908183fbbef9e6e2db8e0c86d97b42b723fd5238f71c81","95e76bed30f6e993e1fcc1b90a4675682e4800ae43403547a775d6e3c7ab2b0f","8b206b995edc6dd849b85c1c56531b9780e3ba75302fd02a2d173f008028707e","97040b190f0daa10cf9a15e51a2fac66b26ddefd7b65998bd6027d1dd67647b7","877c25dfae100e555014e45d1d80364496a0c876201e5dea91a0fd0a6a4ff765","d53f9f96afd41359edeb2d5ad98559f3bfad261391d5aef95320fefb0c6a8742","23d98226adf3be74e1f0470f85e7fd154cd7aa979d60b43190a7437f0d0426eb","639f9321a98b734242a3573764d7f1de5369b0b0b10c768ae37639e8bda5dd03","05876912d3f60a58635248b50e37a20dedc89421f4a6d6ce6f13545fde7c6ed1","dc5fe5f6b39c3fdfaeba333bcd5f0cc98bb3068797a4d7010f585366f549ddf7","4a3ab8cb278bfd1f18f24cc45a02188b63afa6aef50035df6d79c4638f24059a","e724c9ce92f2a8a31ed260764c5455852a13d292e2a31d26acc6840ec0e83208","42cab173ca1afa1abcb1e10b7022fe302a496962746be5c2c8b700f738b463a7","257ef2776cb9f5e8b8330f8a92b409a4e9d1979898f845aa09aa4fa9125a71d2","773bf9af93b5027de9b5b4c779d5cda35f0eb92c7f43a97f2ef3ca081495a191","edb6d09bae4fe20b6c33b196e9d5fb5baa72c2277a55ab87b650e79c711eca15","59625b1fcc91f2686751fd5b623126f434d7b405bd8d866a555963ce2ac69846","2f505cf4e223d7f98e91fba72420ae2ac24adc330c1bf1e645c84a3c6d957d96","fc69ffd599d3e525aba38f80c7cc2ecd187dbf148287364c75f199c8294a00e6","2ad138be6972de52ed966e6402aa6403af79e9f183486e0a725ffa075a0555fb","fdac2512ddaa17ff3746ad7d7ac3a346c02e0fe50647a8472195aa43ef5823e3","967fb6e86b55db228ab50c81f85f39d6a23a0c15bcfa6e19d255e0952d33a65a","c39e7d32dddfcdaa93b18b99fa430ebb1d6ba366459563d400add22f92e3644b","e3932de252bbe43132ad3226865b2a376ad945dbc1d767540c01b7bddc6477c2","b2f52f3cbd863dc4e690614b5cddbf412dea435d0de099db6d8adfd3cbefcd65","557c93b35f3b58e6844a9b8817559da1e0641f7f08f918e3cd1a8efee126746f","80ad2ae93d57dadac5e377ec6743df5e0211ea30bafd4b648c52366af057bb2b","07f90213b5800a0b43a6d6f309517dcca5afc6ffeb4bed396878a29fc5d6ceb0","bb0e637020f81cb40d16f202c3a783f0e269e29547fb84ca9f187a5ea8556965","462da802b50ac0d94a3c8f7f58a6a0aa08108bfc1394449ea56f1e0f63f5132e","2ccea88888048bbfcacbc9531a5596ea48a3e7dcd0a25f531a81bb717903ba4f","dfef9c847826fac5c480b6d972d3a597b932a2308f330a4416eeeb81c63ba1b2","e2379c5dcbe61406e60d82709829a1d4adf0b16c20ad915a2f1caa987c5f6dbe","21f706150e32f03ecd1714d7a7ac55ce3caadc7c7a2a960ba57cc5d39ad84c9d","6442db17edc8cac7c6c2b39e11c15d7431ec351c1a852b61c7a354ef5166f6f5","da1963f37d566ff9f71bf8ca5c628656bae02fc9509050041547e9c7063cc58f","57e4bed825036f7f1328505bc512af492f28b1b57a48f1ff9b6d90b930041a52","3ef0957915b7719ac58153eaea6ce810ff8688276e570f8938455f3ec7930df7","05e0ad043fdd4e2d4874a97bd716174af64d63e43851c09830c00e819a80d395","2dff0ed1eb2046fbdbc2c13914117e1ff1112e217f90542ea5e7f41e39f0393e","a0ba1e2711c2520189ed980225e7a429b0706a1eabf9113e53f0e72550a1b23d","61ab2f2d7b5cd232e133561a389c2cf8886a1e676d22296d0f9a80e9a43d931d","75af0adbecda3923b456088ff716dd43b39f4a8be2db64b397bf21bf7eddcf77","badb4cfbfc6eca3a038be22c76297bec0b5c1478d8b73d60e8b50725b7dcc15c","21e7e0eddddc112f2b891d1066eac74680291db768d3ef9b908965935380ab98","dc6ad8b550645082ef77a01cdc9186360a6b805799963107be45a7a051a94d84","516efe800aaa0b7504b71f2d7e7e9bed5f28eb6c9c739bfdf237f09c7addea46","10ae729013e6620dc937df5dd7077c34e29ad313a28aa75cec39957640cdc8b0","ac5f95dee5e4787fa7c68a81a052cdfa0e03adec8331d3276389384df36cb849","25107bef30f920db282053349c8110a40c94d4d8352aeb9732f59647f2d39b9f","a120dfb4736e6ec4c78f1bff5ff7f977d346152e6b7020659ee1ce4717f6f66f","955a15609b0b382eaefedbe00bd7b669244b05692989a0bfb44e206f2479a7da",{"version":"cfd225912d5e550fa821bc397ac8677db3e7f2d58d2d2971248c9155ad9d0362","signature":"a5ac165a57188ab19afc0375d08a98fb8886cfdb95bfeccb7cdae09c0854cc2f"},{"version":"2e2b305ab2b21ebc58807acffa34c734b9550c62801adc37e872c98c8d0f6bdb","signature":"7818f30a8d867d32f67c0a0ce64b002fdf855f4150b1fb5735249ff126727c0a"},"4489c6a9fde8934733aa7df6f7911461ee6e9e4ad092736bd416f6b2cc20b2c6","2c8e55457aaf4902941dfdba4061935922e8ee6e120539c9801cd7b400fae050","8041cfce439ff29d339742389de04c136e3029d6b1817f07b2d7fcbfb7534990","670a76db379b27c8ff42f1ba927828a22862e2ab0b0908e38b671f0e912cc5ed","9d38964b57191567a14b396422c87488cecd48f405c642daa734159875ee81d9","069bebfee29864e3955378107e243508b163e77ab10de6a5ee03ae06939f0bb9",{"version":"64d4b35c5456adf258d2cf56c341e203a073253f229ef3208fc0d5020253b241","affectsGlobalScope":true},"ee7d8894904b465b072be0d2e4b45cf6b887cdba16a467645c4e200982ece7ea","f3d8c757e148ad968f0d98697987db363070abada5f503da3c06aefd9d4248c1","bc3cba7b0af2d52e7425299aee518db479d44004eff6fbbd206d1ee7e5ec3fb5","afe73051ff6a03a9565cbd8ebb0e956ee3df5e913ad5c1ded64218aabfa3dcb5","035a5df183489c2e22f3cf59fc1ed2b043d27f357eecc0eb8d8e840059d44245","a4809f4d92317535e6b22b01019437030077a76fec1d93b9881c9ed4738fcc54","5f53fa0bd22096d2a78533f94e02c899143b8f0f9891a46965294ee8b91a9434","0d14fa22c41fdc7277e6f71473b20ebc07f40f00e38875142335d5b63cdfc9d2","d8aab31ba8e618cc3eea10b0945de81cb93b7e8150a013a482332263b9305322","462bccdf75fcafc1ae8c30400c9425e1a4681db5d605d1a0edb4f990a54d8094","5923d8facbac6ecf7c84739a5c701a57af94a6f6648d6229a6c768cf28f0f8cb","7adecb2c3238794c378d336a8182d4c3dd2c4fa6fa1785e2797a3db550edea62","dc12dc0e5aa06f4e1a7692149b78f89116af823b9e1f1e4eae140cd3e0e674e6","1bfc6565b90c8771615cd8cfcf9b36efc0275e5e83ac7d9181307e96eb495161","8a8a96898906f065f296665e411f51010b51372fa260d5373bf9f64356703190","7f82ef88bdb67d9a850dd1c7cd2d690f33e0f0acd208e3c9eba086f3670d4f73",{"version":"ccfd8774cd9b929f63ff7dcf657977eb0652e3547f1fcac1b3a1dc5db22d4d58","affectsGlobalScope":true},"d92dc90fecd2552db74d8dc3c6fb4db9145b2aa0efe2c127236ba035969068d4","96d14f21b7652903852eef49379d04dbda28c16ed36468f8c9fa08f7c14c9538","8841e2aa774b89bd23302dede20663306dc1b9902431ac64b24be8b8d0e3f649","916be7d770b0ae0406be9486ac12eb9825f21514961dd050594c4b250617d5a8","254d9fb8c872d73d34594be8a200fd7311dbfa10a4116bfc465fba408052f2b3","d88a5e779faf033be3d52142a04fbe1cb96009868e3bbdd296b2bc6c59e06c0e","d8f7109e14f20eb735225a62fd3f8366da1a8349e90331cdad57f4b04caf6c5a","cf3d384d082b933d987c4e2fe7bfb8710adfd9dc8155190056ed6695a25a559e","9871b7ee672bc16c78833bdab3052615834b08375cb144e4d2cba74473f4a589","c863198dae89420f3c552b5a03da6ed6d0acfa3807a64772b895db624b0de707","8b03a5e327d7db67112ebbc93b4f744133eda2c1743dbb0a990c61a8007823ef","86c73f2ee1752bac8eeeece234fd05dfcf0637a4fbd8032e4f5f43102faa8eec","42fad1f540271e35ca37cecda12c4ce2eef27f0f5cf0f8dd761d723c744d3159","ff3743a5de32bee10906aff63d1de726f6a7fd6ee2da4b8229054dfa69de2c34","83acd370f7f84f203e71ebba33ba61b7f1291ca027d7f9a662c6307d74e4ac22","1445cec898f90bdd18b2949b9590b3c012f5b7e1804e6e329fb0fe053946d5ec","0e5318ec2275d8da858b541920d9306650ae6ac8012f0e872fe66eb50321a669","cf530297c3fb3a92ec9591dd4fa229d58b5981e45fe6702a0bd2bea53a5e59be","c1f6f7d08d42148ddfe164d36d7aba91f467dbcb3caa715966ff95f55048b3a4","f4e9bf9103191ef3b3612d3ec0044ca4044ca5be27711fe648ada06fad4bcc85","0c1ee27b8f6a00097c2d6d91a21ee4d096ab52c1e28350f6362542b55380059a","7677d5b0db9e020d3017720f853ba18f415219fb3a9597343b1b1012cfd699f7","bc1c6bc119c1784b1a2be6d9c47addec0d83ef0d52c8fbe1f14a51b4dfffc675","52cf2ce99c2a23de70225e252e9822a22b4e0adb82643ab0b710858810e00bf1","770625067bb27a20b9826255a8d47b6b5b0a2d3dfcbd21f89904c731f671ba77","d1ed6765f4d7906a05968fb5cd6d1db8afa14dbe512a4884e8ea5c0f5e142c80","799c0f1b07c092626cf1efd71d459997635911bb5f7fc1196efe449bba87e965","2a184e4462b9914a30b1b5c41cf80c6d3428f17b20d3afb711fff3f0644001fd","9eabde32a3aa5d80de34af2c2206cdc3ee094c6504a8d0c2d6d20c7c179503cc","397c8051b6cfcb48aa22656f0faca2553c5f56187262135162ee79d2b2f6c966","a8ead142e0c87dcd5dc130eba1f8eeed506b08952d905c47621dc2f583b1bff9","a02f10ea5f73130efca046429254a4e3c06b5475baecc8f7b99a0014731be8b3","c2576a4083232b0e2d9bd06875dd43d371dee2e090325a9eac0133fd5650c1cb","4c9a0564bb317349de6a24eb4efea8bb79898fa72ad63a1809165f5bd42970dd","f40ac11d8859092d20f953aae14ba967282c3bb056431a37fced1866ec7a2681","cc11e9e79d4746cc59e0e17473a59d6f104692fd0eeea1bdb2e206eabed83b03","b444a410d34fb5e98aa5ee2b381362044f4884652e8bc8a11c8fe14bbd85518e","c35808c1f5e16d2c571aa65067e3cb95afeff843b259ecfa2fc107a9519b5392","14d5dc055143e941c8743c6a21fa459f961cbc3deedf1bfe47b11587ca4b3ef5","a3ad4e1fc542751005267d50a6298e6765928c0c3a8dce1572f2ba6ca518661c","f237e7c97a3a89f4591afd49ecb3bd8d14f51a1c4adc8fcae3430febedff5eb6","3ffdfbec93b7aed71082af62b8c3e0cc71261cc68d796665faa1e91604fbae8f","662201f943ed45b1ad600d03a90dffe20841e725203ced8b708c91fcd7f9379a","c9ef74c64ed051ea5b958621e7fb853fe3b56e8787c1587aefc6ea988b3c7e79","2462ccfac5f3375794b861abaa81da380f1bbd9401de59ffa43119a0b644253d","34baf65cfee92f110d6653322e2120c2d368ee64b3c7981dff08ed105c4f19b0","7d8ddf0f021c53099e34ee831a06c394d50371816caa98684812f089b4c6b3d4","7d2a0ba1297be385a89b5515b88cd31b4a1eeef5236f710166dc1b36b1741e1b","9d92b037978bb9525bc4b673ebddd443277542e010c0aef019c03a170ccdaa73","ab82804a14454734010dcdcd43f564ff7b0389bee4c5692eec76ff5b30d4cf66","bae8d023ef6b23df7da26f51cea44321f95817c190342a36882e93b80d07a960","ae271d475b632ce7b03fea6d9cf6da72439e57a109672671cbc79f54e1386938"],"options":{"composite":true,"declaration":true,"declarationMap":true,"emitDeclarationOnly":true,"esModuleInterop":true,"inlineSources":true,"module":1,"outDir":"./types","rootDir":"../src","sourceMap":true,"strict":true,"target":7},"fileIdsList":[[642],[92,128,129,130,145],[129,130,146,147],[128,129],[128,145,148,151],[128,148,151,152],[149,150,151,153,154],[128,151],[128,145,148,149,150,153],[128,136],[128],[92,128],[80,128],[132,133,134,135,136,137,138,139,140,141,142,143,144],[128,134,135],[128,134,136],[430,434,435],[430,433],[433],[434,436,438],[430,433,434,435,436,437],[430,433,437,441,442,443],[430,433,437,444],[430],[430,431],[431,432],[430,433,439,442,444,445],[440],[441,443,447,450,451],[441,443,451],[128,433,437,441,442,444,447],[441,451],[441,444,448],[433,442,444],[441,444,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462],[441,449],[128,449],[430,437,441,442,443,444,445,448],[441,443,447,449],[441,448,449],[128,155,265,266],[266,267],[265],[128,260],[260,261,262,263,264],[128,232,239,240],[128,232,239,240,260],[128,232,239,240,244],[128,232,239,240,241,243,244],[128,232,239,240,242],[128,232,239,240,245,246,248,249],[238,260],[128,232,239,240,245],[128,232,239,240,243],[128,232,239,240,256],[128,232,239,240,257],[131,229,232,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259],[230],[230,231],[230,239,240,245,246],[232,238,239],[277,278],[92,128,265,268,275],[268,277],[167,520],[167,518,520,521,522],[167,508],[508],[508,509,510,511,512,513,514,515,516,517],[518],[519],[343,349,350,353],[343,349,352],[345,347],[344],[345,347,348],[346],[352,357],[343,349,352,357],[349,352,354,355,356],[343,349,350,351,352,353,357],[343,349,351,353],[343,349],[64,167,281],[284],[64,281],[285,286],[64],[281,282,283,287,288,295,297,309,310,396],[64,167,397],[167,283,287],[290],[64,167],[289,291,292,293,294],[167,282,296],[167,296,297,308],[167,288,395],[58,64],[503,504,505,506],[536],[128,302,535],[128,302,536],[109,128,270],[270],[270,271,272,273,274],[269],[109,128],[302,538],[538,539,540,541,542,543,544,545,546,547],[538,539],[81,128,538,539],[125,128,538,539],[539],[167,204,211,298],[299],[303],[298,299,300,303,304,305,306,307],[128,300,302,305],[128,167,299,302,303],[298,305],[128,167,204,211,299,302],[167,211],[167,311],[311,312],[311,312,313,314],[167],[188,395,582,599,612,629,636],[634],[167,610,623,632,633,635],[622],[188,395,621],[128,211,302,537,548,599,600,612],[167,188,599,612],[548,601],[603],[600,601,602,604,607,609],[606],[601,605,610],[548,601,602],[167,548],[608],[601,602],[615,628,630,631],[599,612],[611,612,613,614],[599,612,613],[167,599,611,612],[167,599,612],[626,627],[167,188,592,626],[167,395,592],[167,184,188,395,470,582,592,599,610,612,615,617,623,625,628,629],[624],[167,395,599,612,629,632],[64,167,591],[128,167,316],[167,322],[339],[167,316,322,323,339,340,394],[128,167,315,316],[317,318,319,320,321],[58,64,319],[381],[384,385,386,387,388,389,390,391,392],[167,359],[322,339,390],[322,339,359],[359,360,367,370,380,381,382,393],[322,339],[358,360],[360],[322],[367],[167,370],[341,342,361,362,363,364,365,366,368,369,371,372,373,374,375,376,377,378,379],[167,372],[322,341,342,361,362,363,364,365,366,368,369,371,372,373,374,375,376,377,378],[308,380],[167,360],[337],[64,324],[325,326,327,328,329,330,331,332,333,334,335,336],[324,337,338],[64,337],[395],[552],[551],[64,167,558],[358],[167,315,395],[64,395,565],[549,550,552,553,554,555,556,559,560,561,562,563,564,565,566,567,568,583,584,586,587,588,589,590,593,594,595,596,597,598],[64,167,582],[64,167,395,552,586],[158],[585],[64,167,395,584],[64,395,584],[64,395,582,585,587,592,593],[64,167,552,555,566,586,587],[593],[199],[199,200,201],[67],[64,67],[65,66,67,68,69,70,71,72,73,74,75,156,159,160,161,162,163,164,165,166],[58,64,65],[67,73,75,155],[67,68],[64,162],[128,235],[233,234,237],[233,236],[128,233],[194,195],[642,643,644,645,646],[642,644],[157],[648,649,650],[93,128],[653],[654],[665],[659,664],[416,418,419,420,421,422,423,424,425,426,427,428],[416,417,419,420,421,422,423,424,425,426,427,428],[417,418,419,420,421,422,423,424,425,426,427,428],[416,417,418,420,421,422,423,424,425,426,427,428],[416,417,418,419,421,422,423,424,425,426,427,428],[416,417,418,419,420,422,423,424,425,426,427,428],[416,417,418,419,420,421,423,424,425,426,427,428],[416,417,418,419,420,421,422,424,425,426,427,428],[416,417,418,419,420,421,422,423,425,426,427,428],[416,417,418,419,420,421,422,423,424,426,427,428],[416,417,418,419,420,421,422,423,424,425,427,428],[416,417,418,419,420,421,422,423,424,425,426,428],[416,417,418,419,420,421,422,423,424,425,426,427],[76],[79],[80,85,112],[81,92,93,100,109,120],[81,82,92,100],[83,121],[84,85,93,101],[85,109,117],[86,88,92,100],[87],[88,89],[92],[91,92],[79,92],[92,93,94,109,120],[92,93,94,109],[92,95,100,109,120],[92,93,95,96,100,109,117,120],[95,97,109,117,120],[76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127],[92,98],[99,120,125],[88,92,100,109],[101],[102],[79,103],[104,119,125],[105],[106],[92,107],[107,108,121,123],[80,92,109,110,111],[80,109,111],[109,110],[112],[113],[92,115,116],[115,116],[85,100,109,117],[118],[100,119],[80,95,106,120],[85,121],[109,122],[123],[124],[80,85,92,94,103,109,120,123,125],[109,126],[128,301],[673,712],[673,697,712],[712],[673],[673,698,712],[673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711],[698,712],[713],[716],[616],[410,411,412,413,414],[410],[412],[410,412],[476,477,478,479,480],[481],[478,481],[479],[490,491,492],[493],[490,493],[128,482,488],[128,482,488,489,493],[482,488],[494,495,496,497],[494],[128,488,489,499],[481,482,483,484,485,486,487,488,490,493,498],[128,488,499],[128,481,482,483,484,485,486,487,490,493],[128,481,482,488,489],[128,482,488,489],[557],[204],[216,217,218],[204,215,216],[179],[179,180,181,182,183],[168,169,170,171,172,173,174,175,176,177,178],[657,660],[657,660,661,662],[659],[656,663],[464,465],[658],[57,59,60,61,62,63],[57,58],[59],[58,59],[57,59],[188,397,406,636],[637,638],[406,471],[167,188,315],[468,469],[167,188,191,198,224,228,409,415,428],[46,167,188,192,198,224,409,446,463,524,525,530,531],[167,192,198,433,466,474,501,529],[198],[188,198,224,228,415,502],[429,473,474,501,527,528,529,530,532,533,534,640],[92,167,188,192,198,224,315,409,415,467,470,471,472,473,530,532],[167,188,198,224,228,409,472,474],[52,145,167,192,198,446,463,523,530],[52,192,198,446,463,530],[52,198,446,463,530],[167,198,475,499],[475,500],[167,198,530],[188,198,409,528,529,532],[47,167,188,198,224,228,406,409,527,528,529,530,532,639],[167,188,198,224,228,415,526,530],[167,188,198,224,228,409,428,475,502,528,530],[47,52,92,167,184,188,198,224,315,409,415,446,463,470,471,524,525,526,527,529,530],[167,184,185,186],[185],[56,185,186,187],[186],[189],[189,190,193,197],[196],[167,191,192],[212,213,214],[211,212],[167,211,212],[167,204,211],[167,205],[205,206,207,208,209,210],[167,204],[405],[155,167,184,188,279,280,397,404],[92,128,167,188],[398],[398,399,400,401,402,403],[198,398],[220],[203,220,222,223],[167,188,191,198,202,203,220,221],[167,198,215,219],[167,574,575,576],[315,575],[572,573,574,575,576,577,581],[167,211,574,576,582],[167,188,198,569,572,574,577],[167,184,188,198,315,470,569,570,571,572,573,575,576,577],[167,211,573,574,575],[578,579,580],[167,198,211,573,575,576],[167,211,573,575,576],[167,188,574],[167,211,575,577],[620],[55,188,198,618,619],[167,188,224,225],[225,226,227],[128,167,188,224,225],[167,224],[407,408],[188,406,407],[188,191,224,228,409],[167,188,192,224,409,463,524,525,531],[167,192,433,474,501,529],[188,224,228,502],[92,167,188,224,409,470,472,473,532],[167,188,224,228,409,472,474],[192,463],[463],[167,475],[188,409,528,529,532],[188,224,228,406,409,527,528,532,639],[167,188,224,228],[167,188,224,228,409,475,528],[92,167,184,188,224,409,446,463,470,527,529]],"referencedMap":[[644,1],[146,2],[148,3],[130,4],[152,5],[153,6],[149,6],[155,7],[150,6],[154,8],[151,9],[137,10],[134,11],[141,12],[135,10],[132,13],[145,14],[139,11],[136,15],[138,16],[436,17],[435,18],[434,19],[439,20],[438,21],[444,22],[445,23],[467,18],[431,24],[432,25],[433,26],[446,27],[441,28],[452,29],[453,30],[448,31],[454,32],[455,33],[456,33],[447,34],[463,35],[458,29],[457,36],[459,37],[449,38],[460,32],[461,30],[451,39],[462,36],[450,40],[442,18],[267,41],[268,42],[266,43],[263,44],[262,44],[261,44],[265,45],[247,46],[252,47],[241,46],[246,48],[245,49],[243,50],[250,51],[251,46],[253,52],[254,53],[256,54],[257,55],[258,56],[260,57],[231,58],[232,59],[248,60],[240,61],[279,62],[277,63],[278,64],[276,45],[521,65],[523,66],[509,67],[510,68],[511,68],[512,67],[513,67],[514,68],[518,69],[515,67],[516,68],[517,68],[519,70],[520,71],[351,72],[353,73],[348,74],[345,75],[349,76],[347,77],[354,78],[355,79],[357,80],[356,78],[358,81],[352,82],[350,83],[282,84],[285,85],[284,86],[287,87],[286,88],[397,89],[289,90],[290,91],[291,92],[292,93],[295,94],[294,84],[296,84],[297,95],[309,96],[310,95],[396,97],[281,98],[507,99],[537,100],[536,101],[535,102],[271,103],[272,104],[275,105],[273,104],[270,106],[274,107],[269,12],[539,108],[548,109],[544,110],[543,111],[546,110],[545,112],[547,113],[542,113],[541,110],[540,113],[299,114],[300,115],[304,116],[308,117],[306,118],[305,119],[307,120],[303,121],[298,122],[312,123],[313,124],[315,125],[311,126],[204,12],[634,127],[635,128],[636,129],[623,130],[622,131],[601,132],[600,133],[603,134],[604,135],[610,136],[607,137],[606,138],[605,139],[602,140],[609,141],[608,142],[632,143],[613,144],[615,145],[614,146],[612,147],[611,148],[628,149],[627,150],[626,151],[631,144],[630,152],[624,126],[625,153],[633,154],[592,155],[591,93],[323,156],[316,157],[340,158],[395,159],[317,160],[318,126],[319,126],[322,161],[320,162],[382,163],[384,126],[385,158],[393,164],[386,126],[387,126],[388,165],[389,126],[391,166],[390,167],[392,88],[394,168],[367,88],[341,158],[342,169],[361,170],[362,171],[363,170],[365,126],[366,172],[368,173],[371,174],[380,175],[373,176],[372,126],[374,126],[375,157],[379,177],[376,172],[377,174],[378,158],[360,165],[381,178],[370,179],[338,180],[325,181],[334,181],[326,181],[327,181],[336,181],[328,181],[329,181],[337,182],[335,181],[330,181],[333,181],[331,181],[332,181],[339,183],[324,184],[550,185],[553,186],[554,187],[556,186],[559,188],[562,189],[564,190],[566,191],[599,192],[583,193],[568,126],[587,194],[588,195],[586,196],[585,197],[589,198],[594,199],[584,98],[593,200],[596,185],[597,201],[598,126],[552,187],[200,202],[201,202],[202,203],[65,88],[66,88],[68,204],[69,88],[70,88],[71,205],[67,88],[167,206],[75,207],[156,208],[159,195],[165,209],[166,210],[236,211],[235,11],[238,212],[233,11],[237,213],[234,214],[196,215],[647,216],[643,1],[645,217],[646,1],[192,11],[158,218],[651,219],[652,220],[654,221],[655,222],[666,223],[665,224],[417,225],[418,226],[416,227],[419,228],[420,229],[421,230],[422,231],[423,232],[424,233],[425,234],[426,235],[427,236],[428,237],[76,238],[77,238],[79,239],[80,240],[81,241],[82,242],[83,243],[84,244],[85,245],[86,246],[87,247],[88,248],[89,248],[90,249],[91,250],[92,251],[93,252],[94,253],[95,254],[96,255],[97,256],[128,257],[98,258],[99,259],[100,260],[101,261],[102,262],[103,263],[104,264],[105,265],[106,266],[107,267],[108,268],[109,269],[111,270],[110,271],[112,272],[113,273],[115,274],[116,275],[117,276],[118,277],[119,278],[120,279],[121,280],[122,281],[123,282],[124,283],[125,284],[126,285],[670,11],[302,286],[672,11],[697,287],[698,288],[673,289],[676,289],[695,287],[696,287],[686,287],[685,290],[683,287],[678,287],[691,287],[689,287],[693,287],[677,287],[690,287],[694,287],[679,287],[680,287],[692,287],[674,287],[681,287],[682,287],[684,287],[688,287],[699,291],[687,287],[675,287],[712,292],[706,291],[708,293],[707,291],[700,291],[701,291],[703,291],[705,291],[709,293],[710,293],[702,293],[704,293],[714,294],[717,295],[617,296],[415,297],[411,298],[413,299],[414,300],[481,301],[476,302],[477,302],[479,303],[478,304],[480,302],[493,305],[492,306],[491,307],[483,308],[490,309],[482,11],[489,310],[498,311],[496,312],[484,313],[499,314],[485,315],[488,316],[486,317],[487,318],[558,319],[216,320],[219,321],[217,322],[218,322],[175,323],[177,323],[176,323],[174,323],[184,324],[179,325],[170,323],[171,323],[172,323],[173,323],[661,326],[663,327],[662,326],[660,328],[664,329],[466,330],[659,331],[64,332],[59,333],[60,334],[61,334],[62,335],[63,335],[58,336],[637,337],[639,338],[638,339],[468,340],[470,341],[429,342],[532,343],[530,344],[502,345],[533,346],[641,347],[474,348],[473,349],[524,350],[525,351],[531,352],[475,126],[500,353],[501,354],[526,355],[534,356],[640,357],[527,358],[529,359],[528,360],[187,361],[186,362],[188,363],[185,364],[190,365],[198,366],[197,367],[193,368],[215,369],[213,370],[214,371],[212,372],[206,373],[207,373],[209,373],[211,374],[205,375],[210,373],[406,376],[405,377],[398,378],[403,379],[402,379],[404,380],[399,379],[400,381],[401,379],[221,382],[223,382],[224,383],[222,384],[220,385],[577,386],[576,387],[582,388],[571,389],[575,390],[574,391],[578,392],[581,393],[579,394],[580,395],[572,396],[573,397],[621,398],[620,399],[619,398],[226,400],[228,401],[227,402],[225,403],[409,404],[408,405]],"exportedModulesMap":[[644,1],[146,2],[148,3],[130,4],[152,5],[153,6],[149,6],[155,7],[150,6],[154,8],[151,9],[137,10],[134,11],[141,12],[135,10],[132,13],[145,14],[139,11],[136,15],[138,16],[436,17],[435,18],[434,19],[439,20],[438,21],[444,22],[445,23],[467,18],[431,24],[432,25],[433,26],[446,27],[441,28],[452,29],[453,30],[448,31],[454,32],[455,33],[456,33],[447,34],[463,35],[458,29],[457,36],[459,37],[449,38],[460,32],[461,30],[451,39],[462,36],[450,40],[442,18],[267,41],[268,42],[266,43],[263,44],[262,44],[261,44],[265,45],[247,46],[252,47],[241,46],[246,48],[245,49],[243,50],[250,51],[251,46],[253,52],[254,53],[256,54],[257,55],[258,56],[260,57],[231,58],[232,59],[248,60],[240,61],[279,62],[277,63],[278,64],[276,45],[521,65],[523,66],[509,67],[510,68],[511,68],[512,67],[513,67],[514,68],[518,69],[515,67],[516,68],[517,68],[519,70],[520,71],[351,72],[353,73],[348,74],[345,75],[349,76],[347,77],[354,78],[355,79],[357,80],[356,78],[358,81],[352,82],[350,83],[282,84],[285,85],[284,86],[287,87],[286,88],[397,89],[289,90],[290,91],[291,92],[292,93],[295,94],[294,84],[296,84],[297,95],[309,96],[310,95],[396,97],[281,98],[507,99],[537,100],[536,101],[535,102],[271,103],[272,104],[275,105],[273,104],[270,106],[274,107],[269,12],[539,108],[548,109],[544,110],[543,111],[546,110],[545,112],[547,113],[542,113],[541,110],[540,113],[299,114],[300,115],[304,116],[308,117],[306,118],[305,119],[307,120],[303,121],[298,122],[312,123],[313,124],[315,125],[311,126],[204,12],[634,127],[635,128],[636,129],[623,130],[622,131],[601,132],[600,133],[603,134],[604,135],[610,136],[607,137],[606,138],[605,139],[602,140],[609,141],[608,142],[632,143],[613,144],[615,145],[614,146],[612,147],[611,148],[628,149],[627,150],[626,151],[631,144],[630,152],[624,126],[625,153],[633,154],[592,155],[591,93],[323,156],[316,157],[340,158],[395,159],[317,160],[318,126],[319,126],[322,161],[320,162],[382,163],[384,126],[385,158],[393,164],[386,126],[387,126],[388,165],[389,126],[391,166],[390,167],[392,88],[394,168],[367,88],[341,158],[342,169],[361,170],[362,171],[363,170],[365,126],[366,172],[368,173],[371,174],[380,175],[373,176],[372,126],[374,126],[375,157],[379,177],[376,172],[377,174],[378,158],[360,165],[381,178],[370,179],[338,180],[325,181],[334,181],[326,181],[327,181],[336,181],[328,181],[329,181],[337,182],[335,181],[330,181],[333,181],[331,181],[332,181],[339,183],[324,184],[550,185],[553,186],[554,187],[556,186],[559,188],[562,189],[564,190],[566,191],[599,192],[583,193],[568,126],[587,194],[588,195],[586,196],[585,197],[589,198],[594,199],[584,98],[593,200],[596,185],[597,201],[598,126],[552,187],[200,202],[201,202],[202,203],[65,88],[66,88],[68,204],[69,88],[70,88],[71,205],[67,88],[167,206],[75,207],[156,208],[159,195],[165,209],[166,210],[236,211],[235,11],[238,212],[233,11],[237,213],[234,214],[196,215],[647,216],[643,1],[645,217],[646,1],[192,11],[158,218],[651,219],[652,220],[654,221],[655,222],[666,223],[665,224],[417,225],[418,226],[416,227],[419,228],[420,229],[421,230],[422,231],[423,232],[424,233],[425,234],[426,235],[427,236],[428,237],[76,238],[77,238],[79,239],[80,240],[81,241],[82,242],[83,243],[84,244],[85,245],[86,246],[87,247],[88,248],[89,248],[90,249],[91,250],[92,251],[93,252],[94,253],[95,254],[96,255],[97,256],[128,257],[98,258],[99,259],[100,260],[101,261],[102,262],[103,263],[104,264],[105,265],[106,266],[107,267],[108,268],[109,269],[111,270],[110,271],[112,272],[113,273],[115,274],[116,275],[117,276],[118,277],[119,278],[120,279],[121,280],[122,281],[123,282],[124,283],[125,284],[126,285],[670,11],[302,286],[672,11],[697,287],[698,288],[673,289],[676,289],[695,287],[696,287],[686,287],[685,290],[683,287],[678,287],[691,287],[689,287],[693,287],[677,287],[690,287],[694,287],[679,287],[680,287],[692,287],[674,287],[681,287],[682,287],[684,287],[688,287],[699,291],[687,287],[675,287],[712,292],[706,291],[708,293],[707,291],[700,291],[701,291],[703,291],[705,291],[709,293],[710,293],[702,293],[704,293],[714,294],[717,295],[617,296],[415,297],[411,298],[413,299],[414,300],[481,301],[476,302],[477,302],[479,303],[478,304],[480,302],[493,305],[492,306],[491,307],[483,308],[490,309],[482,11],[489,310],[498,311],[496,312],[484,313],[499,314],[485,315],[488,316],[486,317],[487,318],[558,319],[216,320],[219,321],[217,322],[218,322],[175,323],[177,323],[176,323],[174,323],[184,324],[179,325],[170,323],[171,323],[172,323],[173,323],[661,326],[663,327],[662,326],[660,328],[664,329],[466,330],[659,331],[64,332],[59,333],[60,334],[61,334],[62,335],[63,335],[58,336],[637,337],[639,338],[638,339],[468,340],[470,341],[429,406],[532,407],[530,408],[533,409],[641,347],[474,410],[473,411],[524,412],[525,412],[531,413],[475,126],[500,414],[501,354],[526,126],[534,415],[640,416],[527,417],[529,418],[528,419],[187,361],[186,362],[188,363],[185,364],[190,365],[198,366],[197,367],[193,368],[215,369],[213,370],[214,371],[212,372],[206,373],[207,373],[209,373],[211,374],[205,375],[210,373],[406,376],[405,377],[398,378],[403,379],[402,379],[404,380],[399,379],[400,381],[401,379],[221,382],[223,382],[224,383],[222,384],[220,385],[577,386],[576,387],[582,388],[571,389],[575,390],[574,391],[578,392],[581,393],[579,394],[580,395],[572,396],[573,397],[621,398],[620,399],[619,398],[226,400],[228,401],[227,402],[225,403],[409,404],[408,405]],"semanticDiagnosticsPerFile":[644,642,146,129,148,130,147,152,153,149,155,150,154,151,137,134,141,135,132,140,145,142,143,144,139,136,133,138,436,435,434,439,438,444,445,467,431,432,433,430,446,441,440,437,452,453,448,454,455,456,447,463,458,457,459,449,460,461,451,462,450,442,443,267,268,266,263,262,261,265,264,247,252,241,246,245,243,250,251,253,255,254,256,257,258,260,231,230,232,248,229,242,240,239,249,244,259,279,277,278,276,521,522,523,509,510,511,512,513,514,518,515,508,516,517,519,520,280,191,351,353,343,348,345,349,347,354,355,357,356,358,352,350,282,283,285,284,287,286,288,397,289,290,291,292,295,293,294,296,297,309,310,396,281,505,503,504,506,507,537,536,535,271,272,275,273,270,274,269,539,548,544,543,546,545,547,538,542,541,540,299,300,304,308,306,305,307,303,298,312,314,313,315,311,204,634,635,636,623,622,601,600,603,604,610,607,606,605,602,609,608,632,613,615,614,612,611,628,627,626,631,630,629,624,625,633,592,591,323,316,340,395,317,318,319,322,320,321,359,382,384,385,393,386,387,388,389,391,390,392,383,394,367,341,342,361,362,363,364,365,366,368,369,371,380,373,372,374,375,379,376,377,378,360,381,370,338,325,334,326,327,336,328,329,337,335,330,333,331,332,339,324,549,550,553,554,555,556,559,560,561,562,563,564,565,566,567,599,583,568,587,588,586,585,589,590,594,595,584,593,596,597,598,552,551,200,201,202,199,65,66,68,69,70,71,72,73,74,67,167,75,156,159,160,161,162,163,164,165,166,236,235,238,233,237,234,344,346,194,196,195,647,643,645,646,192,158,570,648,651,649,652,653,654,655,666,665,650,667,417,418,416,419,420,421,422,423,424,425,426,427,428,668,157,76,77,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,78,127,95,96,97,128,98,99,100,101,102,103,104,105,106,107,108,109,111,110,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,669,670,671,618,302,301,672,697,698,673,676,695,696,686,685,683,678,691,689,693,677,690,694,679,680,692,674,681,682,684,688,699,687,675,712,711,706,708,707,700,701,703,705,709,710,702,704,714,713,715,471,716,717,617,616,415,411,410,413,412,414,131,656,481,476,477,479,478,480,493,492,491,483,490,482,489,494,495,498,496,497,484,499,485,488,486,487,557,558,216,219,217,218,178,175,177,176,174,184,179,183,180,182,181,170,171,172,168,169,173,657,661,663,662,660,664,464,466,465,569,659,658,57,64,59,60,61,62,63,58,8,10,9,2,11,12,13,14,15,16,17,18,3,4,22,19,20,21,23,24,25,5,26,27,28,29,6,33,30,31,32,34,7,35,40,41,36,37,38,39,1,42,637,639,638,468,469,470,429,532,530,472,502,533,641,474,473,524,525,531,475,500,501,526,534,640,527,529,528,56,187,186,188,185,190,198,197,189,193,215,213,214,212,206,207,208,209,211,205,210,406,405,398,403,402,404,399,400,401,203,221,223,224,222,220,577,576,582,571,575,574,578,581,579,580,572,573,621,620,619,226,228,227,225,407,409,408,47,48,49,50,51,52,43,53,54,55,44,45,46],"latestChangedDtsFile":"./types/index.d.ts"},"version":"4.9.5"}
\ No newline at end of file
diff --git a/dist/types/NftController.d.ts b/dist/types/NftController.d.ts
index 7b906c312689c987e26f6edbf3e4e2fb15b97f03..4300b6940ea450fcdc61603d91794eba8722b5d0 100644
--- a/dist/types/NftController.d.ts
+++ b/dist/types/NftController.d.ts
@@ -294,7 +294,7 @@ export declare class NftController extends BaseControllerV1<NftConfig, NftState>
     /**
      * EventEmitter instance used to listen to specific EIP747 events
      */
-    hub: EventEmitter;
+    hub: EventEmitter<[never]>;
     /**
      * Optional API key to use with opensea
      */
diff --git a/dist/types/NftController.d.ts.map b/dist/types/NftController.d.ts.map
index 61d1d30dcdf8fdb39165ea37fefd0a91eb86d9b7..c95f93bfe7f66025694dbca28e6aadbe83ba4347 100644
--- a/dist/types/NftController.d.ts.map
+++ b/dist/types/NftController.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"NftController.d.ts","sourceRoot":"","sources":["../../src/NftController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"NftController.d.ts","sourceRoot":"","sources":["../../src/NftController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/types/TokenRatesController.d.ts b/dist/types/TokenRatesController.d.ts
index 8f35b5b871fd9cf3c7aac8cf8c07d4461acec2bc..9ebfdd8560ff4f9d96dc85f22da4739fefdceb96 100644
--- a/dist/types/TokenRatesController.d.ts
+++ b/dist/types/TokenRatesController.d.ts
@@ -54,16 +54,61 @@ export interface TokenRatesConfig extends BaseConfig {
 export interface ContractExchangeRates {
     [address: string]: number | undefined;
 }
+export type ContractInformations = {
+    marketData: Record<Hex, {
+        tokenAddress: `0x${string}`;
+        value: number;
+        currency: string;
+        allTimeHigh: number;
+        allTimeLow: number;
+        circulatingSupply: number;
+        dilutedMarketCap: number;
+        high1d: number;
+        low1d: number;
+        marketCap: number;
+        marketCapPercentChange1d: number;
+        price: number;
+        priceChange1d: number;
+        pricePercentChange1d: number;
+        pricePercentChange1h: number;
+        pricePercentChange1y: number;
+        pricePercentChange7d: number;
+        pricePercentChange14d: number;
+        pricePercentChange30d: number;
+        pricePercentChange200d: number;
+        totalVolume: number;
+    }>;
+};
 /**
  * @type TokenRatesState
  *
  * Token rates controller state
- * @property contractExchangeRates - Hash of token contract addresses to exchange rates (single globally selected chain, will be deprecated soon)
- * @property contractExchangeRatesByChainId - Hash of token contract addresses to exchange rates keyed by chain ID and native currency (ticker)
+ * @property marketData - Hash of token contract addresses to market data
  */
 export interface TokenRatesState extends BaseState {
-    contractExchangeRates: ContractExchangeRates;
-    contractExchangeRatesByChainId: Record<Hex, Record<string, ContractExchangeRates>>;
+    marketData: Record<Hex, Record<Hex, {
+        tokenAddress: `0x${string}`;
+        value: number;
+        currency: string;
+        allTimeHigh: number;
+        allTimeLow: number;
+        circulatingSupply: number;
+        dilutedMarketCap: number;
+        high1d: number;
+        low1d: number;
+        marketCap: number;
+        marketCapPercentChange1d: number;
+        price: number;
+        priceChange1d: number;
+        pricePercentChange1d: number;
+        pricePercentChange1h: number;
+        pricePercentChange1y: number;
+        pricePercentChange7d: number;
+        pricePercentChange14d: number;
+        pricePercentChange30d: number;
+        pricePercentChange200d: number;
+        totalVolume: number;
+    }>>;
 }
 /**
  * Controller that passively polls on a set interval for token-to-fiat exchange rates
diff --git a/dist/types/TokenRatesController.d.ts.map b/dist/types/TokenRatesController.d.ts.map
index d0eae3c561e5ec3462ee581acf01d1ec6c725b8c..771704fc7086ff97c4aef04f87ac6903be79dfc1 100644
--- a/dist/types/TokenRatesController.d.ts.map
+++ b/dist/types/TokenRatesController.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"TokenRatesController.d.ts","sourceRoot":"","sources":["../../src/TokenRatesController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"TokenRatesController.d.ts","sourceRoot":"","sources":["../../src/TokenRatesController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/types/TokensController.d.ts b/dist/types/TokensController.d.ts
index 76e3aaf2b5788a9e8abbb46a67a571073878a3ac..5f6d47652877808480330e2ff30f3abf06bcfd76 100644
--- a/dist/types/TokensController.d.ts
+++ b/dist/types/TokensController.d.ts
@@ -115,7 +115,7 @@ export declare class TokensController extends BaseControllerV1<TokensConfig, Tok
     /**
      * EventEmitter instance used to listen to specific EIP747 events
      */
-    hub: EventEmitter;
+    hub: EventEmitter<[never]>;
     /**
      * Name of this controller used during composition
      */
diff --git a/dist/types/TokensController.d.ts.map b/dist/types/TokensController.d.ts.map
index 5b08f62fc7eae3f941173fb15de8cfdaec9f18d3..34a437f6f0cb57b2fb4a0d9198900146c017dfa2 100644
--- a/dist/types/TokensController.d.ts.map
+++ b/dist/types/TokensController.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"TokensController.d.ts","sourceRoot":"","sources":["../../src/TokensController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"TokensController.d.ts","sourceRoot":"","sources":["../../src/TokensController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/types/token-prices-service/abstract-token-prices-service.d.ts b/dist/types/token-prices-service/abstract-token-prices-service.d.ts
index d95cc33ab58df7368a399a2c2e688de08249f66d..1a490acb522f4a7d174bece174b2de0b13c1acc9 100644
--- a/dist/types/token-prices-service/abstract-token-prices-service.d.ts
+++ b/dist/types/token-prices-service/abstract-token-prices-service.d.ts
@@ -6,6 +6,24 @@ export type TokenPrice<TokenAddress extends Hex, Currency extends string> = {
     tokenAddress: TokenAddress;
     value: number;
     currency: Currency;
+    allTimeHigh?: number;
+    allTimeLow?: number;
+    circulatingSupply?: number;
+    dilutedMarketCap?: number;
+    high1d?: number;
+    low1d?: number;
+    marketCap?: number;
+    marketCapPercentChange1d?: number;
+    price?: number;
+    priceChange1d?: number;
+    pricePercentChange1d?: number;
+    pricePercentChange1h?: number;
+    pricePercentChange1y?: number;
+    pricePercentChange7d?: number;
+    pricePercentChange14d?: number;
+    pricePercentChange30d?: number;
+    pricePercentChange200d?: number;
+    totalVolume?: number;
 };
 /**
  * A map of token address to its price.
diff --git a/dist/types/token-prices-service/abstract-token-prices-service.d.ts.map b/dist/types/token-prices-service/abstract-token-prices-service.d.ts.map
index bc62078a60f80b757ed497b8d1207fdb314d549f..42370dfd9542fb462c605b4a5bececaff15a9351 100644
--- a/dist/types/token-prices-service/abstract-token-prices-service.d.ts.map
+++ b/dist/types/token-prices-service/abstract-token-prices-service.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"abstract-token-prices-service.d.ts","sourceRoot":"","sources":["../../../src/token-prices-service/abstract-token-prices-service.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAE3C;;GAEG;AACH,MAAM,MAAM,UAAU,CAAC,YAAY,SAAS,GAAG,EAAE,QAAQ,SAAS,MAAM,IAAI;IAC1E,YAAY,EAAE,YAAY,CAAC;IAC3B,KAAK,EAAE,MAAM,CAAC;IACd,QAAQ,EAAE,QAAQ,CAAC;CACpB,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,yBAAyB,CACnC,YAAY,SAAS,GAAG,EACxB,QAAQ,SAAS,MAAM,IACrB;KACD,CAAC,IAAI,YAAY,GAAG,UAAU,CAAC,CAAC,EAAE,QAAQ,CAAC;CAC7C,CAAC;AAEF;;;;;;;;;;;;GAYG;AACH,MAAM,MAAM,0BAA0B,CACpC,OAAO,SAAS,GAAG,GAAG,GAAG,EACzB,YAAY,SAAS,GAAG,GAAG,GAAG,EAC9B,QAAQ,SAAS,MAAM,GAAG,MAAM,IAC9B;IACF;;;;;;;;;OASG;IACH,gBAAgB,CAAC,EACf,OAAO,EACP,cAAc,EACd,QAAQ,GACT,EAAE;QACD,OAAO,EAAE,OAAO,CAAC;QACjB,cAAc,EAAE,YAAY,EAAE,CAAC;QAC/B,QAAQ,EAAE,QAAQ,CAAC;KACpB,GAAG,OAAO,CAAC,OAAO,CAAC,yBAAyB,CAAC,YAAY,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;IAExE;;;;;;OAMG;IACH,wBAAwB,CAAC,OAAO,EAAE,OAAO,GAAG,OAAO,IAAI,OAAO,CAAC;IAE/D;;;;;;OAMG;IACH,yBAAyB,CAAC,QAAQ,EAAE,OAAO,GAAG,QAAQ,IAAI,QAAQ,CAAC;CACpE,CAAC"}
\ No newline at end of file
+{"version":3,"file":"abstract-token-prices-service.d.ts","sourceRoot":"","sources":["../../../src/token-prices-service/abstract-token-prices-service.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAE3C;;GAEG;AACH,MAAM,MAAM,UAAU,CAAC,YAAY,SAAS,GAAG,EAAE,QAAQ,SAAS,MAAM,IAAI;IAC1E,YAAY,EAAE,YAAY,CAAC;IAC3B,KAAK,EAAE,MAAM,CAAC;IACd,QAAQ,EAAE,QAAQ,CAAC;IACnB,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,iBAAiB,CAAC,EAAE,MAAM,CAAC;IAC3B,gBAAgB,CAAC,EAAE,MAAM,CAAC;IAC1B,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,wBAAwB,CAAC,EAAE,MAAM,CAAC;IAClC,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,aAAa,CAAC,EAAE,MAAM,CAAC;IACvB,oBAAoB,CAAC,EAAE,MAAM,CAAC;IAC9B,oBAAoB,CAAC,EAAE,MAAM,CAAC;IAC9B,oBAAoB,CAAC,EAAE,MAAM,CAAC;IAC9B,oBAAoB,CAAC,EAAE,MAAM,CAAC;IAC9B,qBAAqB,CAAC,EAAE,MAAM,CAAC;IAC/B,qBAAqB,CAAC,EAAE,MAAM,CAAC;IAC/B,sBAAsB,CAAC,EAAE,MAAM,CAAC;IAChC,WAAW,CAAC,EAAE,MAAM,CAAC;CACtB,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,yBAAyB,CACnC,YAAY,SAAS,GAAG,EACxB,QAAQ,SAAS,MAAM,IACrB;KACD,CAAC,IAAI,YAAY,GAAG,UAAU,CAAC,CAAC,EAAE,QAAQ,CAAC;CAC7C,CAAC;AAEF;;;;;;;;;;;;GAYG;AACH,MAAM,MAAM,0BAA0B,CACpC,OAAO,SAAS,GAAG,GAAG,GAAG,EACzB,YAAY,SAAS,GAAG,GAAG,GAAG,EAC9B,QAAQ,SAAS,MAAM,GAAG,MAAM,IAC9B;IACF;;;;;;;;;OASG;IACH,gBAAgB,CAAC,EACf,OAAO,EACP,cAAc,EACd,QAAQ,GACT,EAAE;QACD,OAAO,EAAE,OAAO,CAAC;QACjB,cAAc,EAAE,YAAY,EAAE,CAAC;QAC/B,QAAQ,EAAE,QAAQ,CAAC;KACpB,GAAG,OAAO,CAAC,OAAO,CAAC,yBAAyB,CAAC,YAAY,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;IAExE;;;;;;OAMG;IACH,wBAAwB,CAAC,OAAO,EAAE,OAAO,GAAG,OAAO,IAAI,OAAO,CAAC;IAE/D;;;;;;OAMG;IACH,yBAAyB,CAAC,QAAQ,EAAE,OAAO,GAAG,QAAQ,IAAI,QAAQ,CAAC;CACpE,CAAC"}
\ No newline at end of file
diff --git a/dist/types/token-prices-service/codefi-v2.d.ts.map b/dist/types/token-prices-service/codefi-v2.d.ts.map
index b644474c88a07d4b9dd0b2707d25490bbbcdd002..1f05a39d62972b0835426e5bd8127b131af4c6fc 100644
--- a/dist/types/token-prices-service/codefi-v2.d.ts.map
+++ b/dist/types/token-prices-service/codefi-v2.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"codefi-v2.d.ts","sourceRoot":"","sources":["../../../src/token-prices-service/codefi-v2.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAa3C,OAAO,KAAK,EACV,0BAA0B,EAE1B,yBAAyB,EAC1B,MAAM,iCAAiC,CAAC;AAUzC;;;GAGG;AACH,eAAO,MAAM,oBAAoB,ybA2HvB,CAAC;AAEX;;;GAGG;AACH,KAAK,iBAAiB,GAClB,CAAC,OAAO,oBAAoB,CAAC,CAAC,MAAM,CAAC,GACrC,SAAS,CAAC,CAAC,OAAO,oBAAoB,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;AAErD;;;;;GAKG;AACH,eAAO,MAAM,mBAAmB,sTAmEtB,CAAC;AAEX;;;;GAIG;AACH,KAAK,gBAAgB,GAAG,CAAC,OAAO,mBAAmB,CAAC,CAAC,MAAM,CAAC,CAAC;AAc7D;;;GAGG;AACH,qBAAa,0BACX,YACE,0BAA0B,CAAC,gBAAgB,EAAE,GAAG,EAAE,iBAAiB,CAAC;;IAItE;;;;;;;;;;;;;;;OAeG;gBACS,EACV,iBAA8C,EAC9C,OAAqC,EACrC,0BAAyE,EACzE,OAAO,EACP,UAAU,EACV,oBAAqC,GACtC,GAAE;QACD,iBAAiB,CAAC,EAAE,MAAM,CAAC;QAC3B,OAAO,CAAC,EAAE,MAAM,CAAC;QACjB,0BAA0B,CAAC,EAAE,MAAM,CAAC;QACpC,OAAO,CAAC,EAAE,MAAM,IAAI,CAAC;QACrB,UAAU,CAAC,EAAE,MAAM,IAAI,CAAC;QACxB,oBAAoB,CAAC,EAAE,MAAM,CAAC;KAC1B;IAgCN;;;;;;;;;OASG;IACG,gBAAgB,CAAC,EACrB,OAAO,EACP,cAAc,EACd,QAAQ,GACT,EAAE;QACD,OAAO,EAAE,gBAAgB,CAAC;QAC1B,cAAc,EAAE,GAAG,EAAE,CAAC;QACtB,QAAQ,EAAE,iBAAiB,CAAC;KAC7B,GAAG,OAAO,CAAC,OAAO,CAAC,yBAAyB,CAAC,GAAG,EAAE,iBAAiB,CAAC,CAAC,CAAC;IAuDvE;;;;;;OAMG;IACH,wBAAwB,CAAC,OAAO,EAAE,OAAO,GAAG,OAAO,IAAI,gBAAgB;IAKvE;;;;;;;OAOG;IACH,yBAAyB,CAAC,QAAQ,EAAE,OAAO,GAAG,QAAQ,IAAI,iBAAiB;CAO5E"}
\ No newline at end of file
+{"version":3,"file":"codefi-v2.d.ts","sourceRoot":"","sources":["../../../src/token-prices-service/codefi-v2.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAa3C,OAAO,KAAK,EACV,0BAA0B,EAE1B,yBAAyB,EAC1B,MAAM,iCAAiC,CAAC;AAEzC;;;GAGG;AACH,eAAO,MAAM,oBAAoB,ybA2HvB,CAAC;AAEX;;;GAGG;AACH,KAAK,iBAAiB,GAClB,CAAC,OAAO,oBAAoB,CAAC,CAAC,MAAM,CAAC,GACrC,SAAS,CAAC,CAAC,OAAO,oBAAoB,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;AAErD;;;;;GAKG;AACH,eAAO,MAAM,mBAAmB,sTAmEtB,CAAC;AAEX;;;;GAIG;AACH,KAAK,gBAAgB,GAAG,CAAC,OAAO,mBAAmB,CAAC,CAAC,MAAM,CAAC,CAAC;AAqC7D;;;GAGG;AACH,qBAAa,0BACX,YACE,0BAA0B,CAAC,gBAAgB,EAAE,GAAG,EAAE,iBAAiB,CAAC;;IAItE;;;;;;;;;;;;;;;OAeG;gBACS,EACV,iBAA8C,EAC9C,OAAqC,EACrC,0BAAyE,EACzE,OAAO,EACP,UAAU,EACV,oBAAqC,GACtC,GAAE;QACD,iBAAiB,CAAC,EAAE,MAAM,CAAC;QAC3B,OAAO,CAAC,EAAE,MAAM,CAAC;QACjB,0BAA0B,CAAC,EAAE,MAAM,CAAC;QACpC,OAAO,CAAC,EAAE,MAAM,IAAI,CAAC;QACrB,UAAU,CAAC,EAAE,MAAM,IAAI,CAAC;QACxB,oBAAoB,CAAC,EAAE,MAAM,CAAC;KAC1B;IAgCN;;;;;;;;;OASG;IACG,gBAAgB,CAAC,EACrB,OAAO,EACP,cAAc,EACd,QAAQ,GACT,EAAE;QACD,OAAO,EAAE,gBAAgB,CAAC;QAC1B,cAAc,EAAE,GAAG,EAAE,CAAC;QACtB,QAAQ,EAAE,iBAAiB,CAAC;KAC7B,GAAG,OAAO,CAAC,OAAO,CAAC,yBAAyB,CAAC,GAAG,EAAE,iBAAiB,CAAC,CAAC,CAAC;IAsFvE;;;;;;OAMG;IACH,wBAAwB,CAAC,OAAO,EAAE,OAAO,GAAG,OAAO,IAAI,gBAAgB;IAKvE;;;;;;;OAOG;IACH,yBAAyB,CAAC,QAAQ,EAAE,OAAO,GAAG,QAAQ,IAAI,iBAAiB;CAO5E"}
\ No newline at end of file
diff --git a/dist/types/token-service.d.ts.map b/dist/types/token-service.d.ts.map
index 97c27090133ba91b25cb54252e28606c59c5e2d7..1fe3dd4b6cc202a3c60b4b6d19eb91bde23ec0a8 100644
--- a/dist/types/token-service.d.ts.map
+++ b/dist/types/token-service.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"token-service.d.ts","sourceRoot":"","sources":["../../src/token-service.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAI3C,eAAO,MAAM,mBAAmB,8CAA8C,CAAC;AAC/E,eAAO,MAAM,+BAA+B,oEACuB,CAAC;AAiCpE;;;;;;;;;GASG;AACH,wBAAsB,uBAAuB,CAC3C,OAAO,EAAE,GAAG,EACZ,WAAW,EAAE,WAAW,EACxB,EAAE,OAAwB,EAAE;;CAAK,GAChC,OAAO,CAAC,OAAO,CAAC,CAOlB;AAED;;;;;;;;;;GAUG;AACH,wBAAsB,kBAAkB,CAAC,CAAC,EACxC,OAAO,EAAE,GAAG,EACZ,YAAY,EAAE,MAAM,EACpB,WAAW,EAAE,WAAW,EACxB,EAAE,OAAwB,EAAE;;CAAK,GAChC,OAAO,CAAC,CAAC,GAAG,SAAS,CAAC,CAUxB"}
\ No newline at end of file
+{"version":3,"file":"token-service.d.ts","sourceRoot":"","sources":["../../src/token-service.ts"],"names":[],"mappings":"AAKA,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAI3C,eAAO,MAAM,mBAAmB,8CAA8C,CAAC;AAC/E,eAAO,MAAM,+BAA+B,oEACuB,CAAC;AAkCpE;;;;;;;;;GASG;AACH,wBAAsB,uBAAuB,CAC3C,OAAO,EAAE,GAAG,EACZ,WAAW,EAAE,WAAW,EACxB,EAAE,OAAwB,EAAE;;CAAK,GAChC,OAAO,CAAC,OAAO,CAAC,CAclB;AAED;;;;;;;;;;GAUG;AACH,wBAAsB,kBAAkB,CAAC,CAAC,EACxC,OAAO,EAAE,GAAG,EACZ,YAAY,EAAE,MAAM,EACpB,WAAW,EAAE,WAAW,EACxB,EAAE,OAAwB,EAAE;;CAAK,GAChC,OAAO,CAAC,CAAC,GAAG,SAAS,CAAC,CAUxB"}
\ No newline at end of file
